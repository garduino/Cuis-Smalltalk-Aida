'From Cuis 4.1 of 12 December 2012 [latest update: #1561] on 20 January 2013 at 7:49:29 pm'!
'Description Please enter a description for this package '!
!classDefinition: #AIDAModelAdaptorTest category: #'Aida-Tests'!
TestCase subclass: #AIDAModelAdaptorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'AIDAModelAdaptorTest class' category: #'Aida-Tests'!
AIDAModelAdaptorTest class
	instanceVariableNames: ''!

!classDefinition: #AIDASite category: #'Aida-Core'!
SwazooSite subclass: #AIDASite
	instanceVariableNames: 'style settings systemServices userServices timestamps counters other'
	classVariableNames: 'Default Dialect HourlySnapshot LastPreSnapshot LastSnapshot RandomGen SloveneCharacters'
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'AIDASite class' category: #'Aida-Core'!
AIDASite class
	instanceVariableNames: ''!

!classDefinition: #AIDASiteTest category: #'Aida-Tests'!
TestCase subclass: #AIDASiteTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'AIDASiteTest class' category: #'Aida-Tests'!
AIDASiteTest class
	instanceVariableNames: ''!

!classDefinition: #Address category: #'Aida-Parties'!
Object subclass: #Address
	instanceVariableNames: 'title firstName middleName lastName company street city stateProvince postalCode country phones fax emails web'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Parties'!
!classDefinition: 'Address class' category: #'Aida-Parties'!
Address class
	instanceVariableNames: ''!

!classDefinition: #AdvancedSearch category: #'Aida-Support'!
Object subclass: #AdvancedSearch
	instanceVariableNames: 'criteria results colMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Support'!
!classDefinition: 'AdvancedSearch class' category: #'Aida-Support'!
AdvancedSearch class
	instanceVariableNames: ''!

!classDefinition: #AidaModelAdaptor category: #'Aida-Internal'!
Object subclass: #AidaModelAdaptor
	instanceVariableNames: 'subject aspect index format buffer changed validationBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'AidaModelAdaptor class' category: #'Aida-Internal'!
AidaModelAdaptor class
	instanceVariableNames: ''!

!classDefinition: #AidaModelNullAdaptor category: #'Aida-Internal'!
ProtoObject subclass: #AidaModelNullAdaptor
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'AidaModelNullAdaptor class' category: #'Aida-Internal'!
AidaModelNullAdaptor class
	instanceVariableNames: ''!

!classDefinition: #AidaMutex category: #'Aida-Internal'!
Object subclass: #AidaMutex
	instanceVariableNames: 'semaphore owner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'AidaMutex class' category: #'Aida-Internal'!
AidaMutex class
	instanceVariableNames: ''!

!classDefinition: #AidaProfiling category: #'Aida-Tests'!
Object subclass: #AidaProfiling
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'AidaProfiling class' category: #'Aida-Tests'!
AidaProfiling class
	instanceVariableNames: ''!

!classDefinition: #DailyCollection category: #'Aida-Support'!
Object subclass: #DailyCollection
	instanceVariableNames: 'days'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Support'!
!classDefinition: 'DailyCollection class' category: #'Aida-Support'!
DailyCollection class
	instanceVariableNames: ''!

!classDefinition: #DailyValues category: #'Aida-Support'!
Object subclass: #DailyValues
	instanceVariableNames: 'days'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Support'!
!classDefinition: 'DailyValues class' category: #'Aida-Support'!
DailyValues class
	instanceVariableNames: ''!

!classDefinition: #DefaultAuthenticator category: #'Aida-Internal'!
Object subclass: #DefaultAuthenticator
	instanceVariableNames: 'site'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'DefaultAuthenticator class' category: #'Aida-Internal'!
DefaultAuthenticator class
	instanceVariableNames: ''!

!classDefinition: #DelimitedFile category: #'Aida-Support'!
Object subclass: #DelimitedFile
	instanceVariableNames: 'filename delimiter codepage records'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Support'!
!classDefinition: 'DelimitedFile class' category: #'Aida-Support'!
DelimitedFile class
	instanceVariableNames: ''!

!classDefinition: #DocLink category: #'Aida-Internal'!
Object subclass: #DocLink
	instanceVariableNames: 'title url object'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'DocLink class' category: #'Aida-Internal'!
DocLink class
	instanceVariableNames: ''!

!classDefinition: #EMailMessenger category: #'Aida-Support'!
Object subclass: #EMailMessenger
	instanceVariableNames: 'repository queue sendingLoop client mailbox receivingLoop'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Support'!
!classDefinition: 'EMailMessenger class' category: #'Aida-Support'!
EMailMessenger class
	instanceVariableNames: ''!

!classDefinition: #FileProxy category: #'Aida-Internal'!
Object subclass: #FileProxy
	instanceVariableNames: 'site filename timestamps content contentType size caching codepage elements bodyTagIndex imgTagIndexes linkTagIndexes servletTagIndexes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'FileProxy class' category: #'Aida-Internal'!
FileProxy class
	instanceVariableNames: ''!

!classDefinition: #HistoryOfValue category: #'Aida-Support'!
Object subclass: #HistoryOfValue
	instanceVariableNames: 'dates values changedDates authors comments historyCollection'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Support'!
!classDefinition: 'HistoryOfValue class' category: #'Aida-Support'!
HistoryOfValue class
	instanceVariableNames: ''!

!classDefinition: #ImageStream category: #'Aida-Imaging'!
Object subclass: #ImageStream
	instanceVariableNames: 'imageStream progressValue'
	classVariableNames: 'ColorPalette256 GrayPalette256 ImageKindTable'
	poolDictionaries: ''
	category: 'Aida-Imaging'!
!classDefinition: 'ImageStream class' category: #'Aida-Imaging'!
ImageStream class
	instanceVariableNames: ''!

!classDefinition: #BmpImageStream category: #'Aida-Imaging'!
ImageStream subclass: #BmpImageStream
	instanceVariableNames: 'bfType bfSize bfReserved1 bfReserved2 bfOffBits biSize biWidth biHeight biPlanes biBitCount biCompression biSizeImage biXPelsPerMeter biYPelsPerMeter biClrUsed biClrImportant imagePalette imageObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Imaging'!
!classDefinition: 'BmpImageStream class' category: #'Aida-Imaging'!
BmpImageStream class
	instanceVariableNames: ''!

!classDefinition: #BosImageStream category: #'Aida-Imaging'!
ImageStream subclass: #BosImageStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Imaging'!
!classDefinition: 'BosImageStream class' category: #'Aida-Imaging'!
BosImageStream class
	instanceVariableNames: ''!

!classDefinition: #GifImageStream category: #'Aida-Imaging'!
ImageStream subclass: #GifImageStream
	instanceVariableNames: 'width height bitsPerPixel colorPalette rowByteSize xpos ypos pass interlace codeSize clearCode eoiCode freeCode maxCode prefixTable suffixTable remainBitCount bufByte bufStream transparentPixel'
	classVariableNames: 'Extension GraphicControlLabel ImageSeparator Terminator'
	poolDictionaries: ''
	category: 'Aida-Imaging'!
!classDefinition: 'GifImageStream class' category: #'Aida-Imaging'!
GifImageStream class
	instanceVariableNames: ''!

!classDefinition: #MIMEMap category: #'Aida-Internal'!
Object subclass: #MIMEMap
	instanceVariableNames: 'mimeTypes fileExtensions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'MIMEMap class' category: #'Aida-Internal'!
MIMEMap class
	instanceVariableNames: ''!

!classDefinition: #Numberer category: #'Aida-Support'!
Object subclass: #Numberer
	instanceVariableNames: 'counters'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Support'!
!classDefinition: 'Numberer class' category: #'Aida-Support'!
Numberer class
	instanceVariableNames: ''!

!classDefinition: #PartiesTest category: #'Aida-Tests'!
TestCase subclass: #PartiesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'PartiesTest class' category: #'Aida-Tests'!
PartiesTest class
	instanceVariableNames: ''!

!classDefinition: #Party category: #'Aida-Parties'!
Object subclass: #Party
	instanceVariableNames: 'id name description addresses roles relatedPartyRoles events relatedObjects other'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Parties'!
!classDefinition: 'Party class' category: #'Aida-Parties'!
Party class
	instanceVariableNames: ''!

!classDefinition: #OrganizationUnit category: #'Aida-Parties'!
Party subclass: #OrganizationUnit
	instanceVariableNames: 'type parent units specialRoles'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Parties'!
!classDefinition: 'OrganizationUnit class' category: #'Aida-Parties'!
OrganizationUnit class
	instanceVariableNames: ''!

!classDefinition: #Company category: #'Aida-Parties'!
OrganizationUnit subclass: #Company
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Parties'!
!classDefinition: 'Company class' category: #'Aida-Parties'!
Company class
	instanceVariableNames: ''!

!classDefinition: #PartyCollection category: #'Aida-Parties'!
Object subclass: #PartyCollection
	instanceVariableNames: 'parent parties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Parties'!
!classDefinition: 'PartyCollection class' category: #'Aida-Parties'!
PartyCollection class
	instanceVariableNames: ''!

!classDefinition: #Person category: #'Aida-Parties'!
Party subclass: #Person
	instanceVariableNames: 'surname'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Parties'!
!classDefinition: 'Person class' category: #'Aida-Parties'!
Person class
	instanceVariableNames: ''!

!classDefinition: #Role category: #'Aida-Roles'!
Object subclass: #Role
	instanceVariableNames: 'name party relatedParty other'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Roles'!
!classDefinition: 'Role class' category: #'Aida-Roles'!
Role class
	instanceVariableNames: ''!

!classDefinition: #MemberRole category: #'Aida-Roles'!
Role subclass: #MemberRole
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Roles'!
!classDefinition: 'MemberRole class' category: #'Aida-Roles'!
MemberRole class
	instanceVariableNames: ''!

!classDefinition: #RoleGroup category: #'Aida-Roles'!
Object subclass: #RoleGroup
	instanceVariableNames: 'name subroles'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Roles'!
!classDefinition: 'RoleGroup class' category: #'Aida-Roles'!
RoleGroup class
	instanceVariableNames: ''!

!classDefinition: #SchedulerTest category: #'Aida-Tests'!
TestCase subclass: #SchedulerTest
	instanceVariableNames: 'scheduler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'SchedulerTest class' category: #'Aida-Tests'!
SchedulerTest class
	instanceVariableNames: ''!

!classDefinition: #SwazooAida category: #'Aida-Core'!
Object subclass: #SwazooAida
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'SwazooAida class' category: #'Aida-Core'!
SwazooAida class
	instanceVariableNames: ''!

!classDefinition: #SwazooIntegrationTest category: #'Aida-Tests'!
TestCase subclass: #SwazooIntegrationTest
	instanceVariableNames: 'server site'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'SwazooIntegrationTest class' category: #'Aida-Tests'!
SwazooIntegrationTest class
	instanceVariableNames: ''!

!classDefinition: #URLResolver category: #'Aida-Core'!
Object subclass: #URLResolver
	instanceVariableNames: 'site allWebPages allURLLinks counters totalCounter randomGen'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'URLResolver class' category: #'Aida-Core'!
URLResolver class
	instanceVariableNames: ''!

!classDefinition: #URLResolverTest category: #'Aida-Tests'!
TestCase subclass: #URLResolverTest
	instanceVariableNames: 'server site'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'URLResolverTest class' category: #'Aida-Tests'!
URLResolverTest class
	instanceVariableNames: ''!

!classDefinition: #VersionSpec category: #'Aida-Internal'!
Object subclass: #VersionSpec
	instanceVariableNames: 'object number current parent next'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'VersionSpec class' category: #'Aida-Internal'!
VersionSpec class
	instanceVariableNames: ''!

!classDefinition: #VersionSpecTest category: #'Aida-Tests'!
TestCase subclass: #VersionSpecTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'VersionSpecTest class' category: #'Aida-Tests'!
VersionSpecTest class
	instanceVariableNames: ''!

!classDefinition: #VersionedExample category: #'Aida-Tests'!
ProtoObject subclass: #VersionedExample
	instanceVariableNames: 'title body'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'VersionedExample class' category: #'Aida-Tests'!
VersionedExample class
	instanceVariableNames: ''!

!classDefinition: #VersionedObject category: #'Aida-Internal'!
Object subclass: #VersionedObject
	instanceVariableNames: 'version'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'VersionedObject class' category: #'Aida-Internal'!
VersionedObject class
	instanceVariableNames: ''!

!classDefinition: #VersionedObjectTest category: #'Aida-Tests'!
TestCase subclass: #VersionedObjectTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'VersionedObjectTest class' category: #'Aida-Tests'!
VersionedObjectTest class
	instanceVariableNames: ''!

!classDefinition: #WebAnchor category: #'Aida-Elements'!
ProtoObject subclass: #WebAnchor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebAnchor class' category: #'Aida-Elements'!
WebAnchor class
	instanceVariableNames: ''!

!classDefinition: #WebApplication category: #'Aida-Applications'!
Object subclass: #WebApplication
	instanceVariableNames: 'session observee contexts other'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Applications'!
!classDefinition: 'WebApplication class' category: #'Aida-Applications'!
WebApplication class
	instanceVariableNames: ''!

!classDefinition: #VersionedExampleApp category: #'Aida-Tests'!
WebApplication subclass: #VersionedExampleApp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'VersionedExampleApp class' category: #'Aida-Tests'!
VersionedExampleApp class
	instanceVariableNames: ''!

!classDefinition: #WebApplicationTest category: #'Aida-Tests'!
TestCase subclass: #WebApplicationTest
	instanceVariableNames: 'server site session app request'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'WebApplicationTest class' category: #'Aida-Tests'!
WebApplicationTest class
	instanceVariableNames: ''!

!classDefinition: #WebAutocomplete2Field category: #'Aida-Widgets'!
ProtoObject subclass: #WebAutocomplete2Field
	instanceVariableNames: 'choicesAspect choicesObject choiceAspect elementToUpdate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebAutocomplete2Field class' category: #'Aida-Widgets'!
WebAutocomplete2Field class
	instanceVariableNames: ''!

!classDefinition: #WebAutocompleteField category: #'Aida-Widgets'!
ProtoObject subclass: #WebAutocompleteField
	instanceVariableNames: 'choicesAspect choicesObject choiceAspect elementToUpdate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebAutocompleteField class' category: #'Aida-Widgets'!
WebAutocompleteField class
	instanceVariableNames: ''!

!classDefinition: #WebButton category: #'Aida-Elements'!
ProtoObject subclass: #WebButton
	instanceVariableNames: 'type image size'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebButton class' category: #'Aida-Elements'!
WebButton class
	instanceVariableNames: ''!

!classDefinition: #WebCache category: #'Aida-Internal'!
Object subclass: #WebCache
	instanceVariableNames: 'objects other settings parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebCache class' category: #'Aida-Internal'!
WebCache class
	instanceVariableNames: ''!

!classDefinition: #WebCacheEntry category: #'Aida-Internal'!
Object subclass: #WebCacheEntry
	instanceVariableNames: 'content created timeout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebCacheEntry class' category: #'Aida-Internal'!
WebCacheEntry class
	instanceVariableNames: ''!

!classDefinition: #WebCaptcha category: #'Aida-Imaging'!
ProtoObject subclass: #WebCaptcha
	instanceVariableNames: 'text random'
	classVariableNames: 'Cache'
	poolDictionaries: ''
	category: 'Aida-Imaging'!
!classDefinition: 'WebCaptcha class' category: #'Aida-Imaging'!
WebCaptcha class
	instanceVariableNames: ''!

!classDefinition: #WebChat category: #'Aida-Demos'!
Object subclass: #WebChat
	instanceVariableNames: 'lines announcers'
	classVariableNames: 'Singleton'
	poolDictionaries: ''
	category: 'Aida-Demos'!
!classDefinition: 'WebChat class' category: #'Aida-Demos'!
WebChat class
	instanceVariableNames: ''!

!classDefinition: #WebChatApp category: #'Aida-Demos'!
WebApplication subclass: #WebChatApp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Demos'!
!classDefinition: 'WebChatApp class' category: #'Aida-Demos'!
WebChatApp class
	instanceVariableNames: ''!

!classDefinition: #WebCheckBox category: #'Aida-Elements'!
ProtoObject subclass: #WebCheckBox
	instanceVariableNames: 'checked selected'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebCheckBox class' category: #'Aida-Elements'!
WebCheckBox class
	instanceVariableNames: ''!

!classDefinition: #WebClipboard category: #'Aida-Internal'!
Object subclass: #WebClipboard
	instanceVariableNames: 'title url object'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebClipboard class' category: #'Aida-Internal'!
WebClipboard class
	instanceVariableNames: ''!

!classDefinition: #WebCommand category: #'Aida-Internal'!
Object subclass: #WebCommand
	instanceVariableNames: 'command context element value other'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebCommand class' category: #'Aida-Internal'!
WebCommand class
	instanceVariableNames: ''!

!classDefinition: #WebContext category: #'Aida-Internal'!
Object subclass: #WebContext
	instanceVariableNames: 'id parent child state window ids nextId process semaphore event answer result'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebContext class' category: #'Aida-Internal'!
WebContext class
	instanceVariableNames: ''!

!classDefinition: #WebContextFirst category: #'Aida-Internal'!
ProtoObject subclass: #WebContextFirst
	instanceVariableNames: 'view mainSemaphore'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebContextFirst class' category: #'Aida-Internal'!
WebContextFirst class
	instanceVariableNames: ''!

!classDefinition: #WebCounter category: #'Aida-Internal'!
Object subclass: #WebCounter
	instanceVariableNames: 'started day year dailyCounts hourlyCounts todayHourlyCounts total yearlyHistory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebCounter class' category: #'Aida-Internal'!
WebCounter class
	instanceVariableNames: ''!

!classDefinition: #WebCountry category: #'Aida-i18n'!
Object subclass: #WebCountry
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-i18n'!
!classDefinition: 'WebCountry class' category: #'Aida-i18n'!
WebCountry class
	instanceVariableNames: ''!

!classDefinition: #WebDateInputField category: #'Aida-Widgets'!
ProtoObject subclass: #WebDateInputField
	instanceVariableNames: 'button'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebDateInputField class' category: #'Aida-Widgets'!
WebDateInputField class
	instanceVariableNames: ''!

!classDefinition: #WebDelayedField category: #'Aida-Widgets'!
ProtoObject subclass: #WebDelayedField
	instanceVariableNames: 'delay'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebDelayedField class' category: #'Aida-Widgets'!
WebDelayedField class
	instanceVariableNames: ''!

!classDefinition: #WebDemo category: #'Aida-Demos'!
Object subclass: #WebDemo
	instanceVariableNames: 'introduction date input delayedInput field1 field2 editField content submitValue deleted'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Demos'!
!classDefinition: 'WebDemo class' category: #'Aida-Demos'!
WebDemo class
	instanceVariableNames: ''!

!classDefinition: #WebDemoApp category: #'Aida-Demos'!
WebApplication subclass: #WebDemoApp
	instanceVariableNames: 'liveImage selectedClasses filename fileContentType fileStream startStamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Demos'!
!classDefinition: 'WebDemoApp class' category: #'Aida-Demos'!
WebDemoApp class
	instanceVariableNames: ''!

!classDefinition: #WebElement category: #'Aida-Elements'!
Object subclass: #WebElement
	instanceVariableNames: 'parent elements attributes eventHandlers other'
	classVariableNames: 'Colors'
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebElement class' category: #'Aida-Elements'!
WebElement class
	instanceVariableNames: ''!

!classDefinition: #WebAudio category: #'Aida-Elements'!
WebElement subclass: #WebAudio
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebAudio class' category: #'Aida-Elements'!
WebAudio class
	instanceVariableNames: ''!

!classDefinition: #WebCanvas category: #'Aida-Elements'!
WebElement subclass: #WebCanvas
	instanceVariableNames: 'text'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebCanvas class' category: #'Aida-Elements'!
WebCanvas class
	instanceVariableNames: ''!

!classDefinition: #WebComment category: #'Aida-Elements'!
WebElement subclass: #WebComment
	instanceVariableNames: 'text'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebComment class' category: #'Aida-Elements'!
WebComment class
	instanceVariableNames: ''!

!classDefinition: #WebEvent category: #'Aida-Internal'!
Object subclass: #WebEvent
	instanceVariableNames: 'event element context pageUrl value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebEvent class' category: #'Aida-Internal'!
WebEvent class
	instanceVariableNames: ''!

!classDefinition: #WebEventHandler category: #'Aida-Internal'!
Object subclass: #WebEventHandler
	instanceVariableNames: 'event element actionBlocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebEventHandler class' category: #'Aida-Internal'!
WebEventHandler class
	instanceVariableNames: ''!

!classDefinition: #WebFieldSet category: #'Aida-Elements'!
WebElement subclass: #WebFieldSet
	instanceVariableNames: 'legend'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebFieldSet class' category: #'Aida-Elements'!
WebFieldSet class
	instanceVariableNames: ''!

!classDefinition: #WebFileInputField category: #'Aida-Elements'!
ProtoObject subclass: #WebFileInputField
	instanceVariableNames: 'filenameAspect contentTypeAspect writeStream writeBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebFileInputField class' category: #'Aida-Elements'!
WebFileInputField class
	instanceVariableNames: ''!

!classDefinition: #WebFileInputTest category: #'Aida-Tests'!
TestCase subclass: #WebFileInputTest
	instanceVariableNames: 'file filename'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'WebFileInputTest class' category: #'Aida-Tests'!
WebFileInputTest class
	instanceVariableNames: ''!

!classDefinition: #WebForm category: #'Aida-Elements'!
WebElement subclass: #WebForm
	instanceVariableNames: 'fields action tabOrder superform subforms'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebForm class' category: #'Aida-Elements'!
WebForm class
	instanceVariableNames: ''!

!classDefinition: #WebFormElement category: #'Aida-Elements'!
WebElement subclass: #WebFormElement
	instanceVariableNames: 'adaptor enterTabForm'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebFormElement class' category: #'Aida-Elements'!
WebFormElement class
	instanceVariableNames: ''!

!classDefinition: #WebGeolocation category: #'Aida-Internal'!
Object subclass: #WebGeolocation
	instanceVariableNames: 'timestamp latitude longitude accuracy altitude latitudeAccuracy heading speed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebGeolocation class' category: #'Aida-Internal'!
WebGeolocation class
	instanceVariableNames: ''!

!classDefinition: #WebGridColumn category: #'Aida-Widgets'!
Object subclass: #WebGridColumn
	instanceVariableNames: 'parent id name width align aspect linkAspect linkView viewBlock addBlock sorted filter filterWidth summaryType summary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebGridColumn class' category: #'Aida-Widgets'!
WebGridColumn class
	instanceVariableNames: ''!

!classDefinition: #WebIFrame category: #'Aida-Elements'!
WebElement subclass: #WebIFrame
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebIFrame class' category: #'Aida-Elements'!
WebIFrame class
	instanceVariableNames: ''!

!classDefinition: #WebImage category: #'Aida-Elements'!
WebElement subclass: #WebImage
	instanceVariableNames: 'image imageMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebImage class' category: #'Aida-Elements'!
WebImage class
	instanceVariableNames: ''!

!classDefinition: #WebImageMap category: #'Aida-Elements'!
WebElement subclass: #WebImageMap
	instanceVariableNames: 'areas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebImageMap class' category: #'Aida-Elements'!
WebImageMap class
	instanceVariableNames: ''!

!classDefinition: #WebInPlaceEditable2Text category: #'Aida-Widgets'!
ProtoObject subclass: #WebInPlaceEditable2Text
	instanceVariableNames: 'size attribute formated allow triggerElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebInPlaceEditable2Text class' category: #'Aida-Widgets'!
WebInPlaceEditable2Text class
	instanceVariableNames: ''!

!classDefinition: #WebInPlaceEditableText category: #'Aida-Widgets'!
ProtoObject subclass: #WebInPlaceEditableText
	instanceVariableNames: 'size attribute formated allow triggerElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebInPlaceEditableText class' category: #'Aida-Widgets'!
WebInPlaceEditableText class
	instanceVariableNames: ''!

!classDefinition: #WebIndex category: #'Aida-Core'!
Object subclass: #WebIndex
	instanceVariableNames: 'index indexedObjects popularWords workQueue indexer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'WebIndex class' category: #'Aida-Core'!
WebIndex class
	instanceVariableNames: ''!

!classDefinition: #WebInputField category: #'Aida-Elements'!
ProtoObject subclass: #WebInputField
	instanceVariableNames: 'size maxLength type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebInputField class' category: #'Aida-Elements'!
WebInputField class
	instanceVariableNames: ''!

!classDefinition: #WebJSON category: #'Aida-Internal'!
Object subclass: #WebJSON
	instanceVariableNames: 'stream ctorMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebJSON class' category: #'Aida-Internal'!
WebJSON class
	instanceVariableNames: ''!

!classDefinition: #WebJSONPresenter category: #'Aida-Internal'!
Object subclass: #WebJSONPresenter
	instanceVariableNames: 'session observee presenterBlock other'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebJSONPresenter class' category: #'Aida-Internal'!
WebJSONPresenter class
	instanceVariableNames: ''!

!classDefinition: #WebJSONTest category: #'Aida-Tests'!
TestCase subclass: #WebJSONTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'WebJSONTest class' category: #'Aida-Tests'!
WebJSONTest class
	instanceVariableNames: ''!

!classDefinition: #WebLabel category: #'Aida-Elements'!
WebElement subclass: #WebLabel
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebLabel class' category: #'Aida-Elements'!
WebLabel class
	instanceVariableNames: ''!

!classDefinition: #WebLanguage category: #'Aida-i18n'!
Object subclass: #WebLanguage
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-i18n'!
!classDefinition: 'WebLanguage class' category: #'Aida-i18n'!
WebLanguage class
	instanceVariableNames: ''!

!classDefinition: #WebLink category: #'Aida-Elements'!
ProtoObject subclass: #WebLink
	instanceVariableNames: 'ooReference urlReference parms anchor security'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebLink class' category: #'Aida-Elements'!
WebLink class
	instanceVariableNames: ''!

!classDefinition: #WebList category: #'Aida-Elements'!
WebElement subclass: #WebList
	instanceVariableNames: 'name kind type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebList class' category: #'Aida-Elements'!
WebList class
	instanceVariableNames: ''!

!classDefinition: #WebListItem category: #'Aida-Elements'!
WebElement subclass: #WebListItem
	instanceVariableNames: 'tag'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebListItem class' category: #'Aida-Elements'!
WebListItem class
	instanceVariableNames: ''!

!classDefinition: #WebLiveImage category: #'Aida-Imaging'!
ProtoObject subclass: #WebLiveImage
	instanceVariableNames: 'gif refreshed width height painter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Imaging'!
!classDefinition: 'WebLiveImage class' category: #'Aida-Imaging'!
WebLiveImage class
	instanceVariableNames: ''!

!classDefinition: #WebGraph category: #'Aida-Imaging'!
WebLiveImage subclass: #WebGraph
	instanceVariableNames: 'data margin title graphics'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Imaging'!
!classDefinition: 'WebGraph class' category: #'Aida-Imaging'!
WebGraph class
	instanceVariableNames: ''!

!classDefinition: #WebLivePDFCreator category: #'Aida-Widgets'!
ProtoObject subclass: #WebLivePDFCreator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebLivePDFCreator class' category: #'Aida-Widgets'!
WebLivePDFCreator class
	instanceVariableNames: ''!

!classDefinition: #WebMenu category: #'Aida-Elements'!
ProtoObject subclass: #WebMenu
	instanceVariableNames: 'multiple selected adaptorToStore sort'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebMenu class' category: #'Aida-Elements'!
WebMenu class
	instanceVariableNames: ''!

!classDefinition: #WebMethodImage category: #'Aida-Internal'!
ProtoObject subclass: #WebMethodImage
	instanceVariableNames: 'lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebMethodImage class' category: #'Aida-Internal'!
WebMethodImage class
	instanceVariableNames: 'cache'!

!classDefinition: #WebMethodResource category: #'Aida-Internal'!
Object subclass: #WebMethodResource
	instanceVariableNames: 'site object method contentType preferedUrl'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebMethodResource class' category: #'Aida-Internal'!
WebMethodResource class
	instanceVariableNames: ''!

!classDefinition: #WebMobileApplication category: #'Aida-Applications'!
WebApplication subclass: #WebMobileApplication
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Applications'!
!classDefinition: 'WebMobileApplication class' category: #'Aida-Applications'!
WebMobileApplication class
	instanceVariableNames: ''!

!classDefinition: #WebRadioButton category: #'Aida-Elements'!
ProtoObject subclass: #WebRadioButton
	instanceVariableNames: 'checked'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebRadioButton class' category: #'Aida-Elements'!
WebRadioButton class
	instanceVariableNames: ''!

!classDefinition: #WebRawText category: #'Aida-Elements'!
ProtoObject subclass: #WebRawText
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebRawText class' category: #'Aida-Elements'!
WebRawText class
	instanceVariableNames: ''!

!classDefinition: #WebRealtimeConnection category: #'Aida-Internal'!
Object subclass: #WebRealtimeConnection
	instanceVariableNames: 'type handler connection app view semaphore'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebRealtimeConnection class' category: #'Aida-Internal'!
WebRealtimeConnection class
	instanceVariableNames: ''!

!classDefinition: #WebRealtimeHandler category: #'Aida-Internal'!
Object subclass: #WebRealtimeHandler
	instanceVariableNames: 'session connections'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebRealtimeHandler class' category: #'Aida-Internal'!
WebRealtimeHandler class
	instanceVariableNames: ''!

!classDefinition: #WebRichEditor category: #'Aida-Widgets'!
ProtoObject subclass: #WebRichEditor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebRichEditor class' category: #'Aida-Widgets'!
WebRichEditor class
	instanceVariableNames: ''!

!classDefinition: #WebRouter category: #'Aida-Internal'!
Object subclass: #WebRouter
	instanceVariableNames: 'site routes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebRouter class' category: #'Aida-Internal'!
WebRouter class
	instanceVariableNames: ''!

!classDefinition: #WebScheduledEvent category: #'Aida-Internal'!
Object subclass: #WebScheduledEvent
	instanceVariableNames: 'parent timestamp period method object block'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebScheduledEvent class' category: #'Aida-Internal'!
WebScheduledEvent class
	instanceVariableNames: ''!

!classDefinition: #WebScheduler category: #'Aida-Core'!
Object subclass: #WebScheduler
	instanceVariableNames: 'site queue loop mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'WebScheduler class' category: #'Aida-Core'!
WebScheduler class
	instanceVariableNames: ''!

!classDefinition: #WebScript category: #'Aida-Elements'!
WebElement subclass: #WebScript
	instanceVariableNames: 'script source'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebScript class' category: #'Aida-Elements'!
WebScript class
	instanceVariableNames: ''!

!classDefinition: #WebSecurityManager category: #'Aida-Core'!
Object subclass: #WebSecurityManager
	instanceVariableNames: 'site users groups authenticationScheme accessByObject settings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'WebSecurityManager class' category: #'Aida-Core'!
WebSecurityManager class
	instanceVariableNames: ''!

!classDefinition: #WebSecurityTest category: #'Aida-Tests'!
TestCase subclass: #WebSecurityTest
	instanceVariableNames: 'server site mgr'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'WebSecurityTest class' category: #'Aida-Tests'!
WebSecurityTest class
	instanceVariableNames: ''!

!classDefinition: #WebSeparator category: #'Aida-Elements'!
WebElement subclass: #WebSeparator
	instanceVariableNames: 'type size length'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebSeparator class' category: #'Aida-Elements'!
WebSeparator class
	instanceVariableNames: ''!

!classDefinition: #WebSession category: #'Aida-Core'!
Object subclass: #WebSession
	instanceVariableNames: 'ids created cookies parent user appsForObjects queue userValues other'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'WebSession class' category: #'Aida-Core'!
WebSession class
	instanceVariableNames: ''!

!classDefinition: #WebSessionManager category: #'Aida-Core'!
Object subclass: #WebSessionManager
	instanceVariableNames: 'site sessions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'WebSessionManager class' category: #'Aida-Core'!
WebSessionManager class
	instanceVariableNames: ''!

!classDefinition: #WebSessionMgmtTest category: #'Aida-Tests'!
TestCase subclass: #WebSessionMgmtTest
	instanceVariableNames: 'server site session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Tests'!
!classDefinition: 'WebSessionMgmtTest class' category: #'Aida-Tests'!
WebSessionMgmtTest class
	instanceVariableNames: ''!

!classDefinition: #WebSiteOwnerRole category: #'Aida-Roles'!
Role subclass: #WebSiteOwnerRole
	instanceVariableNames: 'webSite'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Roles'!
!classDefinition: 'WebSiteOwnerRole class' category: #'Aida-Roles'!
WebSiteOwnerRole class
	instanceVariableNames: ''!

!classDefinition: #WebStaticServer category: #'Aida-Internal'!
Object subclass: #WebStaticServer
	instanceVariableNames: 'site files'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebStaticServer class' category: #'Aida-Internal'!
WebStaticServer class
	instanceVariableNames: ''!

!classDefinition: #WebStatistics category: #'Aida-Core'!
Object subclass: #WebStatistics
	instanceVariableNames: 'site referers refererStopList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'WebStatistics class' category: #'Aida-Core'!
WebStatistics class
	instanceVariableNames: ''!

!classDefinition: #WebStubElement category: #'Aida-Elements'!
WebElement subclass: #WebStubElement
	instanceVariableNames: 'multiple collection selected aspectToStore objectToStore sort'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebStubElement class' category: #'Aida-Elements'!
WebStubElement class
	instanceVariableNames: ''!

!classDefinition: #WebTable category: #'Aida-Elements'!
WebElement subclass: #WebTable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebTable class' category: #'Aida-Elements'!
WebTable class
	instanceVariableNames: ''!

!classDefinition: #WebTableCell category: #'Aida-Elements'!
WebElement subclass: #WebTableCell
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebTableCell class' category: #'Aida-Elements'!
WebTableCell class
	instanceVariableNames: ''!

!classDefinition: #WebTableHeader category: #'Aida-Elements'!
ProtoObject subclass: #WebTableHeader
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebTableHeader class' category: #'Aida-Elements'!
WebTableHeader class
	instanceVariableNames: ''!

!classDefinition: #WebTableRow category: #'Aida-Elements'!
WebElement subclass: #WebTableRow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebTableRow class' category: #'Aida-Elements'!
WebTableRow class
	instanceVariableNames: ''!

!classDefinition: #WebTabs category: #'Aida-Widgets'!
ProtoObject subclass: #WebTabs
	instanceVariableNames: 'selected'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebTabs class' category: #'Aida-Widgets'!
WebTabs class
	instanceVariableNames: ''!

!classDefinition: #ViewTabs category: #'Aida-Widgets'!
WebTabs subclass: #ViewTabs
	instanceVariableNames: 'views'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'ViewTabs class' category: #'Aida-Widgets'!
ViewTabs class
	instanceVariableNames: ''!

!classDefinition: #WebText category: #'Aida-Elements'!
WebElement subclass: #WebText
	instanceVariableNames: 'text size textAttributes header paragraph font'
	classVariableNames: 'AttributeMarkup'
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebText class' category: #'Aida-Elements'!
WebText class
	instanceVariableNames: ''!

!classDefinition: #WebTextArea category: #'Aida-Elements'!
ProtoObject subclass: #WebTextArea
	instanceVariableNames: 'rows columns'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebTextArea class' category: #'Aida-Elements'!
WebTextArea class
	instanceVariableNames: ''!

!classDefinition: #WebTransactionMonitor category: #'Aida-Internal'!
Object subclass: #WebTransactionMonitor
	instanceVariableNames: ''
	classVariableNames: 'BusySessions LastCommit LocalServers Muttex NotificationSent Transactions'
	poolDictionaries: ''
	category: 'Aida-Internal'!
!classDefinition: 'WebTransactionMonitor class' category: #'Aida-Internal'!
WebTransactionMonitor class
	instanceVariableNames: 'lock'!

!classDefinition: #WebTranslDict category: #'Aida-i18n'!
Object subclass: #WebTranslDict
	instanceVariableNames: 'translator class method language dict changes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-i18n'!
!classDefinition: 'WebTranslDict class' category: #'Aida-i18n'!
WebTranslDict class
	instanceVariableNames: ''!

!classDefinition: #WebTranslator category: #'Aida-i18n'!
Object subclass: #WebTranslator
	instanceVariableNames: 'parent cache other'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-i18n'!
!classDefinition: 'WebTranslator class' category: #'Aida-i18n'!
WebTranslator class
	instanceVariableNames: ''!

!classDefinition: #WebUser category: #'Aida-Core'!
Object subclass: #WebUser
	instanceVariableNames: 'parent id username password name surname company address city zip country website email phone fax other'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'WebUser class' category: #'Aida-Core'!
WebUser class
	instanceVariableNames: ''!

!classDefinition: #WebUserGroup category: #'Aida-Core'!
Object subclass: #WebUserGroup
	instanceVariableNames: 'name users other'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Core'!
!classDefinition: 'WebUserGroup class' category: #'Aida-Core'!
WebUserGroup class
	instanceVariableNames: ''!

!classDefinition: #WebUserRole category: #'Aida-Roles'!
Role subclass: #WebUserRole
	instanceVariableNames: 'username password'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Roles'!
!classDefinition: 'WebUserRole class' category: #'Aida-Roles'!
WebUserRole class
	instanceVariableNames: ''!

!classDefinition: #WebVideo category: #'Aida-Elements'!
WebElement subclass: #WebVideo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Elements'!
!classDefinition: 'WebVideo class' category: #'Aida-Elements'!
WebVideo class
	instanceVariableNames: ''!

!classDefinition: #WebWidget category: #'Aida-Applications'!
ProtoObject subclass: #WebWidget
	instanceVariableNames: 'state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Applications'!
!classDefinition: 'WebWidget class' category: #'Aida-Applications'!
WebWidget class
	instanceVariableNames: ''!

!classDefinition: #WebDemoWidget category: #'Aida-Demos'!
WebWidget subclass: #WebDemoWidget
	instanceVariableNames: 'username password result'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Demos'!
!classDefinition: 'WebDemoWidget class' category: #'Aida-Demos'!
WebDemoWidget class
	instanceVariableNames: ''!

!classDefinition: #WebDemoWidget2 category: #'Aida-Demos'!
WebWidget subclass: #WebDemoWidget2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Demos'!
!classDefinition: 'WebDemoWidget2 class' category: #'Aida-Demos'!
WebDemoWidget2 class
	instanceVariableNames: ''!

!classDefinition: #WebDialog category: #'Aida-Widgets'!
WebWidget subclass: #WebDialog
	instanceVariableNames: 'type text'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebDialog class' category: #'Aida-Widgets'!
WebDialog class
	instanceVariableNames: ''!

!classDefinition: #WebGrid category: #'Aida-Widgets'!
WebWidget subclass: #WebGrid
	instanceVariableNames: 'collection aspect object filtered columns page settings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebGrid class' category: #'Aida-Widgets'!
WebGrid class
	instanceVariableNames: ''!

!classDefinition: #WebNonHTMLResource category: #'Aida-Widgets'!
WebWidget subclass: #WebNonHTMLResource
	instanceVariableNames: 'content contentType filename'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebNonHTMLResource class' category: #'Aida-Widgets'!
WebNonHTMLResource class
	instanceVariableNames: ''!

!classDefinition: #WebRichEditorWakeup category: #'Aida-Widgets'!
WebWidget subclass: #WebRichEditorWakeup
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebRichEditorWakeup class' category: #'Aida-Widgets'!
WebRichEditorWakeup class
	instanceVariableNames: ''!

!classDefinition: #WebValidationError category: #'Aida-Widgets'!
WebWidget subclass: #WebValidationError
	instanceVariableNames: 'origin'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Widgets'!
!classDefinition: 'WebValidationError class' category: #'Aida-Widgets'!
WebValidationError class
	instanceVariableNames: ''!

!classDefinition: #WebWindow category: #'Aida-Applications'!
WebWidget subclass: #WebWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Applications'!
!classDefinition: 'WebWindow class' category: #'Aida-Applications'!
WebWindow class
	instanceVariableNames: ''!

!classDefinition: #WebPage category: #'Aida-Applications'!
WebWindow subclass: #WebPage
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Aida-Applications'!
!classDefinition: 'WebPage class' category: #'Aida-Applications'!
WebPage class
	instanceVariableNames: ''!


!AIDASite commentStamp: '<historical>' prior: 0!
AIDASite as the most important class is an Aida/Web website with its system and user services, session and security managent, url resolving and many more. AIDASite>>answerTo: is the main entry point of requests comming to that website.!

!Address commentStamp: '<historical>' prior: 0!
"ECML v1.1 definition of address (www.ecml.org)"

Instance Variables:
	city	<Object>	description of city
	company	<Object>	description of company
	country	<Object>	description of country
	emails	<Object>	description of emails
	firstName	<Object>	description of firstName
	lastName	<Object>	description of lastName
	middleName	<Object>	description of middleName
	phones	<Object>	description of phones
	postalCode	<Object>	description of postalCode
	stateProvince	<Object>	description of stateProvince
	street	<Object>	description of street
	title	<Object>	description of title

!

!AdvancedSearch commentStamp: '<historical>' prior: 0!
AdvancedSearch is used for set up a search criteria and also for generic search against collection of any objects.
Search criteria:
	- by default search string must be start part of an element in collection to come in results
	- use * before search string to search in the middle of strings 
      - "search string" for exact match (except case)

any method call open a new criteria in a dictionary

Instance Variables:
	criteria	<Dictionary>	 key is aspect, value is search key

!

!AidaModelAdaptor commentStamp: '<historical>' prior: 0!
AIDAModelAdaptor adapts the web form elements to the domain model. Main goal of adaptor is to adapt model object accessors to just #value/#value: methods, used by form elements

Example: aPerson name/name: is adapted to value/value: by a subclass AspectAdaptor, #name as an aspect of aPerson!

!AidaModelNullAdaptor commentStamp: '<historical>' prior: 0!
AIDAModelNullAdaptor adapts actually nothing just holds the value. This is a default adaptor in form element if no one is set. Usefull for preparing forms in advance, without connecting to domain model.

Example adding a hidden field:

	e add: (WebInputField new setHidden; name: 'MyHiddenField'; value: '12345')!

!AidaMutex commentStamp: 'janko 3/19/2012 13:08' prior: 0!
AidaMutex provides proper support for critical sections.

Only one process at a time can execute code within its #critical: method. Other processes attempting to call #critical: will block until the first process leaves the critical section. The process that owns the mutex (the one currently in the critical section), however, may call #critical: repeatedly without fear of blocking.

The process currently inside the critical section can be terminated by calling #terminateOwner. This will result in the process being unwound and the critical section being freed.!

!BmpImageStream commentStamp: '<historical>' prior: 0!
BmpImageStream 

Copyright (C) 1995-1998 AOKI Atsushi, All Rights Reserved.
!

!BosImageStream commentStamp: '<historical>' prior: 0!
BosImageStream 

Copyright (C) 1995-1998 AOKI Atsushi, All Rights Reserved.

!

!Company commentStamp: '<historical>' prior: 0!
Company as a party with its roles and relashionships, employees, organizational units etc.
!

!DailyCollection commentStamp: '<historical>' prior: 0!
DailyCollection is a handy for domain model to store values in collections, one per a day. Used as kind of index for faster access to historical data, which is usally accessed newer mostly while older less and less.

Typical usage:
	aDailyCollection 
		add: aSomething onDate: Date today;
		allDated: Date today;
		allThisYear;
		allLastMonth;
		...!

!DailyValues commentStamp: '<historical>' prior: 0!
DailyValues is a handy for domain model to store values, one per a day. Used as kind of index for faster access to historical data, which is usally accessed newer mostly while older less and less. 

Typical usage:
	aDailyValue 
		at: Date today put: 1234;
		at: Date today add: 10;  "adds to previous value"
		allFromDate: Date doday -5 to: Date today;
		allThisWeek;
		allLastMonth;
		...
!

!DefaultAuthenticator commentStamp: '<historical>' prior: 0!
DefaultAuthenticator authentificates the user during login by username and password, which are stored locally in site's security manager, by contrast to for instance the LDAPAuthenticator, which asks the LDAP directory server to authenticate this user.
!

!DelimitedFile commentStamp: 'janko 7/8/2011 23:21' prior: 0!
DelimitedFile for reading and writing files in CSV format.

Example:
	records := (DelimitedFile new delimiter: $, ; codepage: #cp1250; readFrom: 'somedata.csv') records.
	records do: [:record | "do something on this array of fields"]

Default delimiter is $; and default codepage #UTF8. You can change it to, say,  #cp1250 (Central European) or others, see AIDASite class codepage converting for all possibilities


!

!DocLink commentStamp: '<historical>' prior: 0!
DocLink is used in WebClipboard to cut/copy/paste references to resources on the web. (example: documents to paste as references on other documents, in Scribo)
!

!EMailMessenger commentStamp: '<historical>' prior: 0!
For sending and receiving e-mails

Port from VW, not yet finished!!!

!GifImageStream commentStamp: '<historical>' prior: 0!
GifImageStream 

Copyright (C) 1995-1998 AOKI Atsushi, All Rights Reserved.
!

!HistoryOfValue commentStamp: '<historical>' prior: 0!
HistoryOfValue track some value through the time. You can go back on any date and get a value valid on that time. 

Example usage: a price, which changes from time to time.!

!ImageStream commentStamp: '<historical>' prior: 0!
ImageStream 

Copyright (C) 1995-1998 AOKI Atsushi, All Rights Reserved.
!

!MIMEMap commentStamp: '<historical>' prior: 0!
MIMEMap maps content types to file extensions and back. Example: 'image.jpg' is of content type 'image/jpeg'
!

!MemberRole commentStamp: '<historical>' prior: 0!
MemberRole for a person becoming a member of some organizational unit.
!

!Numberer commentStamp: '<historical>' prior: 0!
Numberer is used to provide counters for things like invoice numbers

Instance Variables:
	counters	<Dictionary>	 counters for different purposes

!

!OrganizationUnit commentStamp: '<historical>' prior: 0!
OrganizationUnit for hierarchical modeling some organization like a company!

!Party commentStamp: '<historical>' prior: 0!
Party is abstract class for persons or companies, holding basic information, roels and relations to other parties (like this person is an employee to that company). It also registers all events related to that party.
!

!PartyCollection commentStamp: '<historical>' prior: 0!
PartyCollection is used for doing many things on mix of org.units, roles, rolegroups and persons. For instance, geting out all persons from above mix ...

Instance Variables:
	parent	<aParty>	a root party, containing that mix of parties (eg. a company)
	parties	<anOrderedCollection>	mix of parties (orgUniits, roles, roleGroups, persons)

!

!Person commentStamp: '<historical>' prior: 0!
Person as a party, with his roles and relations to other parties. 

Note that aPerson has its corresponding aWebUser and vice versa. From historical reasons, hopefully soon those two clases will be merged into Person!!!

!Role commentStamp: '<historical>' prior: 0!
Role is abstract class to show the role one party has in relationship with another, like this person is an employee to that company.

!

!RoleGroup commentStamp: '<historical>' prior: 0!
To group more roles or other groups together. to build a hierarchy of roles. If you use somewhere RoleGroup instead of Role, then you access all Roles together.

Instance Variables:
	name	<String> name of role group
	subroles	<Role | RoleGroup>	group of roles or other role groups

!

!SwazooAida commentStamp: '<historical>' prior: 0!
SwazooAida is here just for easier start and stop your Aida/Web application server

	- SwazooAida demoStart             "will create and start a demo site http://localhost:8888"
	- SwazooAida startOn: portNum   "will start a site on that port on all IP interfaces, any host"
								      "it will be created if doesn't exist yet"
	- SwazooAida start    "will start all existing sites"
	- SwazooAida stop     "will stop all running sites"!

!SwazooIntegrationTest commentStamp: '<historical>' prior: 0!
All tests are commented out because they are DANGEROUS to live Swazoo systems!!

Instance Variables:
	server	<SwazooServer>	description of server
	site	<Object | Proxy>	description of site

!

!URLResolver commentStamp: '<historical>' prior: 0!
URLResolver is a two way Url to object mapper, first way is for finding a reference to domain object the Url in web request is pointing on, reverse way is to get an Url for a domain object, when you add link to it on a web page.

URLResolver holds also counters of web requests per domain objects.
!

!VersionSpec commentStamp: '<historical>' prior: 0!
VersionSpec defines a versioned object by its number and position in version chain.

Instance Variables:
	number	<String>	 number of that version. Integer by default, but it can be any string
	current	<Boolean> true, if this version is current, that is, most important, released, etc.
	parent	<Object> parent, that is, previous version of that object, nil if noone
	next		<Object> next version of that object, nil if noone

!

!VersionedObject commentStamp: '<historical>' prior: 0!
VersionedObject for objects of many versions through the time, with a current version and a new one maybe in preparation. Prime example is Document in Scribo CMS. More on http://www.aidaweb.si/advanced-features.html
!

!ViewTabs commentStamp: '<historical>' prior: 0!
For quick selection of App views. Just fill with view names and descriptions, all other will be automatic. Tab for curently shown will be colored as shown, other tabls will have links to self observee and appropriate view!

!WebApplication commentStamp: '<historical>' prior: 0!
WebApplication is a superclass of all App subclasses for presentations (VC in MVC pattern) of domain objects on the web. By convention the App class is named DomainClass+App, for example PersonApp for Person domain class!

!WebAudio commentStamp: 'janko 8/25/2012 15:00' prior: 0!
WebAudio  for HTML5 audio tag!

!WebAutocomplete2Field commentStamp: 'janko 8/25/2012 14:59' prior: 0!
WebAutocompleteField for choosing value from a dropdown choices, which are filtered while writing characters in the field. See WebDemoApp>>ajaxAutocompleteExample.

!

!WebAutocompleteField commentStamp: '<historical>' prior: 0!
WebAutocompleteField for choosing value from a dropdown choices, which are filtered while writing characters in the field. See WebDemoApp>>ajaxAutocompleteExample.

!

!WebCache commentStamp: '<historical>' prior: 0!
WebCache is Memcached-like cache to speedup serving pages which don't change too frequently. See http://www.aidaweb.si/caching.html for usage and examples.

!

!WebCacheEntry commentStamp: '<historical>' prior: 0!
WebCacheEntry instances hold cached content in WebCache.

!

!WebCaptcha commentStamp: 'janko 3/22/2008 15:26' prior: 0!
A WebCaptcha provides a CAPTCHA image from input text, to be used for separating humans from bots, for instance when submiting blog comments (http://en.wikipedia.org/wiki/Captcha)

Our capthca is using ImageMagick (http://www.imagemagick.org) which must be installed first. It combines a background image (by default captcha-background.png, must be on current directory) with generated one from provided text in default font (see method fontName, currently Andy), which also must be installed and known to ImageMagick. 

To collect all installed fonts in your system for IMagics, run script
	imagick_type_gen > ~/.magics/type.xml

See http://www.imagemagick.org/Usage/scripts/imagick_type_gen

To see and change parameters of building captcha, look into method #prepareCaptchaImage!

!WebChat commentStamp: 'janko 7/8/2011 22:07' prior: 0!
WebChat is domain object for Chat real-time web example!

!WebClipboard commentStamp: '<historical>' prior: 0!
Used for cut/copy/paste page references (not page contents!!) for easier hyperlinking of pages. Every page should have copy action. Then you can paste url to related links section in some other page.

Instance Variables:
	title	<String> title of a page
	url	<String>	url link to a page

!

!WebCommand commentStamp: '<historical>' prior: 0!
WebCommand to send commands to and from the browser via JSON
!

!WebContext commentStamp: 'janko 8/25/2012 14:57' prior: 0!
WebContext holds an execution context for a web request. Contexts can be linked in a stack like structure for tree-like control flow (like a confirmation dialog as popup of some delete action)

Instance Variables
	id		<Integer>	unique id of the context inside one App instance
	parent	<WebContext or WebApplication>	parent in context chain
	child	<WebContext> chils in context chain, if any
	form		<WebForm>	a web form with input fields of this context
	ids		<Dictionary>	 the elements which have id defined, for fast access to them from AJAX requests"
	nextId   <Integer>     number for a next element's id
!

!WebCounter commentStamp: '<historical>' prior: 0!
WebCounter for counting web requests daily and per hour. Mostly used in URLResolver for counting visits of pages.!

!WebCountry commentStamp: 'janko 8/25/2012 17:14' prior: 0!
WebCountry on class side holds a table of country names and their ISO codes
!

!WebDateInputField commentStamp: '<historical>' prior: 0!
WebDateInputField is used for entry of dates with help od JavaScript calendar (http://www.dynarch.com/projects/calendar/), from Romanian author Mihai Bazon. 
See also WebStyle calendar* methods, specially calendarCSS and calendarLang*

Usage is similar as usual input field. Example: 
	element addDateInputFieldAspect: #methodName for: self observee
 
Instance Variables:
	button	<WebImage>	
!

!WebDelayedField commentStamp: '<historical>' prior: 0!
WebDelayedField is used to delayed Ajax posting to server. It waits for delay after last key input, before it posts its contents. Ideal for live-search fields.

Use it as a normal input field, sending it #onClickPost, #onClickPostAndUdate: etc.
!

!WebDemo commentStamp: '<historical>' prior: 0!
WebDemo is a domain model part of few demos, see WebDemoApp for more

!

!WebDemoApp commentStamp: '<historical>' prior: 0!
WebDemoApp collects few demonstrations of Aida/Web in action, like examples of Ajax use etc.!

!WebDemoWidget commentStamp: 'janko 11/21/2011 17:42' prior: 0!
WebDemoWidget2 to show a hierarchy of widgets. This widget is namelly composed of two WebDemoWidget!

!WebDemoWidget2 commentStamp: 'janko 10/28/2011 13:34' prior: 0!
WebDemoWidget2 to show a hierarchy of widgets. This widget is namelly composed of two WebDemoWidget!

!WebDialog commentStamp: 'janko 7/8/2011 23:26' prior: 0!
WebDialog for different dialgos with a user, like delete confirmation ans similar. See class creation methods to create specific dialogs:

- WebDialog class>>newConfirmation 
      for simple yes/no answers to a stated question. Used mainly for confirmations of actions like delete in action methods.

For styling see and override CSS rules from DefaultWebStyle css28Dialog!

!WebEvent commentStamp: 'janko 8/25/2012 17:11' prior: 0!
WebEvent holds details of event triggered on some element of web page. It is transfered as a JSON message from the browser.

!

!WebEventHandler commentStamp: 'janko 8/25/2012 17:12' prior: 0!
WebEventHandler registers and then responds to events (like onClick) on elements of web page

!

!WebFieldSet commentStamp: '<historical>' prior: 0!
FieldSet element groups one or more input fields together. It usually (depends on style) also enclose them with border. Legend is for writing a name of the filedset on the corner!

!WebGraph commentStamp: '<historical>' prior: 0!
WebGraph for drawing graphs, on VisualWorks only, here just as an example for future porting.

For Smalltak wide use rather AidaCharts (JavaScript charting package) instead.!

!WebGrid commentStamp: '<historical>' prior: 0!
WebGrid is a powerfull widget to show tabular data, with filters, sorting, paginations and many more. See WebDemoApp>>viewGrid for examples

!

!WebGridColumn commentStamp: '<historical>' prior: 0!
WebGrid is a powerfull widget to show tabular data, with filters, sorting, paginations and many more.

!

!WebIFrame commentStamp: '<historical>' prior: 0!
WebIFrame is frame, inserted within a block of text. See IFRAME tag in HTML 4.01 spec
!

!WebInPlaceEditable2Text commentStamp: 'janko 8/25/2012 14:27' prior: 0!
WebInPlaceEditableText for editing text directly on the page, simply with a click on the text. 

Based on jQuery UI Editable (currently in development, downloaded jul12) http://wiki.jqueryui.com/w/page/12137959/Editable


See WebDemoApp>>jQueryInPlaceEditorExample for an example.
!

!WebInPlaceEditableText commentStamp: '<historical>' prior: 0!
WebInPlaceEditableText for editing text directly on the page, simply with a click on the text. See WebDemoApp>>ajaxInPlaceEditorExample for an example.!

!WebIndex commentStamp: '<historical>' prior: 0!
WebIndex is a search engine, which index words in a domain object, weightinh their importance (words in header more important etc.), then search for domain objects containing searched keywords (see also WebIndexApp).!

!WebJSON commentStamp: '<historical>' prior: 0!
WebJSON to serialize and parse in JSON format. 

	WebJSON parse: aString
	WebJSON stringify: anObject

anObject can be Collection or Dictionary, or String, Number, True, False, Undefined. Or combination of them.

Based on JSON package from SqueakSource done by Tony Garnock-Jones.!

!WebJSONPresenter commentStamp: 'janko 3/19/2012 21:02' prior: 0!
WebJSONPresenter presents a domain object in JSON format.

Domain object must implement a method #asJson. Object's URL must end with '.json' and it will automatically be directed to that presenter.

Later will be extended like WebApplication. Say for Person a PersonJson, or something like that. !

!WebLabel commentStamp: 'janko 8/25/2012 14:21' prior: 0!
WebLabel or  <label> tag defines a label for an <input> element.

The <label> element does not render as anything special for the user. However, it provides a usability improvement for mouse users, because if the user clicks on the text within the <label> element, it toggles the control.

The for attribute of the <label> tag should be equal to the id attribute of the related element to bind them together.
!

!WebLanguage commentStamp: 'janko 8/25/2012 17:14' prior: 0!
WebLanguage on class side holds a table of language names and their ISO codes

!

!WebLiveImage commentStamp: '<historical>' prior: 0!
WebLiveImage is used for live, dynamic GIF image construction.

Instance Variables:
	gif			<ByteArray>	content of image in GIF format
	refreshed	<Timestamp>	timestamp of last gif creation, used for caching algoritms

!

!WebLivePDFCreator commentStamp: '<historical>' prior: 0!
WebLivePDFCreator created PDF from HTML source together with Table of contents!! It uses external HTMLDOC converter (http://www.htmldoc.org/)
!

!WebMenu commentStamp: '<historical>' prior: 0!
WebMenu is a dropdown menu, which can select single or multiple options. Options are read from a collection, selected options are put in selected. You can set aspect of each option if options are not plain text. 

Example:

	WebMenu aspect: #name collection: self persons selected: self selectedPersons

will show dropdown menu of all persons, shown by name. Selected person will be stored in selectedPersons collection. Above menu is  single selection, it can be multiple selection too if you do:

	aWebMenu setMultiple.!

!WebMethodImage commentStamp: '<historical>' prior: 0!
This image is actually in-lined in a method, which is called on defined object and must return a ByteArray of image contents. 

Instance Variables:
	contentType	<String>	 content type of an image eg. 'image/gif', which is default.
	method	<Symbol>	symbol of a method to be called on object
	object	<Object>	object on which a method will be called

!

!WebMethodResource commentStamp: '<historical>' prior: 0!
WebMethodResource serves resources like images which are stored in plain methods (mosty from WebStyle subclasses).
!

!WebMobileApplication commentStamp: 'janko 8/25/2012 12:26' prior: 0!
WebMobileApplication to have a web app for the same domain object but tailored for mobile phones and tablets. 

Use a classical WebApplication and responsive design with a mobile CSS if your app is just a bit different (like bigger buttons etc.) on a mobile device. 

Use WebMobileApplication if mobile app is very different and tightly designed just for a mobile device, like a mobile phone.

!

!WebNonHTMLResource commentStamp: '<historical>' prior: 0!
NonHTMLResource for returning information in other formats like PDF, plain text etc.

Usage: in your view method for returning PDF as an example:

  MyApp>>viewAsPDF

	^WebNonHTMLResource forPDF: self pdf

Response will be with content type 'application/pdf', while url extension will still be .html. If you want appropriate url extension too, you need to temporary register that element in urlResolver and redirect to it.
!

!WebPage commentStamp: '<historical>' prior: 0!
WebWidget is an abstract class for statefull Aida components - standalone parts of web page, many times also long living, that is, they live longer than just one page view. 
!

!WebRawText commentStamp: '<historical>' prior: 0!
WebRawText for plain ascii text, without any encodings!!!

!WebRealtimeConnection commentStamp: 'janko 7/8/2011 23:14' prior: 0!
WebRealtimeConnection holds information about browser connection to send commands in realtime. It can be WebSocket or long-polling Comet (Ajax call which delays response until something is to send back)

Instance Variables
	type	<Symbol>	#comet or #websocket
	handler <WebRealtimeHandler>
	connection <HTTPCoonnection or WebSocketConnection>
	app	<WebAplication>	 in which App this realtime connection is open
	view	<Symbol>	on which App view
	semaphore	<Semaphore>	for long-polling Comet to wait on!

!WebRealtimeHandler commentStamp: 'janko 8/25/2012 17:12' prior: 0!
WebRealtimeHandler handles all realtime (WebSocket and Comet) channels to browser on that session"

Instance Variables
	session	<WebSession>  on which session 
	connections	<OrderedCollection>	all currently open realtime connections

!

!WebRichEditor commentStamp: '<historical>' prior: 0!
WebRichEditor is a JavaScript HTML WYSIWYG editor. Use it instead of text areas and you can rich edit your text!!

Usage:
	anElement addRichEditorAspect: #body for: myDocument!

!WebRichEditorWakeup commentStamp: '<historical>' prior: 0!
WebRichEditorWakeup is a component which speedup editing by loading all JS and other libraries for rich text editor in background. 

Add it to the end of your pages but only if user has editing rights.!

!WebRouter commentStamp: '<historical>' prior: 0!
WebRouter routes a web request to the appropriate resource (handler), which can be a domain object which is able to represent itself on the web (via URLResolver), or a static file (via FileProxy) or anything else. Router's main method is #resourceFor: aRequest, which returns a resource able to handle that request or nil in case no resource was found.

It contains an ordered collection of routes, which are checked in the sequence until response not nil.
Each route is an association of url pattern and a reference to a handler. Default route is for instance:

	'/*' -> anURLResolver

Url pattern is simply a Smalltalk #match: method criteria, matched over there relative Url of web request.

!

!WebScheduledEvent commentStamp: '<historical>' prior: 0!
WebScheduledEvent instances as entries in the WebSheduler hold blocks to run periodically or once at a scheduled time.

!

!WebScheduler commentStamp: 'janko 3/19/2012 21:25' prior: 0!
WebScheduler is a service for running scheduled events. Events can be single or periodic (daily, hourly, ...).
When event is triggered, its block is executed in a separate low priority process. Scheduler time resolution is 1 second. 

Example of periodic event:
	self site scheduler everyHourAt: 30 "minutes" runBlock: [Trascript show: 'half a hour!!].

Instance Variables:
	site		<anAIDASite>	
	queue	<OrderedCollection>	queue of events, waiting for execution
	loop	<Process>		loop process, every second looks into queue to run an event
	mutex	<AidaMutex>   to protect queue operations

!

!WebSecurityManager commentStamp: '<historical>' prior: 0!
WebSecurityManager for user and group management, authentication and access control in web Apps. See WebSecurityManagerApp for setup security on the site.!

!WebSession commentStamp: '<historical>' prior: 0!
WebSession hold user's session with all appropriate data on this website. It also hold an application state (instances of App classes) which belong to that session. Session can be anonymous (of special user Guest) or logged-in. !

!WebSessionManager commentStamp: '<historical>' prior: 0!
WebSessionManager manages all sessions on this website. It creates a new session if needed or finds existing one from a web request. There are also methods for releasing nonactive (more that an hour without activity) or guest sessions, and to release session application state (instances of App classes)
!

!WebSiteOwnerRole commentStamp: '<historical>' prior: 0!
WebSiteOwnerRole for a person owning certain website!

!WebStaticServer commentStamp: '<historical>' prior: 0!
WebStaticServer serves static content from files. It holds a dictionary of urls and FileProxies, for each file one.!

!WebStatistics commentStamp: '<historical>' prior: 0!
WebStatistics to collect few statistical data (like referers). This is in addition to counters in URLResolver.  See also WebStatisticsApp for reporting the stats with numbers and graphs.

!

!WebStubElement commentStamp: 'jm 8/21/2009 19:45' prior: 0!
WebStubElement is an element which will be replaced with a real one after Ajax update

Example:
	u := WebStubElement newFor: #ajaxShowElement.
	(e addNilLinkText: 'update') onClickUpdate: u.
	e add: u.
	
This will show the element at the click to link by updating the empty stub element.!

!WebTabs commentStamp: '<historical>' prior: 0!
WebTabs are visual selection tool. selected tab is in front, others are back and have url links.
By default an instance have CSS class 'webtabs' and selected tab 'webtabselected"

Usage:
	self addTextBold: 'Selected without link. 
	self addLinkTo: someObject text: 'not-selected with link' view: #view.
	self selected: 1.


Instance Variables:
	selected	<Integer>	which tab is selected. By default is first.

!

!WebTransactionMonitor commentStamp: '<historical>' prior: 0!
WebTransactionMonitor is used for coordinating transactions on databases like Gemstone.
!

!WebTranslDict commentStamp: '<historical>' prior: 0!
WebTranslDict is a dictionary holding the last level in WebTranslator cache. Special dictionary is needed to catch the changes when doing translations by translation tools and storing them back to appropriate class translation methods.!

!WebTranslator commentStamp: 'jm 6/27/2009 20:07' prior: 0!
WebTranslator offers a translation support to web apps. Apps on class side hold translations of the text. WebTranslator is then called by executing app to find a proper translation for each text, if it is used as in this example:

	e addText: #fr->'Bonjour'!

!WebUser commentStamp: '<historical>' prior: 0!
WebUser is the user on our website. This class holds basic user data, address, login history, etc. It can also have user specific data in #otherValues instvar. There are few predefined users like Guest (anymone not logged in), Admin (have access to everything, kind of 'root' user) and Extranet (not used much yet).!

!WebUserGroup commentStamp: '<historical>' prior: 0!
WebUserGroup is a part of user and group management. Groups are then used for security management like access control. There are predefined groups All Users, Administrators, Registered Users, Users waiting activation. To manage groups and their membership see WebSecurityManagerApp!

!WebUserRole commentStamp: '<historical>' prior: 0!
WebUserRole for a person being an user registered on certain website
!

!WebValidationError commentStamp: '<historical>' prior: 0!
WebValidationError shows the error message in case of verification failure of input values in form elements

Instance Variables:
	origin	<WebFormElement>	should reply to #errorText 

!

!WebVideo commentStamp: 'janko 8/25/2012 12:10' prior: 0!
WebVideo for HTML5 video tag!

!WebWidget commentStamp: '<historical>' prior: 0!
WebWidget is an abstract class for statefull Aida components - standalone parts of web page, many times also long living, that is, they live longer than just one page view. 
!

!WebWindow commentStamp: '<historical>' prior: 0!
WebWindow is a window (a web page or window inside a page).
!

!AIDAModelAdaptorTest methodsFor: 'testing'!
testSanitizer
	| adaptor |
	adaptor := AidaModelAdaptor new.
	adaptor buffer: '< script id="id15">'.
	self assert: (adaptor sanitize; buffer) = '<  id="id15">'.
	adaptor buffer: '<img src=""/a.jpg<script type=text/javascript src="http://1.2.3.4/xss.js">" /></script>'.
	self assert: (adaptor sanitize; buffer) = '<img src=""/a.jpg< type=text/java src="http://1.2.3.4/xss.js">" /></>'.
	adaptor buffer: 'script for javascript<script>'.
	self assert: (adaptor sanitize; buffer) = 'script for javascript<>'.
	adaptor buffer: 'a < b. /* in script */ '.
	self assert: (adaptor sanitize; buffer) = 'a < b. /* in  */ '. " this is not ok!! "! !

!AIDASite methodsFor: 'private-serving'!
activityAnnouncers
	"whom to announce activity on that site. A dictionary with an app as key, another
	dict with element id as key and a block to execute"
	^self otherAt: #activityAnnouncers ifAbsent: [self initActivityAnnouncers]! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/4/07 22:07'!
addAllowHeaderTo: aHTTPResponse
	| methods |
	methods := 'OPTIONS,GET,HEAD,POST,DELETE,TRACE,'.
	methods := methods, 'PROPFIND,PROPPATCH,MKCOL,PUT,COPY,MOVE,LOCK,UNLOCK'.
	aHTTPResponse addHeaderName: 'Allow' value: methods! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/8/07 09:38'!
addDontCacheHeaderTo: aHTTPResponse forPage: aWebPage
	| object value |
	object := aWebPage isWebApplication ifTrue: [aWebPage observee] ifFalse: [aWebPage].
	value := object aidaDontCache.
	value ifFalse: [value := aWebPage aidaDontCache]. "WebApp subclass can set it too!! "
	value ifTrue: [aHTTPResponse cacheControl: 'no-store, no-cache, must-revalidate'].! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/8/07 09:38'!
addExpiresHeaderTo: aHTTPResponse forPage: aWebPage
	| object value |
	object := aWebPage isWebApplication ifTrue: [aWebPage observee] ifFalse: [aWebPage].
	value := object expiresTimestamp.
	value isNil ifTrue: [value := aWebPage expiresTimestamp]. "WebApp subclass can set it too!! "
	value notNil ifTrue: [aHTTPResponse expires: value asSpTimestamp].! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/8/07 09:38'!
addModifiedHeaderTo: aHTTPResponse forPage: aWebPage
	| object value |
	object := aWebPage isWebApplication ifTrue: [aWebPage observee] ifFalse: [aWebPage].
	value := object modifiedTimestamp.
	value isNil ifTrue: [value := aWebPage modifiedTimestamp]. "WebApp subclass can set it too!! "
	value notNil ifTrue: [aHTTPResponse lastModified: value asSpTimestamp].! !

!AIDASite methodsFor: 'private-serving'!
addResponseHeadersTo: aHTTPResponse forPage: aWebPage on: aWebSession
	"use observee in app to find timestamps, because observee points 
	to right version of an object!! "
	| object |
	object := aWebPage isWebApplication ifTrue: [aWebPage observee] ifFalse: [aWebPage].
	aHTTPResponse contentType: object aidaContentType.
	self addModifiedHeaderTo: aHTTPResponse forPage: aWebPage.
	self addExpiresHeaderTo: aHTTPResponse forPage: aWebPage.
	self addDontCacheHeaderTo: aHTTPResponse forPage: aWebPage.
"	self addUACompatibleHeaderTo: aHTTPResponse." "for stupid IE8 to avoid manual checking Compatibility view"
	aWebSession cookie ifFalse: 
		[aHTTPResponse cookie: (self cookieHeaderFor: aWebSession)].! !

!AIDASite methodsFor: 'system services' stamp: 'np 3/16/2009 12:30'!
addSystemService: aServiceObject named: aSymbol 
	"add a new system service (e.g URLResolver) to the dictionary of services"
	^self systemServices
		at: aSymbol asSymbol put: aServiceObject! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
addToRunningHistoryCrashed: aBoolean
	"Call it at server startup (in setStartedTimestamp). It reads old timestamps (started and
	last alive) and add it to the history" 
	| array |
	array := Array new: 3.
	array
		at: 1 put: self startedTimestamp asSeconds;
		at: 2 put: self lastTimeAliveTimestamp asSeconds;
		at: 3 put: aBoolean.  "true if server crashed"
	self runningHistoryCollection add: array.! !

!AIDASite methodsFor: 'private-serving'!
addUACompatibleHeaderTo: aHTTPResponse
	"For stupid Microsoft's IE8 to avoid users manually check Page->Compatibility view"
	aHTTPResponse addHeaderName: 'X-UA-Compatible' value: 'IE=EmulateIE7'! !

!AIDASite methodsFor: 'user services'!
addUserService: aServiceObject named: aSymbol 
	"add a new user service (e.g WebIndex) to the dictionary of services"
	self userServices
		at: aSymbol asSymbol put: aServiceObject! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/4/07 22:07'!
addressTextFor: anIPAddress

	^((anIPAddress hostAddress at: 1) printString, '.',
	(anIPAddress hostAddress at: 2) printString, '.',
	(anIPAddress hostAddress at: 3) printString, '.',
	(anIPAddress hostAddress at: 4) printString)! !

!AIDASite methodsFor: 'system services'!
admin
	^self systemServices 
		at: #Admin
		ifAbsent: 
			[self addSystemService: (WebAdmin new) named: #Admin.
			self register: self admin onUrl: '/admin'.
			^self admin].! !

!AIDASite methodsFor: 'settings' stamp: 'mivsek 6/13/2007 15:54'!
afterLogin
	"url of a page to jump after login or #lastPage to back to last page before logout"

	^self settings at: #afterLogin ifAbsentPut: [#lastPage]. "back to last page before logout"! !

!AIDASite methodsFor: 'settings'!
afterLogin: aStringOrSymbol
	"1. url of page to jump"
	"2. #lastPage - back to a page before logout"
	"3. #myPage - to user's personal page, if exists"
	((aStringOrSymbol isKindOf: String) not and: 
		[(#(#lastPage #myPage) includes: aStringOrSymbol) not])
			ifTrue: [self error: 'wrong login argument'].
	self settings  at: #afterLogin put: aStringOrSymbol! !

!AIDASite methodsFor: 'statistics-counters'!
allPages
	"all page requests from the server creation until now"
	^self pagesCounter total! !

!AIDASite methodsFor: 'statistics-counters'!
allPagesThisMonth
	"all page requests in current month"
	^self pagesCounter countsOnMonth: SpDate today monthIndex year: SpDate today year! !

!AIDASite methodsFor: 'statistics-counters'!
allPagesThisWeek
	"all page requests in current week"
	^self pagesCounter currentWeekCounts
		inject: 0 into: [:sum :each | sum + each]! !

!AIDASite methodsFor: 'statistics-counters'!
allPagesToday
	^self pagesCounter countsOnDate: SpDate today! !

!AIDASite methodsFor: 'statistics-counters'!
allPagesYesterday
	^self pagesCounter countsOnDate: (SpDate today subtractDays: 1)! !

!AIDASite methodsFor: 'private-serving'!
announceActivity
	"announce only if more than a second from last announcement"
	(self lastRequestTimestamp notNil and:
		[self lastRequestTimestamp asSeconds = SpTimestamp now asSeconds]) ifTrue: [^nil]. 
	self activityAnnouncers associations do: [:assoc |
		assoc key "app" isActive 
			ifTrue: [assoc value values do: [:block | block value] ]
			ifFalse: [self activityAnnouncers removeKey: assoc key] ] "auto cleanup of released application state"! !

!AIDASite methodsFor: 'serving' stamp: 'mivsek 8/22/2007 11:08'!
answer: anObject to: aRequest on: aWebSession
	aRequest isGet | aRequest isPost | aRequest isHead
		ifTrue: [^self answer: anObject toGetOrPost: aRequest on: aWebSession].
	aRequest isOptions ifTrue: [^self answer: anObject toOptions: aRequest on: aWebSession].
	aRequest isPropFind ifTrue: [^self answer: anObject toPropFind: aRequest on: aWebSession].
	aRequest isLock ifTrue: [^self answer: anObject toLock: aRequest on: aWebSession].
	aRequest isUnlock ifTrue: [^self answer: anObject toUnlock: aRequest on: aWebSession].
	aRequest isPut ifTrue: [^self answer: anObject toPut: aRequest on: aWebSession].
	^HTTPException notImplemented! !

!AIDASite methodsFor: 'serving' stamp: 'janko 4/25/2012 11:15'!
answer: anObject toGetOrPost: aRequest on: aWebSession
	| presenter stream response properContent |
	(self cache isCached: anObject to: aRequest on: aWebSession)
		ifTrue: [^self cache respond: anObject to: aRequest on: aWebSession].
	[presenter := anObject aidaPresenterFor: aRequest on: aWebSession]
		ifCurtailed: [self finalizeExecutingRequest: aRequest].
	presenter isNil ifTrue:   "not found"
		[aWebSession removeIfNewGuest. ^HTTPException notFound].
	aWebSession isHttpAuthenticationNeeded "because of logout" ifTrue:  [^self unauthorizedResponse].
	aWebSession shouldRedirect ifTrue: [^self redirectOn: aWebSession].
	self log: 'h'.
	presenter aidaIsRespondingStreamed
		ifTrue: 
			[ [presenter streamHtmlTo: nil "not needed" for: aRequest on: aWebSession]
				ensure: [self finalizeExecutingRequest: aRequest].
			self log: ' done'.
			^aRequest streamedResponse]
		ifFalse: 
			[response := HTTPResponse ok.
			aRequest task response: response.
			self addResponseHeadersTo: response forPage: presenter on: aWebSession.
			stream := WriteStream on: (String new: 10000).
			[presenter streamHtmlTo: stream for: aRequest on: aWebSession]
				ensure: [self finalizeExecutingRequest: aRequest].
			properContent := (AIDASite properArray: stream contents). "in case of TwoByteString"
			response entity: properContent. 
			(self cache shouldCache: anObject to: aRequest on: aWebSession)
				ifTrue: [self cache store: properContent for: anObject to: aRequest on: aWebSession].
			self log: ' done'.
			^response]! !

!AIDASite methodsFor: 'serving' stamp: ' 21/4/07 22:07'!
answer: anObject toLock: aRequest on: aWebSession
	"WebDAV lock request for that object"
	|  rsp |
	"Temporary!!!! just return a fake lock!!"
	rsp := Swazoo.HTTPLockResponse new.
	rsp start.
	rsp addTagName: 'locktype' value: #write.
	rsp addTagName: 'lockscope' value: #exclusive.
	rsp addTagName: 'depth' value: '0'.
	rsp addLockOwner: 'Administrator'.
	rsp addTagName: 'timeout' value: 'Second-604800'.  "one week, temporary!!"
	rsp addLockToken: 'opaquelocktoken:89001c0a-23f2-0310-b37d-c58bc335a1ff'.
	^rsp! !

!AIDASite methodsFor: 'serving' stamp: ' 21/4/07 22:07'!
answer: anObject toOptions: aRequest on: aWebSession
	| response |
	response := Swazoo.HTTPResponse ok.
	self isWebDAVEnabled ifTrue: 
	 	[response addHeaderName: 'DAV' value: '1,2'.
		"without following header Windows refuse to add new Web folder!! "
		response addHeaderName: 'MS-Author-Via' value: 'DAV'].
	self addAllowHeaderTo: response.
	^response! !

!AIDASite methodsFor: 'serving' stamp: ' 21/4/07 22:07'!
answer: anObject toPropFind: aRequest on: aWebSession
	"WebDAV properties request from object"
	|  multiResponse |
	"Temporary!!!! Now it just return empty collection, which is enough for MS web folders to add new!! "
	multiResponse := Swazoo.HTTPPropFindResponse new.
	multiResponse multiStart.
	multiResponse startResponseFor: aRequest uri value.
	multiResponse addPropertyName: 'getlastmodified' value: 'Mon, 21 Feb 2005 14:11:01 GMT'.
	aRequest uri value last = $/ ifTrue: "directory"
		[multiResponse addPropertyName: 'resourcetype' value: #collection].
	multiResponse endResponseWithStatusCode: 200.
	multiResponse multiEnd.
	^multiResponse! !

!AIDASite methodsFor: 'serving' stamp: ' 21/4/07 22:07'!
answer: anObject toPut: aRequest on: aWebSession
	"WebDAV: try to PUT content into that object"
	(anObject isKindOf: FileProxy) ifFalse: [^HTTPException forbidden].
	anObject put: aRequest putData.
	^HTTPResponse ok! !

!AIDASite methodsFor: 'serving' stamp: 'JM 4/21/2007 22:20'!
answer: anObject toUnlock: aRequest on: aWebSession
	"WebDAV unlock request for that object"
	^HTTPResponse noContent. "204"! !

!AIDASite methodsFor: 'serving' stamp: 'janko 8/25/2012 15:18'!
answerTo: aRequest 
	"Squeak specific!! "
	| session object errorResponse |
	[self logRequest: aRequest.
	aRequest isPing ifTrue: [^HTTPResponse ok].  "/ping.html for monitoring the site"
	session := self sessionManager findOrCreateSessionFor: aRequest.
	aRequest session: session.
	session isHttpAuthenticationNeeded ifTrue: [session authenticateFrom: aRequest].
	session isHttpAuthenticationNeeded "still" ifTrue: [^self unauthorizedResponse].
	self shouldRedirect ifTrue: [^self redirectToOtherHost: aRequest on: session].
	self log: 'p'.
	object := self router resourceFor: aRequest.  "routes to a resource able to handle this request"
	self countRequest: aRequest onObject: object.
	object isNil 
		ifTrue: [session removeIfNewGuest. ^HTTPResponse notFound].
	^self answer: object to: aRequest on: session] 
		on: Error, Exception
		do: [:exception |                      
			self halt.
			exception class == HTTPException ifTrue: [^exception response].
			exception class == SpSocketError 
				ifTrue: [self reportSocketError: exception request: aRequest] "temporary"
				ifFalse:
					["self reportException: exception. " "temporary off, no gain to report to Transcript!!"
					exception defaultAction]. 
			errorResponse := self httpResponseOnException: exception.
			HTTPException raiseResponse: errorResponse.
			^errorResponse].! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
authenticationScheme
	"#Basic or #Digest, see rfc2617. Digest is recomended because password
	goes encrypted to server"
	self securityManager hasHttpBasicAuthenticationScheme ifTrue: [^#Basic].
	self securityManager hasHttpDigestAuthenticationScheme ifTrue: [^#Digest].
	^#None! !

!AIDASite methodsFor: 'system services'!
authenticator
	"a plugable authentication of users during login"
	^self systemServices 
		at: #Authenticator
		ifAbsent: [self setDefaultAuthenticator].! !

!AIDASite methodsFor: 'settings' stamp: 'mivsek 1/10/2008 18:48'!
autoLogout
	"logout after 15min of inactivity. default is NO!! "
	^self settings at: #AutoLogout ifAbsent: [false]! !

!AIDASite methodsFor: 'settings'!
autoLogout: aBoolean
	"logout after 15min of inactivity"
	(aBoolean isKindOf: Boolean) ifFalse: [self error: 'wrong argument'].
	^self settings at: #AutoLogout put: aBoolean! !

!AIDASite methodsFor: 'statistics' stamp: 'JM 4/26/2007 19:58'!
availability
	"return server availability from first run in %"
	"AIDASite default availability"
	| uptime downtime |
	uptime := self totalUptime.
	downtime := self totalDowntime.
	^((uptime / ((uptime + downtime) max: 1)) * 100) asScaledDecimal: 2! !

!AIDASite methodsFor: 'private-backup/restore' stamp: 'np 1/15/2008 20:48'!
backupToFile
	"file out all object tree to file aidasite-<sitename>.obj"
	"(AIDASite named: 'biart') backupToFile"
	"(AIDASite named: 'biart') deepSearchOfClass: 'ObsoleteIntranet'"
	"(AIDASite named: 'biart') deepSearchOfObsoleteClasses"
	| filename fileDir |
	filename := 'aidasite-', self name, '.obj'.
	fileDir := FileDirectory forFileName: filename.
	(fileDir fileExists: filename) ifTrue: 
		[fileDir copyFileWithoutOverwriteConfirmationNamed: filename toFileNamed: ('aidasite-', self name, '-old.obj')].
	(FileStream fileNamed: filename)
		fileOutClass: nil andObject: self! !

!AIDASite methodsFor: 'system services' stamp: 'np 3/16/2009 12:32'!
cache
	"a global cache of presentations of domain objects, if they are cached"
	^self systemServices 
		at: #Cache
		ifAbsent: [self addSystemService: (WebCache newOn: self) named: #Cache].! !

!AIDASite methodsFor: 'settings'!
cometEnabled
	"Is long-polling Comet enabled? By default no"
	^self settings at: #CometEnabled ifAbsent: [false]! !

!AIDASite methodsFor: 'settings'!
cometEnabled: aBoolean
	"Is long-polling Comet enabled? By default no"
	^self settings at: #CometEnabled put: aBoolean! !

!AIDASite methodsFor: 'settings'!
contextProcesses
	"if true, web contexts execute POSTs and Ajax requests in a separate process, to enable tree-like control flow"
	^self settings at: #contextProcesses ifAbsentPut: [false].! !

!AIDASite methodsFor: 'settings'!
contextProcesses: aBoolean
	"if true, web contexts execute POSTs and Ajax requests in a separate process, to enable tree-like control flow"
	(aBoolean isKindOf: Boolean) ifFalse: [self error: 'wrong argument'].
	self settings  at: #contextProcesses put: aBoolean.! !

!AIDASite methodsFor: 'private-serving'!
cookieHeaderFor: aSession 
	"set a permanent cookie on client (up to year 2020, enough?) "
	"for secure sessions different id as for usual !! "
	| id |
	id := (aSession lastRequest notNil and: [aSession lastRequest isEncrypted])
		ifTrue: [aSession secureId] ifFalse: [aSession id].
	^(WriteStream on: String new)
		nextPutAll: self cookieName;
		nextPutAll: '=';
		nextPutAll: id printString;
		nextPutAll: '; path=/; expires=Friday, 01-Jan-2020 01:00:00 GMT; HttpOnly'; 
			"HttpOnly to prevent session hijacking by malicious JS scripts like in XSS attacs"
		contents! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/4/07 22:07'!
cookieName
	"this is the name for our cookie. It shold be unique, so it is a bit strange"
	^'aida9357'! !

!AIDASite methodsFor: 'private-counters' stamp: 'janko 8/19/2011 22:18'!
countRequest: aRequest  onObject: anObject
	self announceActivity. "must be before setting last request timestamp!!"
	self setLastRequestTimestamp.
	aRequest session shouldCountRequests ifFalse: [^nil].    "to skip admin requests etc."
	anObject class == WebSession ifTrue: [^nil]. "don't count ajax and websocket requests"
	anObject notNil 
		ifTrue: 
			[self urlResolver incCounterFor: anObject.
			self incRequestCounterFor: anObject]
		ifFalse: 
			[self incNotFoundCounter.
			self log: ' not found: ', aRequest uriString, ' '.
			^nil ].
	self statistics collectStatsFrom: aRequest.
	^anObject! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
counters

	counters isNil ifTrue: [self initCounters].
	^counters

"WebServer default counters"! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
countingPolicy
	^self settings at: #countingPolicy ifAbsentPut: [#all].! !

!AIDASite methodsFor: 'settings'!
countingPolicy: aSymbol
	"from who to count requests with WebCounters: #all, #excludeAdmins, #onlyGuests, #none"
	(#(#all, #excludeAdmins, #onlyGuests, #none) includes: aSymbol) 
		ifFalse: [self error: 'unknown policy'].
	self settings  at: #countingPolicy put: aSymbol! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
cr
	^String with: Character cr! !

!AIDASite methodsFor: 'statistics'!
createdDate
	"date of  server creation"
	^self createdTimestamp notNil 
		ifTrue: [self createdTimestamp asDate] 
		ifFalse: [nil]! !

!AIDASite methodsFor: 'statistics'!
createdDateText
	"date of  server creation"
	^self createdDate notNil 
		ifTrue: [self createdDate shorterPrintSloString] 
		ifFalse: ['']! !

!AIDASite methodsFor: 'statistics' stamp: 'JM 4/26/2007 19:44'!
createdTimestamp
	"time and date of  server creation"
	^SpTimestamp fromSeconds:
		(self timestamps at: #Created ifAbsentPut: [SpTimestamp now asSeconds])! !

!AIDASite methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
critical: aBlock

	"For protecting critical sections in parallel execution of web requests. Use it always
	when you do things, which cannot be disturbed by another request. Exmaple:
		aServer critical: [<a block with critical section>]. "

	^WebTransactionMonitor critical: aBlock! !

!AIDASite methodsFor: 'settings-directories'!
defaultHelpDirectory
	^self defaultHomeDirectory, (SpEnvironment onWindows ifTrue: ['\'] ifFalse: ['/']), 'help'! !

!AIDASite methodsFor: 'settings-directories'!
defaultHomeDirectory
	"where the image started, but depending on Unix or Win style"
	^(SpEnvironment onWindows ifTrue: ['.\'] ifFalse: ['./'])! !

!AIDASite methodsFor: 'settings' stamp: 'mivsek 1/10/2008 18:50'!
defaultLanguage
	"ISO 639 2-letter language code symbol for default language of that site"
	^self settings at: #defaultLanguage ifAbsentPut: [#en].! !

!AIDASite methodsFor: 'settings' stamp: 'mivsek 1/10/2008 18:50'!
defaultLanguage: aLanguageCodeSymbol
	"ISO 639 2-letter language code symbol for default language of that site"
	^self settings at: #defaultLanguage put: aLanguageCodeSymbol! !

!AIDASite methodsFor: 'user services'!
demo
	^self userServices at: #WebDemo
		ifAbsent: 
			[self addUserService: WebDemo new named: #WebDemo.
			self register: self demo onUrl: '/demos'.
			^self demo]! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
diagnostics

	"if true, diagnostic messages are written on transcript for every web request"
	^self settings  at: #diagnostics ifAbsentPut: [true].! !

!AIDASite methodsFor: 'settings'!
diagnostics: aBoolean
	"if true, diagnostic messages are written on transcript for every web request"
	(aBoolean isKindOf: Boolean) ifFalse: [self error: 'wrong argument'].
	self settings  at: #diagnostics put: aBoolean.! !

!AIDASite methodsFor: 'start/stop'!
disable
	"this site is disabled and stopped, if not yet before. This site won't be started with SwazooServer start"
	self stop.
	self sessionManager
		removeGuestSessions;
		releaseApplicationState.
	^super disable! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
disableWebDAVSupport
	"Web Distributed Authoring and Versioning (WebDAV, www.webdav.org) is disabled on this site"
	"AIDASite default disableWebDAVSupport"
	self settings at: #WebDAVEnabled put: false! !

!AIDASite methodsFor: 'start/stop'!
enable
	"this site is enabled and can be started. Only enabled sites are started with SwazooServer start"
	^super enable! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
enableWebDAVSupport
	"Web Distributed Authoring and Versioning (WebDAV, www.webdav.org) is enabled on this site"
	"AIDASite default enableWebDAVSupport"
	self settings at: #WebDAVEnabled put: true! !

!AIDASite methodsFor: 'system services' stamp: 'janko 4/20/2012 17:13'!
federatedAuthenticator
	"a federated plugable authentication (OpenID) of users during login. It can be used in 
	parallel with #authenticator"
	^self systemServices 
		at: #FederatedAuthenticator
		ifAbsent: [self setDefaultFederatedAuthenticator]. "OpenID"! !

!AIDASite methodsFor: 'system services'!
federatedAuthorizator
	"a federated plugable authorization support (OAuth)r"
	^self systemServices 
		at: #FederatedAuthorizator
		ifAbsent: [self setDefaultFederatedAuthorizator]. "OAuth, including in URLResolver on /authorizator"! !

!AIDASite methodsFor: 'private-serving'!
finalizeExecutingRequest: aRequest
	"do all necessary cleanup in execution context"
	aRequest context isNil ifTrue: [^nil].
	aRequest context finalizeExecutionOf: aRequest! !

!AIDASite methodsFor: 'system services'!
help
	^self systemServices 
		at: #Help
		ifAbsent: 
			[self addSystemService: (WebHelp new) named: #Help.
			self register: self help onUrl: '/help'.
			^self help].! !

!AIDASite methodsFor: 'settings-directories'!
helpDirectory
	" a directory, where help html dokuments are stored. See WebApplication help pages category for 
 	details"
	^self settings  at: #helpDirectory ifAbsentPut: [self defaultHelpDirectory]! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
helpDirectory: aString
	" a directory, where help html dokuments are stored. See WebApplication help pages category for 
 	details"
	self settings  at: #helpDirectory put: aString.! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/4/07 22:07'!
helpResolve: aResolution 
	(self canAnswer and: [aResolution siteMatch: self]) ifFalse: [^nil].
	^self answerTo: aResolution request! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
helpURL

	^self settings  at: #helpURL ifAbsent: [^'']! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
helpURL: aString
	self settings at: #helpURL put: aString.! !

!AIDASite methodsFor: 'settings-directories'!
homeDirectory

	^self settings  at: #homeDirectory ifAbsentPut: [self defaultHomeDirectory]! !

!AIDASite methodsFor: 'settings-directories'!
homeDirectory: aString
	" a directory, which is the root for static content like static html dokuments"
	self settings  at: #homeDirectory put: aString.! !

!AIDASite methodsFor: 'statistics-counters' stamp: ' 21/4/07 22:07'!
hourlyStatsProcess

	"hourly report to transcript"
	"WebServer default hourlyStatsProcess"
	| hits pages new returning afterHits afterPages afterNew afterReturning |
	[
		hits := self totalCounter total.
		pages := self pagesCounter total.
		new :=	self newVisitorsCounter total.
		returning := self returningVisitorsCounter total.
		(Delay forSeconds: self secondsToHour) wait.
		[self isServing] whileTrue: 
			[afterHits := self totalCounter total.
			afterPages := self pagesCounter total.
			afterNew := self newVisitorsCounter total.
			afterReturning := self returningVisitorsCounter total.
			Transcript cr; show: '***'; cr; show:
				'***  ',  self name, ' ', 
				Time now hours printString, ':', Time now minutes printString, ' ',
				'    last hour hits: ', (afterHits - hits) printDotString, 
				'    pages: ', (afterPages - pages) printDotString, 
				'    visitors new: ', (afterNew - new) printDotString, 
				'    returning: ', (afterReturning - returning) printDotString;
				cr; show: '***'.
			self registerTopHourHits: (afterHits - hits) pages: (afterPages - pages).
			hits := afterHits. pages := afterPages.
			new := afterNew. returning := afterReturning.
			(Delay forSeconds: self secondsToHour) wait].
	] fork.! !

!AIDASite methodsFor: 'private-serving'!
httpResponseOnException: anException
	| response |
	response := HTTPResponse internalServerError.
	response entity: '
<HTML>
<HEAD><TITLE>', response statusText, '</TITLE></HEAD>
  <BODY>
   <H2>', response statusLine, '</H2>
   <P>The server experienced an error while processing this request. <BR>
   If this problem persists, please contact the webmaster.</P>
  <P>Error description:</P>
  <P>', anException messageText, '</P>
  <P>Stack:</P>
  <P>', 
	((DebuggerService shortStackFor: anException initialContext ofSize: 30
		"on: Error do: [:ex | ex messageText]")
			copyReplaceAll: (String with: Character cr) with: '<BR>')
, '</P>
  </BODY>
</HTML>'.
	^response! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
incNotFoundCounter

	"call this after each request is processed"


	self critical:
		[self notFoundCounter incCounter].! !

!AIDASite methodsFor: 'private-counters'!
incRequestCounterFor: anObject
	"call this after each request is processed"
	self critical:
		[self totalCounter incCounter.
		(anObject aidaContentType = 'text/html') 
			ifTrue: [self pagesCounter incCounter] ].! !

!AIDASite methodsFor: 'user services'!
index
	^self userServices 
		at: #WebIndex
		ifAbsent: 
			[self addUserService: WebIndex new named: #WebIndex.
			self register: self index onUrl: '/search'.
			^self index].! !

!AIDASite methodsFor: 'initialize-release'!
initActivityAnnouncers
	"whom to announce activity on that site. A dictionary with an app as key, another
	dict with element id as key and a block to execute"
	^self otherAt: #activityAnnouncers put: Dictionary new! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
initCounters
	"counters of web requests: total and by year/day of year"
	self critical: 
		[counters := IdentityDictionary new.
		self pagesCounter.
		self totalCounter.
		self newVisitorsCounter.
		self returningVisitorsCounter.
		self notFoundCounter].

"WebServer default initCounters"! !

!AIDASite methodsFor: 'initialize-release'!
initDefaultSettings

	self host: 'newsite' ip: '127.0.0.1'  port: 8888.  "this is usable for tests only"
"	self homeDirectory: self defaultHomeDirectory. " "rather lazy init, because of platform issues"
"	self helpDirectory: self defaultHelpDirectory. " "rather lazy init, because of platform issues"
	self helpURL: '/help'.
	self styleClass: 'DefaultWebStyle'.
	self diagnostics: false.
	self loggingPolicy: #none.
	self countingPolicy: #all.
	self smtpServer: self ip.
	self urgentNotificationEMail: 'info@eranova.si'.! !

!AIDASite methodsFor: 'initialize-release'!
initDemoOnRootUrl
	"(AIDASite named: 'aidademo') initDemoOnRootUrl."
	self register: self demo onUrl: '/'.! !

!AIDASite methodsFor: 'initialize-release'!
initFavicon
	"/favicon.ico, a small icon shown in browser near url address"
	"(AIDASite named: 'biart') initFavicon."
	| icon |
	icon := WebMethodImage
		initCache; 
		fromMethod: #favicon on: self style contentType: 'image/x-icon' site: self.
	self register: icon onUrl: '/favicon.ico'.! !

!AIDASite methodsFor: 'initialize-release'!
initHourlySnapshot
	"For default image based persistency"
	(self scheduler isScheduledBlock: [AIDASite preImageSnapshot; imageSnapshot]) "schedule only once!!"
		ifTrue: [^nil]. 
	self scheduler
		everyHourAt: 0 
		runBlock: [AIDASite preImageSnapshot; imageSnapshot]! !

!AIDASite methodsFor: 'initialize-release'!
initNightlyCleanup
	"releasing session application state and other cleanup every night at 4:00"
	(self scheduler isScheduledBlock: [self nightlyCleanup]) ifTrue: [^nil]. "schedule only once!!"
	self scheduler
		everyDayAt: 4 
		runBlock:  [self nightlyCleanup]! !

!AIDASite methodsFor: 'initialize-release'!
initOther
	other := Dictionary new! !

!AIDASite methodsFor: 'initialize-release'!
initScheduledTasks
	self initHourlySnapshot.
	self initNightlyCleanup.! !

!AIDASite methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initTimestamps
	timestamps := IdentityDictionary new.
	self setLastTimeAliveTimestamp.
	self setCreatedTimestamp.

"WebServer default initTimestamps"! !

!AIDASite methodsFor: 'initialize-release'!
initialize
	super initialize.
	WebTransactionMonitor addServer: self.
	self initDefaultSettings.
	self initDemoOnRootUrl. 
	self initFavicon.
	self initScheduledTasks.
	WebTransactionMonitor commit.! !

!AIDASite methodsFor: 'statistics'!
isActive
	"there was some activity (requests served) on this site in last hour"
	self lastRequestTimestamp isNil ifTrue: [^false].
	^self lastRequestTimestamp asSeconds > (SpTimestamp now asSeconds - 3600)! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
isWebDAVEnabled
	"Is Web Distributed Authoring and Versioning (WebDAV, www.webdav.org) ienabled on this site"
		^(self settings includesKey: #WebDAVEnabled)
			 and: [self settings includesKey: #WebDAVEnabled]! !

!AIDASite methodsFor: 'settings' stamp: 'janko 11/24/2008 21:59'!
keywords
	"global keywords, added to all webpages generated on this site"
	^self settings  at: #keywords ifAbsent: ''
! !

!AIDASite methodsFor: 'settings' stamp: 'janko 11/24/2008 21:25'!
keywords: aString
	"global keywords, added to all webpages generated on this site"
	self settings  at: #keywords put: aString.
! !

!AIDASite methodsFor: 'statistics' stamp: 'jm 8/3/2010 10:06'!
lastCommitTimestamp
	"time and date of last commit to the database. If noone yet, return nil"
	^SpTimestamp fromSeconds: (self timestamps at: #LastCommit ifAbsent: [^nil])! !

!AIDASite methodsFor: 'statistics' stamp: 'jm 8/3/2010 10:06'!
lastRequestTimestamp
	"time and date of last web request. If noone yet, return nil"
	^SpTimestamp fromSeconds: (self timestamps at: #LastRequest ifAbsent: [^nil])! !

!AIDASite methodsFor: 'statistics'!
lastRequestTimestampText
	"time and date of last web request"
	^self lastRequestTimestamp notNil 
		ifTrue: [self lastRequestTimestamp asDate shorterPrintSloString, ' ',
			self lastRequestTimestamp asTime printSloString] 
		ifFalse: ['']! !

!AIDASite methodsFor: 'statistics' stamp: 'JM 4/25/2007 21:09'!
lastTimeAliveTimestamp
	"lastTimeAliveThread writes to timestamps every minute and commit. 
	Used in case of crash to determine, when a server was last time alive 
	and worked properly"
	^SpTimestamp fromSeconds: 
		(self timestamps at: #LastTimeAlive ifAbsentPut: [SpTimestamp now asSeconds])! !

!AIDASite methodsFor: 'private-serving'!
log: aString
	self diagnostics ifTrue: [Transcript show: aString].! !

!AIDASite methodsFor: 'private-serving'!
logRequest: aRequest
	| text |
	self diagnostics ifFalse: [^nil].
	text := self name, ' ',
 		Date today dayOfMonth printString, '.',
		Date today monthIndex printString, ' ',
		Time now hours printString, ':', 
		Time now minutes printString,
		' from ', (aRequest peer notNil ifTrue: [aRequest peer] ifFalse: ['']), ' ',
		aRequest methodName, ' ',
		aRequest urlString.
	self log: self cr, text, self cr, text, '              s'.! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/4/07 22:07'!
logStringFor: aRequest
	^self name, ' ',
 		Date today dayOfMonth printString, '.',
		Date today monthIndex printString, ' ',
		Time now hours printString, ':', 
		Time now minutes printString,
		' from ', (aRequest peer notNil ifTrue: [aRequest peer] ifFalse: ['']), ' url: ',
		aRequest urlString! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
logging

	"if true, all requests are logged into a database"
	^self settings  at: #logging ifAbsentPut: [false].! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
loggingPolicy
	^self settings at: #loggingPolicy ifAbsentPut: [#none].! !

!AIDASite methodsFor: 'settings'!
loggingPolicy: aSymbol
	"from who to log requests with WebCounters: #all, #excludeAdmins, #onlyGuests, #none"
	(#(#all, #excludeAdmins, #onlyGuests, #none) includes: aSymbol) 
		ifFalse: [self error: 'unknown policy'].
	self settings  at: #loggingPolicy put: aSymbol! !

!AIDASite methodsFor: 'system services'!
messenger
	"for sending and receiving emails"
	^self systemServices 
		at: #Messenger
		ifAbsentPut: [EMailMessenger newOn: self].! !

!AIDASite methodsFor: 'private' stamp: 'jm 2/7/2011 13:22'!
migrateSchedulerInSystemServices
	| scheduler |
	(self systemServices includesKey: #WebScheduler) ifTrue:
		[scheduler := self systemServices at: #WebScheduler.
		self systemServices at: #Scheduler put: scheduler.
		self systemServices removeKey: #WebScheduler].
! !

!AIDASite methodsFor: 'system services' stamp: ' 21/4/07 22:07'!
mimeMap
	^self systemServices 
		at: #MimeMap
		ifAbsent: 
			[self addSystemService: MIMEMap new named: #MimeMap.
			^self mimeMap].! !

!AIDASite methodsFor: 'statistics-counters' stamp: ' 21/4/07 22:07'!
minuteStatsProcess

	"every minute report to transcript"
	"WebServer default minuteStatsProcess"
	| hits pages new returning afterHits afterPages afterNew afterReturning |
	[
		hits := self totalCounter total.
		pages := self pagesCounter total.
		new :=	self newVisitorsCounter total.
		returning := self returningVisitorsCounter total.
		(Delay forSeconds: self secondsToMinute) wait.
		[self isServing] whileTrue: 
			[afterHits := self totalCounter total.
			afterPages := self pagesCounter total.
			afterNew := self newVisitorsCounter total.
			afterReturning := self returningVisitorsCounter total.
			Transcript cr; show: 
				self name, ' ', 
				Time now hours printString, ':', Time now minutes printString, ' ',
				'    last minute hits: ', (afterHits - hits) printDotString, 
				'    pages: ', (afterPages - pages) printDotString, 
				'    visitors new: ', (afterNew - new) printDotString, 
				'    returning: ', (afterReturning - returning) printDotString.
			self registerTopMinuteHits: (afterHits - hits) pages: (afterPages - pages).
			hits := afterHits. pages := afterPages.
			new := afterNew. returning := afterReturning.
			(Delay forSeconds: self secondsToMinute) wait].
	] fork.! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
newVisitorsCounter
	"counter of new sessions"
	(self counters includesKey: #NewVisitors) ifFalse: 
 		["self error: 'newVisitorsCounter ??'."
		self counters at: #NewVisitors put: WebCounter new].
	^self counters at: #NewVisitors

"WebServer default newVisitorsCounter"! !

!AIDASite methodsFor: 'private'!
nightlyCleanup
	"releasing session application state and other cleanup"
	"AIDASite allInstances do: [:each | each nightlyCleanup] "
	self isEnabled ifFalse: [^nil]. "no need to cleanup disabled sites"
	Transcript cr; show: '*** Aida site ', self name, ' nightly cleanup'.
	HTTPConnection allInstances do: [:each | each close].  "to GC all streams and buffers"
	self sessionManager removeGuestSessions.
	self sessionManager releaseApplicationState.
	self statistics removeReferersJustOneHit.! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
notFoundCounter
	"counter of not found errors"
	(self counters includesKey: #NotFound) ifFalse: 
 		[self counters at: #NotFound put: WebCounter new].
	^self counters at: #NotFound

"WebServer default notFoundCounter"! !

!AIDASite methodsFor: 'statistics'!
onActivityDo: aBlock on: aWebElement app: aWebApplication
	"register a block to be executed on activity on this site. With 1s period if very frequent"
	(self activityAnnouncers at: aWebApplication ifAbsentPut: Dictionary new)
		at: aWebElement id  put: aBlock

" AIDASite allInstances do: [:site | site initActivityAnnouncers] "! !

!AIDASite methodsFor: 'private-other'!
other
	^other! !

!AIDASite methodsFor: 'private-other'!
otherAt: aSymbol
	"other values"
	^self otherAt: aSymbol ifAbsent: [nil]! !

!AIDASite methodsFor: 'private-other'!
otherAt: aSymbol ifAbsent: aBlock
	"other values"
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!AIDASite methodsFor: 'private-other'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!AIDASite methodsFor: 'private-other'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
pagesCounter
	"counter of only text/html pages"
	(self counters includesKey: #Pages) ifFalse: 
 		["self error: 'pagesCounter ??'."
		self counters 	at: #Pages put: WebCounter new].
	^self counters at: #Pages

"WebServer default pagesCounter"! !

!AIDASite methodsFor: 'private'!
printString

	^'anAIDASite named: ', self name! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/8/07 09:38'!
properString: aString 
	"if two byte string, convert it to one byte, cut twobyte characters, make them $? "
	| stream |
	aString class == ByteString ifTrue: [^aString].
	stream := WriteStream on: String new.
	aString 
		do: [:char | stream nextPut: (char asInteger < 256 ifTrue: [char] ifFalse: [$?])].
	^stream contents! !

!AIDASite methodsFor: 'private-serving' stamp: 'jm 8/2/2010 16:18'!
redirectOn: aSession
	"Squeak specific!! "
	| location response |
	location := aSession redirectLink composeURLOn: aSession.
	location := AIDASite convert: location toCodepage: aSession codePage.
	location := location notNil 
		ifTrue: [location copyReplaceAll: '&amp;' with: '&'] "well, why exactly?"
		ifFalse: [''].
	response := HTTPResponse redirectLink "Squeak specific!! "
		location: location.
	aSession cookie ifFalse: [response cookie: (self cookieHeaderFor: aSession)].
	aSession redirectLink: nil.
	^response.! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
redirectToHost
	"if set, all requests are redirected to that hostname!!"
	| host |
	host := self settings  at: #redirectToHost ifAbsent: [^nil].
	(host isNil or: [host isEmpty]) ifTrue: [^nil].
	^host! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
redirectToHost: aHostnameString
	"if set, all requests are redirected to that hostname!!"
	self settings  at: #redirectToHost put: aHostnameString! !

!AIDASite methodsFor: 'private-serving'!
redirectToOtherHost: aRequest on: aSession
	| response |
	response := HTTPResponse redirectLink 
		location: self redirectToHost.
	aSession cookie ifFalse:  "if immediate redirect on a new session"
		[response cookie: (self cookieHeaderFor: aSession)].
	^response.! !

!AIDASite methodsFor: 'user services'!
register: anObjectOrApp onUrl: anUrlString
	"for easier registration of root domain objects or Apps"
	^self urlResolver defaultUrl: anUrlString for: anObjectOrApp! !

!AIDASite methodsFor: 'statistics-counters' stamp: ' 21/4/07 22:07'!
registerTopHourHits: aHitNumber pages: aPageNumber
	(self topHour at: 2) < aHitNumber ifTrue: 
		[self topHour
			at: 1 put: Timestamp now;
			at: 2 put: aHitNumber;
			at: 3 put: aPageNumber].! !

!AIDASite methodsFor: 'statistics-counters' stamp: ' 21/4/07 22:07'!
registerTopMinuteHits: aHitNumber pages: aPageNumber
	(self topMinute at: 2) < aHitNumber ifTrue: 
		[self topMinute
			at: 1 put: Timestamp now;
			at: 2 put: aHitNumber;
			at: 3 put: aPageNumber].! !

!AIDASite methodsFor: 'system services'!
registration
	"a registration app for new users to register"
	^self systemServices 
		at: #Registration
		ifAbsent: 
			[self addSystemService: WebRegistrationApp "as class!!" named: #Registration.
			self register: self registration onUrl: '/registration'.
			^self registration].! !

!AIDASite methodsFor: 'settings'!
registrationAllowed
	"is registration allowed on this site? By default no"
	^self settings at: #RegistrationAllowed ifAbsent: [false]! !

!AIDASite methodsFor: 'settings'!
registrationAllowed: aBoolean
	"is registration allowed on this site? By default no"
	^self settings at: #RegistrationAllowed put: aBoolean! !

!AIDASite methodsFor: 'start/stop'!
releaseApplicationState
	"release application state (appsForObjects) of all sessions"
	^self sessionManager releaseApplicationState! !

!AIDASite methodsFor: 'serving' stamp: 'mivsek 1/10/2008 18:46'!
reportException: anException
	 | report |
	Transcript cr; show: '*** error in web app code: ', anException errorString.
"	report := DebuggerService shortStackFor: anException initialContext ofSize: 10.
	(report  tokensBasedOn: Character cr) do: [:each |
		Transcript cr; show: '     ', each].
"! !

!AIDASite methodsFor: 'serving' stamp: 'mivsek 1/10/2008 18:47'!
reportSocketError: anException request: aRequest
	"some hard to find error while streaming, i'm trying to debug it with that report"
	Transcript cr; show: '**SpSocketError on ', self name, ': ', 
		anException parameter messageText; cr.
	Transcript show:  aRequest printString; cr.! !

!AIDASite methodsFor: 'statistics-counters' stamp: ' 21/4/07 22:07'!
requestsInYear: aYearNumber
	"return a number of requests on specified year"

	| count |
	count := 0.
	((self counters at: #Daily) at: aYearNumber ifAbsent: [^0]) do: [:dayCount |
		count := count + dayCount].
	^count! !

!AIDASite methodsFor: 'statistics-counters' stamp: ' 21/4/07 22:07'!
requestsOnDate: aDate
	"return a number of requests on specified date"

	^self totalCounter countsOnDate: aDate! !

!AIDASite methodsFor: 'start/stop' stamp: ' 21/4/07 22:07'!
restart
	self stop.
	self start.! !

!AIDASite methodsFor: 'private-backup/restore' stamp: 'np 1/15/2008 20:49'!
restoreSiteNamed: aString
	"boss in from file aidasite-<sitename>.obj"
	"AIDASite new restoreSiteNamed: 'test' "
	| filename site |
	filename := 'aidasite-', aString, '.obj'.
	site := (FileStream fileNamed: filename) fileInObjectAndCode.
	^site! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
returningVisitorsCounter
	"counter of returning sessions"
	(self counters includesKey: #ReturningVisitors) ifFalse: 
 		["self error: 'returningVisitorsCounter ??'."
		self counters
			at: #ReturningVisitors put: WebCounter new].
	^self counters at: #ReturningVisitors

"WebServer default returningVisitorsCounter"! !

!AIDASite methodsFor: 'system services'!
router
	"for routing the web requests to the appropriate request handler depending on url pattern"
	^self systemServices 
		at: #Router
		ifAbsent: [self addSystemService: (WebRouter newOn: self) named: #Router].! !

!AIDASite methodsFor: 'statistics' stamp: 'JM 4/26/2007 19:57'!
runningHistory
	"return a collection of server runs as array of:
		started timestamp,
		last alive = stopped (more or less) timestamp,
		uptime in seconds,
		downtime from previous run in seconds,
		crashed or not.
	Used to determine history 
	of server runnings and to calculate server avaiability. Last entry in collection is current run
	with last alive no more than minute before current time"
	"AIDASite default runningHistory"
	| collection newArray  arry |
	collection := OrderedCollection new.
	self runningHistoryCollection do: [:array |
		newArray := Array new: 5.
		newArray 
			at: 1 put: (SpTimestamp fromSeconds: (array at: 1));
			at: 2 put: (SpTimestamp fromSeconds: (array at: 2));
			at: 3 put: (((array at: 2) - (array at: 1)) max: 0);
			at: 4 put: 0;  "we will calculate later"
			at: 5 put: ((array size < 3) ifTrue: [true] ifFalse: [array at:3]).
		collection add: newArray copy].
	newArray := Array new: 5.
	newArray
		at: 1 put: self startedTimestamp;
		at: 2 put: self lastTimeAliveTimestamp;
		at: 3 put: (self lastTimeAliveTimestamp asSeconds - 
			self startedTimestamp asSeconds);
		at: 4 put: 0;  "we will calculate later"
		at: 5 put: false. "current run not crashed"
	collection add: newArray copy.
	2 to: collection size do: [:inx |
		arry := collection at: inx.
		arry at: 4 put:   "this started - previous last alived"
			((arry at: 1) asSeconds - ((collection at: inx-1) at: 2) asSeconds)
		].
	^collection! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
runningHistoryCollection
	^self timestamps at: #RunningHistory ifAbsentPut: [OrderedCollection new].! !

!AIDASite methodsFor: 'system services' stamp: 'jm 2/7/2011 13:23'!
scheduler
	"AIDASite allInstances do: [:each | each migrateSchedulerInSystemServices] "
	self migrateSchedulerInSystemServices. "if not already"
	^self systemServices
		at: #Scheduler
		ifAbsent:
			[self
				addSystemService: (WebScheduler newOn: self)
				named: #Scheduler]! !

!AIDASite methodsFor: 'statistics-counters' stamp: ' 21/4/07 22:07'!
secondsToHour

	| now | 
	now := Time now asSeconds.
	^(3600 - (now - (now // 3600 * 3600))) max: 0

"WebServer default secondsToHour"! !

!AIDASite methodsFor: 'statistics-counters' stamp: ' 21/4/07 22:07'!
secondsToMinute

	| now | 
	now := Time now asSeconds.
	^(60 - (now - (now // 60 * 60))) max: 0

"WebServer default secondsToMinute"! !

!AIDASite methodsFor: 'system services'!
securityManager
	^self systemServices 
		at: #SecurityManager
		ifAbsent: 
			[self 
				addSystemService: (WebSecurityManager newOn: self)
				named: #SecurityManager.
			self register: self securityManager onUrl: '/security'.
			self securityManager initialize.
			^self securityManager].! !

!AIDASite methodsFor: 'system services' stamp: ' 21/4/07 22:07'!
sessionManager
	^self systemServices 
		at: #SessionManager
		ifAbsent: 
			[self 
				addSystemService: (WebSessionManager newOn: self)
				named: #SessionManager.
			^self sessionManager].! !

!AIDASite methodsFor: 'private' stamp: 'JM 4/25/2007 20:47'!
setCreatedTimestamp
	"set the server creation timestamp to current date and time."
	self timestamps 
		at: #Created put: SpTimestamp now asSeconds.! !

!AIDASite methodsFor: 'settings'!
setDefaultAuthenticator
	"DefaultAuthenticator authentificates the user during login by username and password, which 
	are stored locally in site's security manager"
	^self addSystemService: (DefaultAuthenticator newOn: self) named: #Authenticator! !

!AIDASite methodsFor: 'settings' stamp: 'janko 4/20/2012 17:14'!
setDefaultFederatedAuthenticator
	"OpenID is a default federated authentificator"
	^self 
		addSystemService: (OpenIDAuthenticator newOn: self) 
		named: #FederatedAuthenticator! !

!AIDASite methodsFor: 'settings'!
setDefaultFederatedAuthorizator
	"OAuth is a default federated authorizator, accessible on /authorizator as well"
	| auth |
	auth := self 
		addSystemService: (OAuthAuthorizator newOn: self) 
		named: #FederatedAuthorizator.
	self register: auth onUrl: '/authorizator'.
	^auth! !

!AIDASite methodsFor: 'private' stamp: 'jm 8/3/2010 10:10'!
setLastCommitTimestamp
	"set the last commit timestamp to current date and time"
	self critical: [
		self timestamps 
			at: #LastCommit 
			put: SpTimestamp now asSeconds].! !

!AIDASite methodsFor: 'private' stamp: 'jm 8/3/2010 10:10'!
setLastRequestTimestamp
	"set the last web request timestamp to current date and time"
	self critical: [
		self timestamps at: #LastRequest put: SpTimestamp now asSeconds].! !

!AIDASite methodsFor: 'private' stamp: 'JM 4/25/2007 20:48'!
setLastTimeAliveTimestamp
	"A lastTimeAliveThread sets this timestamp every minute"
	self critical: [
		self timestamps at: #LastTimeAlive put: SpTimestamp now asSeconds].! !

!AIDASite methodsFor: 'private' stamp: 'JM 4/25/2007 21:09'!
setStartedTimestampCrashed: aBoolean
	"set the last server startup timestamp to current date and time.  
	Before that records old created and last alive timestamp to a running history.
	Argument shows if server was running, therefore crashed, or was stoped normaly"
	self addToRunningHistoryCrashed: aBoolean.
	self timestamps 
		at: #Started put: SpTimestamp now asSeconds.! !

!AIDASite methodsFor: 'private'!
settings
	settings isNil ifTrue: 
		[settings := Dictionary new. 
		self initDefaultSettings].
	^settings

"WebServer default settings"! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
settingsReport
	"a brief report of current settings to transcript, used at site startup"
	Transcript cr; show: 'server diagnostics: '.
	self diagnostics
		ifTrue: [Transcript show: 'ON']
		ifFalse: [Transcript show: 'OFF'].
	Transcript cr.! !

!AIDASite methodsFor: 'private-serving' stamp: ' 21/4/07 22:07'!
shouldRedirect
	^self redirectToHost notNil! !

!AIDASite methodsFor: 'settings' stamp: 'mivsek 1/10/2008 18:55'!
smtpServer
	"an address of email server for outgoing mails (notifications, mailing lists etc.)"
	^self settings  at: #smtpServer ifAbsentPut: [self host].
! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
smtpServer: anAddressString
	"an address of email server for outgoing mails (notifications, mailing lists etc.)"
	self settings  at: #smtpServer put: anAddressString.! !

!AIDASite methodsFor: 'start/stop'!
start
	self isEnabled ifFalse: [^nil].
	self setStartedTimestampCrashed: self isServing.
	self setLastTimeAliveTimestamp.
	super start.
	self startServices.! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
startServices
	self systemServices values do: [:service | (service class canUnderstand: #start) ifTrue: [service start] ].
	self userServices values do: [:service | (service class canUnderstand: #start) ifTrue: [service start] ].! !

!AIDASite methodsFor: 'statistics'!
startedDate
	"date of last server startup"
	^self startedTimestamp notNil 
		ifTrue: [self startedTimestamp asDate] 
		ifFalse: [nil]! !

!AIDASite methodsFor: 'statistics' stamp: 'JM 4/25/2007 21:08'!
startedTimestamp
	"time and date of last server startup"
	^SpTimestamp fromSeconds:
		(self timestamps at: #Started ifAbsentPut: [SpTimestamp now asSeconds])! !

!AIDASite methodsFor: 'system services'!
staticServer
	"serving static content from files"
	^self systemServices 
		at: #StaticServer
		ifAbsent: 
			[self addSystemService: (WebStaticServer newOn: self) named: #StaticServer.
			self staticServer initialize. "to add it to router and cleanup urlResolver of files"
			self staticServer]! !

!AIDASite methodsFor: 'system services'!
statistics
	^self systemServices 
		at: #Statistics
		ifAbsent: 
			[self 
				addSystemService: (WebStatistics newOn: self)
				named: #Statistics.
			self register: self statistics onUrl: '/stats'.
			^self statistics].! !

!AIDASite methodsFor: 'start/stop' stamp: ' 21/4/07 22:07'!
stop
	super stop.
	self stopServices.
	self setLastTimeAliveTimestamp.! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
stopServices
	self systemServices values do: [:service | (service class canUnderstand: #stop) ifTrue: [service stop] ].
	self userServices values do: [:service | (service class canUnderstand: #stop) ifTrue: [service stop] ].! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
stopWatchdog
	self watchdog notNil ifTrue: 
		[self watchdog terminate.
		self watchdog: nil].! !

!AIDASite methodsFor: 'accessing' stamp: 'JM 4/25/2007 21:07'!
style
	style isNil ifTrue: 
		[self style: ((Smalltalk at: self styleClass asSymbol) value newOnSite: self)].
	^style! !

!AIDASite methodsFor: 'private'!
style: aWebStyle
	(aWebStyle isNil or: [aWebStyle isKindOf: WebStyle]) 
		ifFalse: [self error: 'Set the style with method #styleClass: instead!!'].
	style := aWebStyle.! !

!AIDASite methodsFor: 'settings' stamp: 'np 4/2/2008 23:36'!
styleClass
	(self settings includesKey: #styleClass) ifFalse: 
		[self styleClass: 'DefaultWebStyle' ].
	^(self settings  at: #styleClass) asString! !

!AIDASite methodsFor: 'settings'!
styleClass: aClassOrString
	"name of a class to provide a style support for this site. Default is WebStyle"
	| nme |
	nme := (aClassOrString isKindOf: String)
		ifTrue: [aClassOrString] ifFalse: [aClassOrString name asString].
	self settings  at: #styleClass put: nme.
	self style: nil.  "to initialize new style immediatelly, if possible"
	[self style] 
		on: Error do: [:ex | "nothing"]! !

!AIDASite methodsFor: 'settings' stamp: 'mivsek 1/10/2008 18:56'!
supportedLanguages
	"Which languages are supported on this site. Content may be in all those languages. 
	Default language is always among supported."
	^(self settings at: #supportedLanguages ifAbsent: [Set new])
		add: self defaultLanguage; yourself! !

!AIDASite methodsFor: 'settings' stamp: 'mivsek 1/10/2008 18:57'!
supportedLanguages: aSetOfLangCodes
	"Which languages are supported on this site. Content may be in all those languages. 
	Default language is always among supported."
	^self settings at: #supportedLanguages put: aSetOfLangCodes asSet! !

!AIDASite methodsFor: 'system services'!
systemServiceNamed: aSymbol
	"return a system service object with a specified name"
	^self systemServices at: aSymbol asSymbol ifAbsent: [^nil]! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
systemServices
	"return a dictionary of system services (e.g. URLResolver, ImageManager etc.)"
	systemServices isNil 
		ifTrue: [systemServices := Dictionary new].
	^systemServices! !

!AIDASite methodsFor: 'settings' stamp: 'np 10/18/2008 13:17'!
tempDirectory
	" a directory for temporary files, usually ./temp. This directory is also created if not exist yet "
	^self settings  at: #tempDirectory ifAbsent: 
		[^self tempDirectory: self homeDirectory, 'temp']! !

!AIDASite methodsFor: 'settings' stamp: 'np 10/18/2008 13:17'!
tempDirectory: aString
	" a directory for temporary files, usually ./temp. This directory is also created if not exist yet "
	| dir |
	self settings at: #tempDirectory put: aString.
	dir := SpFilename named: self tempDirectory.
	dir exists ifFalse: [dir makeDirectory].
	^self tempDirectory! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
timestamps
	timestamps isNil ifTrue: [self initTimestamps].
	^timestamps! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
topHour
	"a hour of most hits, an array with timestamp, hits and pages"
	(self counters includesKey: #TopHour) ifFalse: 
 		[self counters at: #TopHour put: (Array with: Timestamp now with: 0 with: 0)].
	^self counters at: #TopHour

"WebServer default topHour"! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
topMinute
	"a minute of most hits, an array with timestamp, hits and pages"
	(self counters includesKey: #TopMinute) ifFalse: 
 		[self counters at: #TopMinute put:  (Array with: Timestamp now with: 0 with: 0)].
	^self counters at: #TopMinute

"WebServer default topMinute"! !

!AIDASite methodsFor: 'private-counters' stamp: ' 21/4/07 22:07'!
totalCounter
	"counter of all web requests"
	(self counters includesKey: #Total) ifFalse: 
 		["self error: 'totalCounter ??'."
		self counters at: #Total put: WebCounter new].
	^self counters at: #Total

"WebServer default totalCounter"! !

!AIDASite methodsFor: 'statistics' stamp: ' 21/4/07 22:07'!
totalDowntime
	"return downtime between all server runs in seconds"
	"AIDASite default totalDowntime"
	| history downtime |
	history := self runningHistory.
	downtime := 0.
	history do: [:array | downtime := downtime + (array at: 4)].
	^downtime! !

!AIDASite methodsFor: 'statistics-counters' stamp: ' 21/4/07 22:07'!
totalRequests
	"return a number of requests from server creation"

	^self totalCounter total.! !

!AIDASite methodsFor: 'statistics' stamp: ' 21/4/07 22:07'!
totalUptime
	"return uptime of all server runs in seconds"
	"AIDASite default totalUptime"
	| history uptime |
	history := self runningHistory.
	uptime := 0.
	history do: [:array | uptime := uptime + (array at: 3)].
	^uptime! !

!AIDASite methodsFor: 'system services' stamp: 'np 3/25/2009 15:36'!
translator
	"translation support for Apps"
	^self systemServices 
		at: #Translator
		ifAbsent: [self addSystemService: (WebTranslator newOn: self) named: #Translator].! !

!AIDASite methodsFor: 'statistics' stamp: ' 21/4/07 22:07'!
uptime
	"return uptime of current server run in seconds (with 60s precision)"
	"AIDASite default uptime"
	^self lastTimeAliveTimestamp asSeconds - self startedTimestamp asSeconds! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
urgentNotificationEMail

	"an email address or addresses (separated by comma) of all recipients of urgent server notifications "

	^self settings  at: #urgentNotificationEMail ifAbsentPut: ['janko.mivsek@eranova.si'].! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
urgentNotificationEMail: anEMailAddressString
	"an email address or addresses (separated by comma) of all recipients of urgent server notifications "
	self settings  at: #urgentNotificationEMail put: anEMailAddressString.! !

!AIDASite methodsFor: 'system services' stamp: ' 21/4/07 22:07'!
urlResolver
	^self systemServices 
		at: #URLResolver
		ifAbsent: 
			[self 
				addSystemService: (URLResolver newOn: self) 
				named: #URLResolver.
			^self urlResolver].! !

!AIDASite methodsFor: 'settings' stamp: 'np 5/6/2008 17:18'!
urlsWithSessionId
	"is session id added to urls when browser cookie support is disabled?"
	^self settings at: #urlsWithSessionId ifAbsentPut: false! !

!AIDASite methodsFor: 'settings'!
urlsWithSessionId: aBoolean
	"is session id added to urls when browser cookie support is disabled?"
	(aBoolean isKindOf: Boolean) ifFalse: [self error: 'wrong argument'].
	^self settings at: #urlsWithSessionId put: aBoolean! !

!AIDASite methodsFor: 'user services'!
userServiceNamed: aSymbol
	"return a user service object with a specified name"
	^self userServices at: aSymbol asSymbol ifAbsent: [^nil]! !

!AIDASite methodsFor: 'private' stamp: ' 21/4/07 22:07'!
userServices
	"return a dictionary of user services (e.g. WebIndex, WebNews etc.)"
	userServices isNil ifTrue: [userServices := Dictionary new. ].
	^userServices! !

!AIDASite methodsFor: 'private' stamp: 'janko 8/2/2008 15:02'!
watchdogAction
	self setLastTimeAliveTimestamp! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
webServerEMail

	"an email address of this web server "

	^self settings  at: #webServerEMail ifAbsentPut: ['aida-web@eranova.si'].! !

!AIDASite methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
webServerEMail: anEMailString
	"an email address of this web server "
	self settings  at: #webServerEMail put: anEMailString.! !

!AIDASite methodsFor: 'settings'!
webUserClass
	"set if other class than WebUser is used for creating/registering users"
	^self settings at: #WebUserClass ifAbsent: [WebUser]! !

!AIDASite methodsFor: 'settings'!
webUserClass: aClass
	"set if other class than WebUser is used for creating/registering users"
	^self settings at: #WebUserClass put: aClass! !

!AIDASite class methodsFor: 'slovenian characters' stamp: 'JM 4/26/2007 20:02'!
charC
	"return internal  unicode code for slovene character: uppercase c"
	^16r010C asCharacter! !

!AIDASite class methodsFor: 'slovenian characters' stamp: ' 21/4/07 22:07'!
charCszSet
	^Set new
		add: self charc; add: self charC;
		add: self chars; add: self charS;
		add: self charz; add: self charZ;
		yourself! !

!AIDASite class methodsFor: 'slovenian characters' stamp: 'JM 4/26/2007 20:06'!
charS
	"return internal  unicode code for slovene character: uppercase s"
	^16r0160 asCharacter! !

!AIDASite class methodsFor: 'slovenian characters' stamp: ' 21/4/07 22:07'!
charZ
	"return internal unicode code for slovene character: uppercase z"
	^16r017D asCharacter! !

!AIDASite class methodsFor: 'slovenian characters' stamp: ' 21/4/07 22:07'!
charc
	"return internal  unicode code for slovene character: lowercase c"
	^16r010D asCharacter! !

!AIDASite class methodsFor: 'slovenian characters' stamp: ' 21/4/07 22:07'!
chars
	"return internal  unicode code for slovene character: lowercase s"
	^16r0161 asCharacter! !

!AIDASite class methodsFor: 'slovenian characters' stamp: 'JM 4/26/2007 20:07'!
charz
	"return internal unicode code for slovene character: lowercase z"
	^16r017E asCharacter! !

!AIDASite class methodsFor: 'codepage converting' stamp: 'mu 3/7/2008 20:21'!
convert: aString fromCodepage: aSymbol
	"convert aString to internal unicode"
	| encoding |
	(#(#'win-1250' #'win1250' #'Windows-1250' cp1250) includes: aSymbol) 
		ifTrue: [encoding := #'cp-1250'].
	(#(#'iso-8859-2' #'iso8859-2' #'ISO-8859-2' iso2) includes: aSymbol) 
		ifTrue: [encoding := #'iso-8859-2'].
	(#(#utf8 #'utf-8' #'utf_8' #UTF8 #'UTF-8' #'UTF_8') includes: aSymbol) 
		ifTrue: [encoding := #utf8].
	encoding isNil ifTrue: [^aString].

	^[aString convertFromEncoding: encoding] on: Error do: [:ex | aString ].

	
"AIDASite convert: (String with: 16rC4 asCharacter with: 16r8D asCharacter) fromCodepage: #utf8 "! !

!AIDASite class methodsFor: 'codepage converting' stamp: 'mu 3/8/2008 16:34'!
convert: aString toCodepage: aSymbol
	"convert internal unicode aString to codepage. "
	| encoding converter in out |
	(#(#'win-1250' #'win1250' #'Windows-1250' cp1250) includes: aSymbol) 
		ifTrue: [encoding := #'cp-1250'].
	(#(#'iso-8859-2' #'iso8859-2' #'ISO-8859-2' iso2) includes: aSymbol) 
		ifTrue: [encoding := #'iso-8859-2'].
	(#(#utf8 #'utf-8' #'utf_8' #UTF8 #'UTF-8' #'UTF_8') includes: aSymbol) 
		ifTrue: [encoding := #'utf8'].
	encoding isNil ifTrue: [^aString].

	converter := (TextConverter newForEncoding: encoding) ifNil: [UTF8TextConverter new].
	in := aString readStream.
	out := WriteStream on: ''.
	[in atEnd] whileFalse: [converter nextPut: in next toStream: out].
	^out contents

"AIDASite convert: (String with: 16r010D asCharacter) toCodepage: #utf8 "! !

!AIDASite class methodsFor: 'codepage converting' stamp: ' 21/4/07 22:07'!
convertFromWeb: aString on: aSession
	"convert aString, which is in code page, defined in aSession to an internal unicode "
	^self convert: aString fromCodepage: aSession codePage! !

!AIDASite class methodsFor: 'http encoding'!
convertFromWebString: aString
	"converts special chars in http stream: 
		'+' as ' '
		%xx as appropriate ASCII char
	"
	| newString |
	newString := HTTPString decodedHTTPFrom: aString.
	newString := AIDASite convert:newString fromCodepage: #'utf-8'.
	^newString

"AIDASite convertFromWebString: (AIDASite convertToWebString: '+-% test one') "! !

!AIDASite class methodsFor: 'http encoding' stamp: 'np 9/26/2008 12:50'!
convertIRItoURL: aString
	| stream aByteString |
	stream _ WriteStream on: ''.
	aByteString _ self convert: aString toCodepage: #utf8.
	aByteString do: [ :char |
	('abcdefghijklmnopqrstuvwxyz0123456789./-+:~?#@=' includes: char asLowercase)
		ifTrue: [ stream nextPut: char. ]
		ifFalse: [ stream nextPut: $%; nextPutAll: (char codePoint radix: 16). ]. ].
	^ stream contents.! !

!AIDASite class methodsFor: 'codepage converting' stamp: ' 21/4/07 22:07'!
convertToWeb: aString on: aSession
	"rconver internal unicode aString to a proper code page, defined in aSession"
	^self convert: aString toCodepage: aSession codePage! !

!AIDASite class methodsFor: 'http encoding'!
convertToWebString: aString
	"converts some special chars in http stream: 
		' ' as '+'
		%xx as appropriate ASCII char
	"
	^HTTPString encodedHTTPFrom: aString 

"AIDASite convertToWebString: '+-% test one' "! !

!AIDASite class methodsFor: 'http encoding'!
decodeCharEntitiesIn: aString
	"  '&lt;tag&gt; = '<tag>'  "
	"Character entitty references, see http://www.w3.org/TR/html401/charset.html#h-5.3.2"
	| charDict in out |
	charDict := Dictionary new
		at: 'lt' put: $<; at: 'gt' put: $>;
		at: 'amp' put: $&; at: 'quot' put: $"; yourself.
	in := aString readStream. out := WriteStream on: String new.
	[in atEnd] whileFalse: 
		[| ch entity | 
		ch := in next.
		ch = $& 
			ifTrue: 
				[entity := in upTo: $; .
				out nextPut: (charDict at: entity)]
			ifFalse: [out nextPut: ch]  ].
	^out contents! !

!AIDASite class methodsFor: 'accessing' stamp: 'mu 2/3/2008 16:44'!
default
	"just return default instance set by default:"
	^Default! !

!AIDASite class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
default: aString
	"make a site with that name a default one"
	| site |
	site := SwazooServer singleton siteNamed: aString.
	site isNil ifTrue: [^self error: 'site with that name does not exist!!'].
	Default := site.
	^site! !

!AIDASite class methodsFor: 'http encoding'!
encodeCharEntitiesIn: aString
	"  '<tag>' = '&lt;tag&gt;' "
	"Character entitty references,  see http://www.w3.org/TR/html401/charset.html#h-5.3.2"
	| charEntities charDict in out |
	charEntities := #($< $> $& $").
	(aString contains: [:ch | charEntities includes: ch ]) ifFalse: [^aString]. "quick test"
	charDict := Dictionary new
		at: $< put: '&lt;'; at: $> put: '&gt;';
		at: $& put: '&amp;'; at: $" put: '&quot;'; yourself.
	in := aString readStream. out := WriteStream on: String new.
	[in atEnd] whileFalse: 
		[| ch | ch := in next.
		(charEntities includes: ch)
			ifTrue: [out nextPutAll: (charDict at: ch)]
			ifFalse: [out nextPut: ch]  ].
	^out contents! !

!AIDASite class methodsFor: 'http encoding'!
encodeQuoteEntitiesIn: aString
	" Just double quotes '' to &quot;  "
	"Character entitty references,  see http://www.w3.org/TR/html401/charset.html#h-5.3.2"
	| in out |
	(aString contains: [:ch | ch = $" ]) ifFalse: [^aString]. "quick test"
	in := aString readStream. out := WriteStream on: String new.
	[in atEnd] whileFalse: 
		[| ch | ch := in next.
		ch = $"
			ifTrue: [out nextPutAll: '&quot;']
			ifFalse: [out nextPut: ch]  ].
	^out contents! !

!AIDASite class methodsFor: 'http encoding' stamp: ' 21/4/07 22:07'!
fromHexValue: aCharacter
	aCharacter isDigit 
		ifTrue: [^aCharacter asInteger - $0 asInteger]
		ifFalse: [
			(aCharacter asLowercase between: $a and: $f)
				ifTrue: [^aCharacter asLowercase asInteger - $a asInteger+10]
				ifFalse: [^nil]].! !

!AIDASite class methodsFor: 'http encoding' stamp: ' 21/4/07 22:07'!
hexCharFrom: aNumber
	^aNumber < 10 
		ifTrue: [($0 asInteger + aNumber) asCharacter]
		ifFalse: [($A asInteger + aNumber - 10) asCharacter]! !

!AIDASite class methodsFor: 'image snapshot' stamp: 'janko 4/21/2012 16:02'!
imageSnapshot
	"Save an image and show elapsed time on transcript"
	"Snapshoting is coordinated so that only one snapshot occurs out of many calls"
	"AIDASite imageSnapshot"
	"Squeak specific"
	| elapsed |
	(self isHourlySnapshot and: [self shallSnapshot]) ifFalse: [^nil]. "to allow only one snapshot per hour"
	self setLastSnapshot.
	self reportImageState. "for debugging"
	WebSessionManager allInstances do: [:each | each removeNonactiveGuestSessions].	"this really belongs here?"
	Processor activeProcess priority: Processor userInterruptPriority. "to avoid image block bug"
	elapsed := Time millisecondsToRun: [SmalltalkImage current saveSession]. "Squeak specific"
	Transcript show: ' in ', (elapsed // 1000) printString, 's '.  "reports elapsed time to Transcript"! !

!AIDASite class methodsFor: 'slovenian characters' stamp: 'JM 4/26/2007 20:07'!
initSloveneCharacters
	"AIDASite initSloveneCharacters"
	SloveneCharacters := Set new: 6.
	^SloveneCharacters 
		add: self charC;
		add: self charc;
		add: self charS;
		add: self chars;
		add: self charZ;
		add: self charz;
		yourself! !

!AIDASite class methodsFor: 'initialize' stamp: 'jm 2/4/2011 19:56'!
initialize
	"AIDASite initialize"
	"prepare a demo site, if not already, and start it"
	self initializeDemoSite ! !

!AIDASite class methodsFor: 'initialize'!
initializeDemoSite
	"prepare and start a demo site, if not already"
	"put that in Aida/Web bundle postLoad action!!"
	SwazooServer singleton aidaSites isEmpty ifTrue:
		[SwazooServer singleton 
			aidaDemoSite;
			start.
		Transcript 
			cr; cr; 
			show: '*** Aida/Web demo site started, open http://localhost:8888'; 
			cr; cr].! !

!AIDASite class methodsFor: 'private'!
isHourlySnapshot
	"Shall snapshot image every hour? Yes by default"
	HourlySnapshot isNil ifTrue: [self setHourlySnapshot].
	^HourlySnapshot! !

!AIDASite class methodsFor: 'slovenian characters' stamp: 'JM 4/26/2007 20:07'!
isSloveneCharacter: aCharacter
	"return true if character is slovene"
	SloveneCharacters isNil ifTrue: [self initSloveneCharacters].
	^SloveneCharacters includes: aCharacter

"AIDASite isSloveneCharacter: AIDASite charC"! !

!AIDASite class methodsFor: 'private'!
lastPreSnapshot
	"a timestamp of last pre snapshoot activity"
	LastPreSnapshot isNil ifTrue: [LastPreSnapshot := 
		(SpTimestamp fromSeconds: SpTimestamp now asSeconds - (24*3600))]. "something older than 5min!!"
	^LastPreSnapshot! !

!AIDASite class methodsFor: 'private'!
lastSnapshot
	"a timestamp of last image snapshot"
	LastSnapshot isNil ifTrue: [LastSnapshot := 
		(SpTimestamp fromSeconds: SpTimestamp now asSeconds - (24*3600))]. "something older than 5min!!"
	^LastSnapshot! !

!AIDASite class methodsFor: 'testing' stamp: 'jm 8/26/2009 16:21'!
onPharo
	"Squeak specific" "Pharo specific"
	Dialect isNil ifTrue: [self setDialect].
	^Dialect = #Pharo! !

!AIDASite class methodsFor: 'testing' stamp: 'jm 8/26/2009 16:22'!
onSqueak
	"Squeak specific" "Pharo specific"
	Dialect isNil ifTrue: [self setDialect].
	^Dialect = #Squeak! !

!AIDASite class methodsFor: 'image snapshot' stamp: 'janko 10/21/2011 16:57'!
preImageSnapshot
	"backup previous image on disk"
	"Squeak specific"
	"AIDASite preImageSnapshot"
	| imgFilename imgBckFilename |
	self shallPreSnapshot ifFalse: [^false]. "to avoid multible backups by calls from multiple sites "
	self setLastPreSnapshot. self setLastSnapshot. "to avoid other sites to snapshot"
	Transcript cr; show: 'img backup..'.
	imgFilename := Smalltalk imageName copyReplaceAll: '.image' with: ''.
	imgBckFilename := imgFilename, '-bck'.
	SpEnvironment onWindows not
		ifTrue: [OSProcess waitForCommand: 'cp ', (imgFilename, '.image'), ' ', imgBckFilename, '.image'.
			OSProcess waitForCommand: 'cp ', (imgFilename, '.changes'), ' ', imgBckFilename, '.changes']
		ifFalse: [OSProcess waitForCommand: 'copy /Y ', (imgFilename, '.image'), ' ', imgBckFilename, '.image'.
			OSProcess waitForCommand: 'copy /Y ', (imgFilename, '.changes'), ' ', imgBckFilename, '.changes'].
	Transcript show: 'done, '.
	self resetLastSnapshot. "so that #imageSnapshot will now continue"
! !

!AIDASite class methodsFor: 'codepage converting'!
properArray: aStringOrByteArray
	"if two byte (or wide) string, convert it to one byte, cut twobyte characters, make them $? "
	| stream |
	aStringOrByteArray class == ByteString ifTrue: [^aStringOrByteArray].
	aStringOrByteArray class == ByteArray ifTrue: [^aStringOrByteArray].
	aStringOrByteArray class == Array ifTrue: [^aStringOrByteArray asByteArray].
	stream := WriteStream on: (String new: aStringOrByteArray size *2).
	aStringOrByteArray "TwoByteArray or WideArray"
		do: [:char | stream nextPut: (char asInteger < 256 ifTrue: [char] ifFalse: [$?])].
	^stream contents! !

!AIDASite class methodsFor: 'utilities' stamp: 'janko 7/18/2008 17:57'!
random
	"a random generator, always seeded and therefore ready to geenrate numbers which are really 
       random"
	RandomGen isNil ifTrue: [RandomGen := Random new].
	^RandomGen! !

!AIDASite class methodsFor: 'image snapshot' stamp: 'janko 8/25/2012 19:05'!
reportImageState
	"AIDASite reportImageState"
"	Transcript cr; show: '** image state: '.
	Transcript cr; show: '   ', HTTPConnection allInstances size printString, ' HTTPCommections'.
	Transcript cr; show: '   ', Socket allInstances size printString, ' Sockets'.
	Transcript cr; show: '   ', Process allInstances size printString, ' Processes'.
	Transcript cr; show: '   ', Semaphore allInstances size printString, ' Semaphores'.
	Transcript cr; show: '   ', Socket registry size printString, ' Socket registry'.
	Transcript cr; show: '   ', StandardFileStream registry size printString, ' StandardFileStream registry'.
	Transcript cr; show: '   ', (ExternalSemaphoreTable unprotectedExternalObjects reject: #isNil) size 
		printString, ' ExternalSemaphoreTable'.
"
! !

!AIDASite class methodsFor: 'image snapshot'!
resetHourlySnapshot
	"Don't snapshot image every hour"
	"AIDASite resetHourlySnapshot"
	HourlySnapshot := false! !

!AIDASite class methodsFor: 'private'!
resetLastSnapshot
	"in preImageSnapshot to indicate that it is finished and imageSnapshot can continue"
	LastSnapshot := nil! !

!AIDASite class methodsFor: 'private' stamp: 'jm 2/1/2011 21:32'!
setDialect
	"for now only Squeak or Pharo"
	"Squeak specific" "Pharo specific"
	Dialect := (('Pharo*' match: SystemVersion current version)
		ifTrue: [#Pharo]
		ifFalse: [#Squeak])
	! !

!AIDASite class methodsFor: 'image snapshot'!
setHourlySnapshot
	"Snapshot image every hour"
	"AIDASite resetHourlySnapshot"
	HourlySnapshot := true! !

!AIDASite class methodsFor: 'private'!
setLastPreSnapshot
	"a timestamp of last pre snapshot activity"
	LastPreSnapshot := SpTimestamp now! !

!AIDASite class methodsFor: 'private'!
setLastSnapshot
	"a timestamp of last image snapshot"
	LastSnapshot := SpTimestamp now! !

!AIDASite class methodsFor: 'private'!
shallPreSnapshot
	"yes, if allowed and if there were no presnapshot last 5 minutes"
	self isHourlySnapshot ifFalse: [^false].
	^(SpTimestamp now asSeconds - self lastPreSnapshot asSeconds) > (5*60)! !

!AIDASite class methodsFor: 'private'!
shallSnapshot
	"yes, if allowed and if there were no snapshot last 5 minutes"
	self isHourlySnapshot ifFalse: [^false].
	^(SpTimestamp now asSeconds - self lastSnapshot asSeconds) > (5*60)! !

!AIDASite class methodsFor: 'slovenian characters' stamp: 'JM 4/26/2007 20:07'!
sloveneLowercase: aString
	^aString collect: [:chr | 
		(AIDASite isSloveneCharacter: chr)
			ifTrue: 	[(chr = AIDASite charC) ifTrue: [AIDASite charc]
				ifFalse: [(chr = AIDASite charS) ifTrue: [AIDASite chars]
					ifFalse: [(chr = AIDASite charZ) ifTrue: [AIDASite charz]
						ifFalse: [chr] ]]]
			ifFalse: [chr asLowercase]
		].! !

!AIDASite class methodsFor: 'slovenian characters' stamp: 'JM 4/26/2007 20:08'!
sloveneUppercase: aString
	^aString collect: [:chr | 
		(AIDASite isSloveneCharacter: chr)
			ifTrue: 	[(chr = AIDASite charc) ifTrue: [AIDASite charC]
				ifFalse: [(chr = AIDASite chars) ifTrue: [AIDASite charS]
					ifFalse: [(chr = AIDASite charz) ifTrue: [AIDASite charZ]
						ifFalse: [chr] ]]]
			ifFalse: [chr asUppercase]
		].! !

!AIDASite class methodsFor: 'accessing'!
version
	^'6.5'! !

!AIDASiteTest methodsFor: 'testing'!
testEncodeCharEntitites
	self assert: ((AIDASite encodeCharEntitiesIn: '<tag>') = '&lt;tag&gt;').
	self assert: ((AIDASite decodeCharEntitiesIn: '&lt;tag&gt;') = '<tag>').
	self assert: ((AIDASite encodeCharEntitiesIn: '<>&"') = '&lt;&gt;&amp;&quot;').
	self assert: ((AIDASite decodeCharEntitiesIn: '&lt;&gt;&amp;&quot;') = '<>&"').! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
city
	city isNil ifTrue: [^''].
	^city! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
city: aString
	city := aString.! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
company
	company isNil ifTrue: [^''].
	^company! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
company: aString
	company := aString.! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
country
	country isNil ifTrue: [^''].
	^country! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
country: aString
	country := aString.! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
email
	self emails size > 0 ifTrue: [^self emails at: 1].
	^' '! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
email: aString 
	self emails size > 0 ifTrue: [^self emails at: 1 put: aString].
	^self emails add: aString! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
emails
	emails isNil ifTrue: [self initEMails].
	^emails! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
fax
	fax isNil ifTrue: [^''].
	^fax! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
fax: aString
	fax := aString.! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
firstName
	firstName isNil ifTrue: [^''].
	^firstName! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
firstName: aString
	firstName := aString.! !

!Address methodsFor: 'initialize - release' stamp: ' 10/1/08 16:40'!
initEMails
	emails := OrderedCollection new.! !

!Address methodsFor: 'initialize - release' stamp: ' 10/1/08 16:40'!
initPhones
	phones := OrderedCollection new.
	phones add: ''.! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
lastName
	lastName isNil ifTrue: [^''].
	^lastName! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
lastName: aString
	lastName := aString.! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
middleName
	middleName isNil ifTrue: [^''].
	^middleName! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
middleName: aString
	middleName := aString.! !

!Address methodsFor: 'private' stamp: ' 10/1/08 16:40'!
migrateToUnicode
	"from iso8859-2"
	"Address allInstances do: [:each | each migrateToUnicode]"
	title notNil ifTrue: [title := title ensureUnicodeSloveneChars].
	firstName notNil ifTrue: [firstName := firstName ensureUnicodeSloveneChars].
	middleName notNil ifTrue: [middleName := middleName ensureUnicodeSloveneChars].
	lastName notNil ifTrue: [lastName := lastName ensureUnicodeSloveneChars].
	company notNil ifTrue: [company := company ensureUnicodeSloveneChars].
	street notNil ifTrue: [street := street ensureUnicodeSloveneChars].
	city notNil ifTrue: [city := city ensureUnicodeSloveneChars].
	country notNil ifTrue: [country := country ensureUnicodeSloveneChars].! !

!Address methodsFor: 'accessing' stamp: 'janko 4/20/2012 17:10'!
mobile
	^self phones size > 1 
		ifTrue: [self phones at: 2]
		ifFalse: ['']! !

!Address methodsFor: 'accessing' stamp: 'janko 4/20/2012 17:11'!
mobile: aString
	self phones size > 1 ifTrue: [^self phones at: 2 put: aString].
	self phones size = 0 ifTrue: [self phones add: ''].
	^self phones add: aString! !

!Address methodsFor: 'accessing' stamp: 'janko 4/20/2012 17:11'!
phone
	^self phones size > 0 
		ifTrue: [self phones first]
		ifFalse: ['']! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
phone: aString
	self phones size > 0 ifTrue: [^self phones at: 1 put: aString].
	^self phones add: aString! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
phones
	phones isNil ifTrue: [self initPhones].
	^phones! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
post
	^self city! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
post: anObject
	self city: anObject! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
postalCode
	postalCode isNil ifTrue: [^''].
	^postalCode! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
postalCode: aString
	postalCode := aString.! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
stateProvince
	stateProvince isNil ifTrue: [^''].
	^stateProvince! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
stateProvince: aString
	stateProvince := aString.! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
street
	street isNil ifTrue: [^''].
	^street! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
street: aString
	street := aString.! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
title
	title isNil ifTrue: [^''].
	^title! !

!Address methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
title: aString
	title := aString.! !

!Address methodsFor: 'accessing'!
web
	"address of the website"
	web isNil ifTrue: [^''].
	^web! !

!Address methodsFor: 'accessing'!
web: aString
	"address of the website"
	web := aString! !

!Address class methodsFor: 'odb specific' stamp: ' 10/1/08 16:40'!
replicationSpec
	"Gemstone"

	^super replicationSpec, 
		#(	(firstName replicate)
			(lastName replicate)
			(company replicate)
			(street replicate)
			(city replicate)
			(postalCode replicate)
			(country replicate)
			(phones max 4)
			(emails max 4)
		 )! !

!AdvancedSearch methodsFor: 'private'!
alignCriteria: aCriteriaDict aspect: aSymbol with: anObject
	"adjust type of search field with those in object's aspect"
	| objValue |
	objValue := anObject perform: aSymbol.
	(objValue isKindOf: Number) ifTrue: 
		[aCriteriaDict at: aSymbol put: (aCriteriaDict at: aSymbol) asNumber]! !

!AdvancedSearch methodsFor: 'column mappings'!
alignFor: anAspectSymbol
	"column align for that field. nil if not defined"
	^(self colMapAt: anAspectSymbol ifAbsent: [^nil])
		at: 5! !

!AdvancedSearch methodsFor: 'accessing'!
allAspects
	"all aspects from colMap"
	^self colMap collect: [:map | map first]! !

!AdvancedSearch methodsFor: 'search form'!
allFieldsTo: anElement
	"build a search form for all aspects (accessors) of searched objects"
	^self fields: self allAspects to: anElement! !

!AdvancedSearch methodsFor: 'accessing'!
aspects
	"all search aspects, with criteria set or not"
	^self criteria keys! !

!AdvancedSearch methodsFor: 'accessing'!
clear
	"clear all search fields"
	self criteria keysAndValuesDo: [:key :value | self criteria at: key put: ''].! !

!AdvancedSearch methodsFor: 'column mappings'!
colAligns
	"for auto columns in search results"
	^self colAlignsWithout: #()! !

!AdvancedSearch methodsFor: 'column mappings'!
colAlignsWithout: anArrayOfAspects
	"for auto columns in search results"
	| collection |
	collection := OrderedCollection new.
	(self colAspectsWithout: anArrayOfAspects) do: [:aspect || map |
		map := self colMapAt: aspect ifAbsent: [nil].
		collection add: (map notNil ifTrue: [map at: 5 "align" ifAbsent: [nil]]) ].
	^collection! !

!AdvancedSearch methodsFor: 'column mappings'!
colAspects
	"for auto columns in search results"
	| aspects sorted |
	aspects := self searchedAspects asSet.
	sorted := OrderedCollection new.
	self colMap do: [:map | (aspects includes: map first) ifTrue: [sorted add: map first]]. "sort by order in colMap"
	^sorted! !

!AdvancedSearch methodsFor: 'column mappings'!
colAspectsWithout: anArrayOfAspects
	"for auto columns in search results"
	^self colAspects select: [:each | (anArrayOfAspects includes: each) not]! !

!AdvancedSearch methodsFor: 'column mappings'!
colFilters
	"for auto columns in search results"
	^self colFiltersWithout: #()! !

!AdvancedSearch methodsFor: 'column mappings'!
colFiltersWithout: anArrayOfAspects
	"for auto columns in search results"
	| collection |
	collection := OrderedCollection new.
	(self colAspectsWithout: anArrayOfAspects) do: [:aspect || map |
		map := self colMapAt: aspect ifAbsent: [nil].
		collection add: (map notNil ifTrue: [map at: 4 "filter" ifAbsent: [nil]]) ].
	^collection! !

!AdvancedSearch methodsFor: 'column mappings'!
colMap
	"map of columns in results table, used also for search form"
	"#( (aspect,  title, size, filter align) (...) )"
	^colMap! !

!AdvancedSearch methodsFor: 'private'!
colMap: anArrayOfSymbols
	colMap := anArrayOfSymbols! !

!AdvancedSearch methodsFor: 'private'!
colMapAt: anAspect ifAbsent: aBlock
	^self colMap detect: [:each | each first = anAspect] ifNone: aBlock! !

!AdvancedSearch methodsFor: 'column mappings'!
colNames
	"for auto columns in search results"
	^self colNamesWithout: #()! !

!AdvancedSearch methodsFor: 'column mappings'!
colNamesWithout: anArrayOfAspects
	"for auto columns in search results"
	| collection |
	collection := OrderedCollection new.
	(self colAspectsWithout: anArrayOfAspects) do: [:aspect || map |
		map := self colMapAt: aspect ifAbsent: [nil].
		collection add: (map notNil ifTrue: [map at: 2 "title" ifAbsent: [nil]]) ].
	^collection! !

!AdvancedSearch methodsFor: 'private'!
criteria
	criteria isNil ifTrue: [self initCriteria].
	^criteria! !

!AdvancedSearch methodsFor: 'private'!
doesNotUnderstand: aMessage
	| aspect |
	aspect := (aMessage selector asString copyUpTo: $: ) asSymbol.
	(self criteria includesKey: aspect) ifFalse: [self criteria at: aspect put: ''].
	aMessage arguments notEmpty ifTrue: "mutator"
		[self criteria at: aspect put: aMessage arguments first].
	^self criteria at: aspect! !

!AdvancedSearch methodsFor: 'search form'!
fields: anArrayOfAspects to: anElement
	"build a search form for defined aspects (accessors) of searched objects"
	anArrayOfAspects do: [:aspect || name size |
		name := self nameFor: aspect.
		name last ~= $: ifTrue: [name := name, ':'].
		anElement cell addText: name.
		size := (self sizeFor: aspect) notNil ifTrue: [self sizeFor: aspect] ifFalse: [8].
		anElement newCell addInputFieldAspect: aspect for: self size: size.
		aspect ~= anArrayOfAspects last 
			ifTrue: [anElement newRow] ].! !

!AdvancedSearch methodsFor: 'column mappings'!
filterFor: anAspectSymbol
	"column filter yes/no/size for that field"
	^(self colMapAt: anAspectSymbol ifAbsent: [^nil])
		at: 4! !

!AdvancedSearch methodsFor: 'initialize-release'!
initCriteria
	criteria := Dictionary new.! !

!AdvancedSearch methodsFor: 'initialize-release'!
initResults
	results := OrderedCollection new.! !

!AdvancedSearch methodsFor: 'private'!
isExactMatchRequested: aString
	" if string is in quotation "
	aString isEmpty ifTrue: [^false].
	^aString trimBlanks first = $" and: [aString trimBlanks last = $" ]! !

!AdvancedSearch methodsFor: 'column mappings'!
nameFor: anAspectSymbol
	"column name/title for that field"
	^(self colMapAt: anAspectSymbol ifAbsent: [^nil])
		at: 2! !

!AdvancedSearch methodsFor: 'private'!
object: anObject match: aCriteria
	| objValue |
	aCriteria associationsDo: [:assoc | 
		(anObject class canUnderstand: assoc key) ifTrue:
			[objValue := anObject perform: assoc key.
			(objValue isKindOf: String) 
				ifTrue: 
					[(assoc value match: objValue) ifFalse: [^false] ] 
				ifFalse:  "numbers, dates etc."
					["self alignCriteria: aCriteria aspect: assoc key with: anObject."
					(assoc value match: objValue printString) ifFalse: [^false] ] ] ].
	^true! !

!AdvancedSearch methodsFor: 'private'!
preparedCriteria
	"just search fields, which are not empty"
	| dict |
	dict := Dictionary new.
	self criteria keysAndValuesDo: 
		[:key :value | 
			value trimBlanks notEmpty ifTrue:
				[(self isExactMatchRequested: value)
					ifTrue: [dict at: key put: (self withoutQuotation: value trimBlanks)]
					ifFalse: [dict at: key put: (value, '*')] ] ].
	^dict! !

!AdvancedSearch methodsFor: 'search'!
results
	results isNil ifTrue: [self initResults].
	^results! !

!AdvancedSearch methodsFor: 'search'!
searchFrom: aCollection
	| preparedCriteria |
	preparedCriteria := self preparedCriteria.
	results := aCollection select: [:each | self object: each match: preparedCriteria].
	^self results! !

!AdvancedSearch methodsFor: 'accessing'!
searchedAspects
	"aspect symbols, which have a search criteria set"
	^self preparedCriteria keys! !

!AdvancedSearch methodsFor: 'column mappings'!
sizeFor: anAspectSymbol
	"size for that field"
	^(self colMapAt: anAspectSymbol ifAbsent: [^nil])
		at: 3! !

!AdvancedSearch methodsFor: 'private'!
withoutQuotation: aString
	^aString copyFrom: 2 to: aString size -1! !

!AidaModelAdaptor methodsFor: 'accessing'!
aspect

	^aspect! !

!AidaModelAdaptor methodsFor: 'private'!
aspect: aSymbol

	aspect := aSymbol! !

!AidaModelAdaptor methodsFor: 'private'!
buffer
	"a buffered value before saved to the domain object"
	"an already converted value before it is saved to the domain object"
	^buffer! !

!AidaModelAdaptor methodsFor: 'private'!
buffer: aValue
	"an already converted value before it is saved to the domain object"
	buffer := aValue! !

!AidaModelAdaptor methodsFor: 'accessing'!
changed
	"is value changed?"
	changed ifNil: [self resetChanged].
	^changed! !

!AidaModelAdaptor methodsFor: 'accessing'!
convertedAndEncodedValue
	self format = #iso ifTrue: 	"Date should be ISO formated: yyyy-mm-dd"
		[^self value year printString, '-', 
			(self value monthIndex < 10 ifTrue: ['0'] ifFalse: ['']), self value monthIndex printString, '-',
			(self value dayOfMonth < 10 ifTrue: ['0'] ifFalse: ['']), self value dayOfMonth printString].
	^self value! !

!AidaModelAdaptor methodsFor: 'accessing'!
format
	"format of the value. Depends of value type. If nil, autoformating is used"
	"For Date can be #iso #sloDate #shortSloDate"
	^format! !

!AidaModelAdaptor methodsFor: 'accessing'!
format: aSymbol
	"format of the value. Depends of value type. If nil, autoformating is used"
	"For Date can be #iso #sloDate #shortSloDate"
	format := aSymbol! !

!AidaModelAdaptor methodsFor: 'accessing'!
index

	^index! !

!AidaModelAdaptor methodsFor: 'private'!
index: aNumber
	index := aNumber! !

!AidaModelAdaptor methodsFor: 'initialize-release'!
initDefaultValidationBlock
	self validationBlock: [:value | true ] "just validate it"! !

!AidaModelAdaptor methodsFor: 'testing'!
isAspectAdaptor
	^self aspect notNil! !

!AidaModelAdaptor methodsFor: 'testing'!
isEmpty
	"nothing entered in this field"
	^self buffer isNil or: [self buffer trimBlanks isEmpty]! !

!AidaModelAdaptor methodsFor: 'testing'!
isIndexAdaptor
	^self index notNil! !

!AidaModelAdaptor methodsFor: 'validation'!
isValid
	"bufered value is valid according to the rule in validationBlock"
	self changed ifFalse: [^true]. "value not changed, nothing to validate!!"
	self validationBlock isNil ifTrue: [^true]. "leave this instvar nil until really needed, to avoid garbage"
	^self validationBlock value: self buffer! !

!AidaModelAdaptor methodsFor: 'private'!
resetChanged
	changed := false! !

!AidaModelAdaptor methodsFor: 'private'!
sanitize
	"sanitize input from <script> and similar input to prevent entering XSS and similar malicious code"
	| in out |
	in := ReadStream on: self buffer.
	out := WriteStream on: String new.
	[in atEnd] whileFalse:
		[in peek = $< 
			ifTrue: [out nextPutAll: (self sanitizeTagFrom: in)]
			ifFalse: [out nextPut: in next] ].
	self buffer: out contents! !

!AidaModelAdaptor methodsFor: 'private'!
sanitizeTagFrom: aStream
	"sanitize tag by just skipping 'script' if found "
	| out inx|
	out := WriteStream on: String new.
	[aStream atEnd or: [aStream peek = $> ]] whileFalse:
		[out nextPut: aStream next.
		aStream peek = $< ifTrue: [out nextPutAll: (self sanitizeTagFrom: aStream)]]. "deal with tags within tags"
	aStream peek = $> ifTrue: [out nextPut: aStream next].
	^('*script*' match: out contents)
		ifTrue: 
			[inx := out contents asLowercase indexOfSubCollection: 'script' startingAt: 1.
			(out contents copyFrom: 1 to: inx-1), (out contents copyFrom: inx+6 to: out contents size)]
		ifFalse: [out contents].! !

!AidaModelAdaptor methodsFor: 'saving'!
save
	"save the value to the domain model. Save only if validated, othewise raise an exception"
	self changed ifFalse: [^nil].
	self isValid ifFalse: [self error: 'value validation failed!!'].
	self saveValue: self buffer.
	self resetChanged.
	self buffer: nil! !

!AidaModelAdaptor methodsFor: 'private'!
saveValue: aValue
	self isAspectAdaptor ifTrue: [self subject perform: (self aspect asString, ':') asSymbol with: aValue].
	self isIndexAdaptor ifTrue: [self subject at: self index put: aValue]! !

!AidaModelAdaptor methodsFor: 'private'!
setChanged
	changed := true! !

!AidaModelAdaptor methodsFor: 'accessing'!
subject
	"subject of adapting, a domain object"
	^subject! !

!AidaModelAdaptor methodsFor: 'private'!
subject: anObject
	"subject of adapting, a domain object"
	subject := anObject! !

!AidaModelAdaptor methodsFor: 'validation'!
validationBlock
	"block must return true to validate a value, which is argument of that block"
	"example block: [:value | value class = Date ] "
"	validationBlock isNil ifTrue: [self initDefaultValidationBlock]. " "leave nil to avoid unecessary garbage"
	^validationBlock! !

!AidaModelAdaptor methodsFor: 'validation'!
validationBlock: aBlock
	"block must return true to validate a value, which is argument of that block"
	"example block: [:value | value class = Date ] "
	validationBlock := aBlock! !

!AidaModelAdaptor methodsFor: 'accessing'!
value
	self isAspectAdaptor ifTrue: [^self subject perform: self aspect].
	self isIndexAdaptor ifTrue: [^self subject at: self index]! !

!AidaModelAdaptor methodsFor: 'accessing'!
value: aValue
	"value is first put in buffer. To the domain model is written with #save, but only if 
	pass the validation with #isValid"
	self buffer: aValue.
	self setChanged! !

!AidaModelAdaptor class methodsFor: 'instance creation'!
forAspect: aSymbol
	^super new aspect: aSymbol! !

!AidaModelAdaptor class methodsFor: 'instance creation'!
forIndex: aNumber
	^super new index: aNumber! !

!AidaModelNullAdaptor methodsFor: 'validation'!
isValid
	^true! !

!AidaModelNullAdaptor methodsFor: 'saving'!
save
	"nothing to save here"! !

!AidaModelNullAdaptor methodsFor: 'accessing'!
value
	^value notNil ifTrue: [value] ifFalse: ['']! !

!AidaModelNullAdaptor methodsFor: 'accessing'!
value: aString
	value := aString! !

!AidaMutex methodsFor: 'critical sections'!
critical: aBlock
	| process |
	process := Processor activeProcess.
	^ (owner == process)
		ifTrue: [ aBlock value ]
		ifFalse: [
			semaphore critical: [
				owner := process.
				aBlock ensure: [ owner := nil ] ] ]! !

!AidaMutex methodsFor: 'initialize-release'!
initialize
	super initialize.
	semaphore := Semaphore forMutualExclusion! !

!AidaMutex methodsFor: 'accessing'!
owner
	^ owner! !

!AidaMutex methodsFor: 'critical sections'!
terminateOwner
	owner notNil ifTrue: [owner terminate]! !

!AidaMutex class methodsFor: 'instance creation'!
new
	^super basicNew
		initialize! !

!AidaProfiling methodsFor: 'profiling-gs'!
areadmeGemstone
	"a short description of how to profile, interpret results, why to profile etc."! !

!AidaProfiling methodsFor: 'profiling-gs'!
areadmeResultsGS
	"results, history of, short explanations"

"Gemstone64 2.2.5 Profiling of Aida/Web 5.6, 11.2.08, Janko Mivsek
[1000 timesRepeat: [site answerTo: req]]

elapsed CPU time:    23662 ms,  monitoring interval: 10 ms
24ms/req, 40 req/s"! !

!AidaProfiling methodsFor: 'profiling-vw'!
areadmeResultsVW
	"results, history of, short explanations"

"VW 7.6 Profiling of Aida/Web 5.6, 11.2.08, Janko Mivsek
[1000 timesRepeat: [site answerTo: req]]

707 samples, 20.03 average ms/sample, 1780 scavenges, 28 incGCs,
11.75s active, 2.35s other processes,
14.16s real time, 0.06s profiling overhead
12ms/req, 83 req/s"! !

!AidaProfiling methodsFor: 'profiling-squeak'!
areadmeSqueak
	"a short description of how to profile, interpret results, why to profile etc."! !

!AidaProfiling methodsFor: 'profiling-vw'!
areadmeVW
	"a short description of how to profile, interpret results, why to profile etc."! !

!AidaProfiling methodsFor: 'support'!
ensure100KBFile
	"dummy .jpg file"
	| fname stream |
	fname := SpFilename named: 'test100K.jpg'.
	fname exists ifFalse:
		[[stream := fname writeStream binary.
		100000 timesRepeat: [stream nextPut: 16rCE] "just something"]
			ensure: [stream close] ].! !

!AidaProfiling methodsFor: 'support'!
pingRequest
	| requestStream req |
	requestStream := SwazooStream on: String new.
	requestStream
		nextPutLine: 'GET /ping.html HTTP/1.1';
		crlf.
	req := HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents).
	req task: SwazooTask new.  req task request: req.
	req task connection: (HTTPConnection new stream: (SwazooStream on: String new)).
	^req! !

!AidaProfiling methodsFor: 'profiling-gs'!
profileAnswerToGS
	"AIDASite>>answerTo: profile"
	"AidaProfiling new profileAnswerToVW"

	| site  req |
	site := AIDASite new initialize.
	req := self sampleRequest.
	site answerTo: req. site answerTo: req.
	Smalltalk.ProfMonitor monitorBlock: 
		[1000 timesRepeat: [site answerTo: req]]! !

!AidaProfiling methodsFor: 'profiling-vw'!
profileAnswerToVW
	"AIDASite>>answerTo: profile"
	"AidaProfiling new profileAnswerToVW"
	| site req resp |
	site := AIDASite new initialize. site admin. "to init its URL"
	req := self sampleRequest.  "/admin?view=login  with cookie set"
	resp := site answerTo: req. 
	TimeProfiler new 
		samplingInterval: 10; 
		profile: [1000 timesRepeat: [site answerTo: req]].
	^resp "to check if it is actually as expected"! !

!AidaProfiling methodsFor: 'profiling-vw'!
profilePingToVW
	"AIDASite>>answerTo: profile"
	"AidaProfiling new profilePingToVW"
	| site req resp |
	site := AIDASite new initialize.
	req := self pingRequest.  "/ping.html"
	resp := site answerTo: req. 
	TimeProfiler new 
		samplingInterval: 10; 
		profile: [10000000 timesRepeat: [site answerTo: req]].
	^resp "to check if it is actually as expected"! !

!AidaProfiling methodsFor: 'profiling-vw'!
profileStatic100KBVW
	"static 100KB file serving"
	"AidaProfiling new profileStatic100KBVW"
	| site req resp |
	self ensure100KBFile.
	site := AIDASite new initialize.
	req := self static100KBRequest.  "/test100K.jpg?id=123456"
	resp := site answerTo: req. req task response: nil. "streaming!!"
	TimeProfiler new 
		samplingInterval: 10; 
		profile: [1 timesRepeat: [site answerTo: req.  req task response: nil] ].
	^resp "to check if it is actually as expected"! !

!AidaProfiling methodsFor: 'support'!
sampleRequest
	| requestStream req |
	requestStream := SwazooStream on: String new.
	requestStream
		nextPutLine: 'GET /admin?view=login HTTP/1.1';
		nextPutLine: 'Cookie: aida9357=123456';
		crlf.
	req := HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents).
	req task: SwazooTask new.  req task request: req.
	req task connection: (HTTPConnection new stream: (SwazooStream on: String new)).
	^req! !

!AidaProfiling methodsFor: 'support'!
static100KBRequest
	| requestStream req |
	requestStream := SwazooStream on: String new.
	requestStream
		nextPutLine: 'GET /test100K.jpg HTTP/1.1';
		crlf;
		nextPutLine: 'Cookie: aida9357=123456';
		crlf.
	req := HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents).
	req task: SwazooTask new.  req task request: req.
	req task connection: (HTTPConnection new stream: (SwazooStream on: String new)).
	^req! !

!Association methodsFor: '*Aida' stamp: 'np 3/25/2009 15:36'!
aidaIsAssociation
	"used for Aida/Web translation support, multilingual strings are namelly assocs: #fr->'Bonjour'"
	^true! !

!BlockClosure methodsFor: '*Aida' stamp: 'np 10/17/2008 17:46'!
aidaDeepCopyNotIn: aDict
	^nil! !

!BmpImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
colorValueFrom: rgbInteger 
	| scalingValue |
	scalingValue := ColorValue scalingValue.
	^ColorValue
		scaledRed: (self
				convertValue: ((rgbInteger bitShift: -16)
						bitAnd: 255)
				from: 255
				to: scalingValue)
		scaledGreen: (self
				convertValue: ((rgbInteger bitShift: -8)
						bitAnd: 255)
				from: 255
				to: scalingValue)
		scaledBlue: (self
				convertValue: (rgbInteger bitAnd: 255)
				from: 255
				to: scalingValue)! !

!BmpImageStream methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nextImage
	self readBitmapFileHeader.
	self readBitmapInfoHeader.
	self readImagePalette.
	self readImageData.
	^imageObject! !

!BmpImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextLSBLong
	^self next + (self next bitShift: 8) + (self next bitShift: 16) + (self next bitShift: 24)! !

!BmpImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextLSBLongPut: a32BitW 
	self nextPut: (a32BitW bitAnd: 255).
	self nextPut: ((a32BitW bitShift: -8)
			bitAnd: 255).
	self nextPut: ((a32BitW bitShift: -16)
			bitAnd: 255).
	self nextPut: ((a32BitW bitShift: -24)
			bitAnd: 255)! !

!BmpImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextLSBWord
	^self next + (self next bitShift: 8)! !

!BmpImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextLSBWordPut: a16BitW 
	self nextPut: (a16BitW bitAnd: 255).
	self nextPut: ((a16BitW bitShift: -8)
			bitAnd: 255)! !

!BmpImageStream methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nextPutImage: anImage 
	(anImage isKindOf: Image)
		ifFalse: [^self errorCanNotWrite].
	(anImage bitsPerPixel = 8 or: [anImage bitsPerPixel = 24])
		ifTrue: [imageObject := anImage]
		ifFalse: [anImage bitsPerPixel > 8
				ifTrue: [imageObject := anImage convertToPalette: (FixedPalette
									redShift: 16
									redMask: 255
									greenShift: 8
									greenMask: 255
									blueShift: 0
									blueMask: 255)]
				ifFalse: [Cursor wait showWhile: [imageObject := anImage convertToPalette: self class colorPalette256 renderedBy: ErrorDiffusion new]]].
	self writeBitmapFileHeader.
	self writeBitmapInfoHeader.
	self writeImagePalette.
	self writeImageData.
	bfSize := self position.
	^anImage! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readBitmapFileHeader
	| position |
	position := self position.
	(self hasMagicNumber: 'BM' asByteArray)
		ifFalse: [^self errorCanNotRead].
	self position: position.
	bfType := self nextWord.
	bfSize := self nextLSBLong.
	bfReserved1 := self nextLSBWord.
	bfReserved2 := self nextLSBWord.
	bfOffBits := self nextLSBLong! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readBitmapInfoHeader
	biSize := self nextLSBLong.
	biWidth := self nextLSBLong.
	biHeight := self nextLSBLong.
	biPlanes := self nextLSBWord.
	biBitCount := self nextLSBWord.
	biCompression := self nextLSBLong.
	biSizeImage := self nextLSBLong.
	biXPelsPerMeter := self nextLSBLong.
	biYPelsPerMeter := self nextLSBLong.
	biClrUsed := self nextLSBLong.
	biClrImportant := self nextLSBLong! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readDepth1Data
	| image total progress count index |
	self position: bfOffBits.
	image := Image
				extent: biWidth @ biHeight
				depth: biBitCount
				palette: imagePalette.
	total := biWidth * biHeight.
	progress := 0.
	self progress: progress / total.
	biHeight - 1
		to: 0
		by: -1
		do: 
			[:y | 
			count := 128.
			0 to: biWidth - 1
				do: 
					[:x | 
					count = 128 ifTrue: [index := self next].
					image
						atX: x
						y: y
						put: (index bitAnd: count).
					count := count / 2.
					count < 1 ifTrue: [count := 128].
					progress := progress + 1.
					self progress: progress / total]].
	^image! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readDepth1Palette
	^MappedPalette blackWhite! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readDepth24Data
	| image total progress count rgb color index |
	self position: bfOffBits.
	image := Image
				extent: biWidth @ biHeight
				depth: biBitCount
				palette: imagePalette.
	total := biWidth * biHeight.
	progress := 0.
	self progress: progress / total.
	biHeight - 1
		to: 0
		by: -1
		do: 
			[:y | 
			count := 0.
			0 to: biWidth - 1
				do: 
					[:x | 
					rgb := self next + (self next bitShift: 8) + (self next bitShift: 16).
					color := self colorValueFrom: rgb.
					index := image palette indexOfPaintNearest: color.
					image
						atX: x
						y: y
						put: index.
					count := count + 3.
					progress := progress + 1.
					self progress: progress / total].
			[count \\ 4 = 0]
				whileFalse: 
					[self next.
					count := count + 1]].
	^image! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readDepth24Palette
	^FixedPalette
		redShift: 16
		redMask: 255
		greenShift: 8
		greenMask: 255
		blueShift: 0
		blueMask: 255! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readDepth8Data
	| image total progress count index |
	self position: bfOffBits.
	image := Image
				extent: biWidth @ biHeight
				depth: biBitCount
				palette: imagePalette.
	total := biWidth * biHeight.
	progress := 0.
	self progress: progress / total.
	biHeight - 1
		to: 0
		by: -1
		do: 
			[:y | 
			count := 0.
			0 to: biWidth - 1
				do: 
					[:x | 
					index := self next.
					image
						atX: x
						y: y
						put: index.
					count := count + 1.
					progress := progress + 1.
					self progress: progress / total].
			[count \\ 4 = 0]
				whileFalse: 
					[self next.
					count := count + 1]].
	^image! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readDepth8Palette
	| size colors rgb color |
	size := 1 bitShift: biBitCount.
	biClrUsed = 0 ifFalse: [size := biClrUsed].
	colors := Array new: size.
	1 to: size
		do: 
			[:index | 
			rgb := self next + (self next bitShift: 8) + (self next bitShift: 16).
			self next.
			color := self colorValueFrom: rgb.
			colors at: index put: color].
	^MappedPalette withColors: colors! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readImageData
	biCompression = 0 ifFalse: [^self errorCanNotRead].
	imageObject := nil.
	biBitCount = 24 ifTrue: [imageObject := self readDepth24Data].
	biBitCount = 8 ifTrue: [imageObject := self readDepth8Data].
	biBitCount = 1 ifTrue: [imageObject := self readDepth1Data].
	imageObject isNil ifTrue: [^self errorCanNotRead].
	^imageObject! !

!BmpImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readImagePalette
	imagePalette := nil.
	biBitCount = 24 ifTrue: [imagePalette := self readDepth24Palette].
	biBitCount = 8 ifTrue: [imagePalette := self readDepth8Palette].
	biBitCount = 1 ifTrue: [imagePalette := self readDepth1Palette].
	imagePalette isNil ifTrue: [^self errorCanNotRead]! !

!BmpImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
rgbIntegerArrayFor: aPalette 
	| colors |
	colors := Array new: aPalette maxIndex + 1.
	1 to: colors size do: [:i | colors at: i put: (self rgbIntegerFrom: (aPalette at: i - 1 ifAbsent: [ColorValue white]))].
	^colors! !

!BmpImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
rgbIntegerFrom: aColorValue 
	| scalingValue |
	scalingValue := ColorValue scalingValue.
	^((self
		convertValue: aColorValue scaledRed
		from: scalingValue
		to: 255)
		bitShift: 16)
		+ ((self
				convertValue: aColorValue scaledGreen
				from: scalingValue
				to: 255)
				bitShift: 8) + (self
			convertValue: aColorValue scaledBlue
			from: scalingValue
			to: 255)! !

!BmpImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeBitmapFileHeader
	bfType := ($B asInteger bitShift: 8)
				+ $M asInteger.
	bfSize := 0.
	bfReserved1 := 0.
	bfReserved2 := 0.
	bfOffBits := nil.
	imageObject bitsPerPixel = 8 ifTrue: [bfOffBits := 54 + (imageObject palette size * 4)].
	imageObject bitsPerPixel = 24 ifTrue: [bfOffBits := 54].
	bfOffBits isNil ifTrue: [^self errorCanNotWrite].
	self nextWordPut: bfType.
	self nextLSBLongPut: bfSize.
	self nextLSBWordPut: bfReserved1.
	self nextLSBWordPut: bfReserved2.
	self nextLSBLongPut: bfOffBits! !

!BmpImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeBitmapInfoHeader
	biSize := 40.
	biWidth := imageObject width.
	biHeight := imageObject height.
	biPlanes := 1.
	biBitCount := imageObject bitsPerPixel.
	biCompression := 0.
	biSizeImage := 0.
	biXPelsPerMeter := 0.
	biYPelsPerMeter := 0.
	biClrUsed := 0.
	imageObject bitsPerPixel = 8 ifTrue: [biClrUsed := (imageObject palette size)].
	biClrImportant := 0.
	self nextLSBLongPut: biSize.
	self nextLSBLongPut: biWidth.
	self nextLSBLongPut: biHeight.
	self nextLSBWordPut: biPlanes.
	self nextLSBWordPut: biBitCount.
	self nextLSBLongPut: biCompression.
	self nextLSBLongPut: biSizeImage.
	self nextLSBLongPut: biXPelsPerMeter.
	self nextLSBLongPut: biYPelsPerMeter.
	self nextLSBLongPut: biClrUsed.
	self nextLSBLongPut: biClrImportant! !

!BmpImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeDepth24Data
	| total progress count index color rgb |
	self position = bfOffBits ifFalse: [^self errorCanNotWrite].
	total := biWidth * biHeight.
	progress := 0.
	self progress: progress / total.
	biHeight - 1
		to: 0
		by: -1
		do: 
			[:y | 
			count := 0.
			0 to: biWidth - 1
				do: 
					[:x | 
					index := imageObject atX: x y: y.
					color := imageObject palette at: index.
					rgb := self rgbIntegerFrom: color.
					self nextPut: (rgb bitAnd: 255).
					self nextPut: ((rgb bitShift: -8)
							bitAnd: 255).
					self nextPut: ((rgb bitShift: -16)
							bitAnd: 255).
					count := count + 3.
					progress := progress + 1.
					self progress: progress / total].
			[count \\ 4 = 0]
				whileFalse: 
					[self nextPut: 0.
					count := count + 1]].
	^imageObject! !

!BmpImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeDepth24Palette
	^imageObject palette! !

!BmpImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeDepth8Data
	| count index |
	self position = bfOffBits ifFalse: [^self errorCanNotWrite].
"
	total := biWidth * biHeight.
	progress := 0.
	self progress: progress / total. 
"
	biHeight - 1
		to: 0
		by: -1
		do: 
			[:y | 
			count := 0.
			0 to: biWidth - 1
				do: 
					[:x | 
					index := imageObject atX: x y: y.
					self nextPut: index.
					count := count + 1.
"					progress := progress + 1.
					self progress: progress / total
"
					].
			[count \\ 4 = 0]
				whileFalse: 
					[self nextPut: 0.
					count := count + 1]].
	^imageObject! !

!BmpImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeDepth8Palette
	| size palette array |
	size := 1 bitShift: biBitCount.
	palette := imageObject palette.
	palette size = size ifFalse: [self errorCanNotWrite].
	array := self rgbIntegerArrayFor: palette.
	array
		do: 
			[:rgb | 
			self nextPut: (rgb bitAnd: 255).
			self nextPut: ((rgb bitShift: -8)
					bitAnd: 255).
			self nextPut: ((rgb bitShift: -16)
					bitAnd: 255).
			self nextPut: 0].
	^imageObject palette! !

!BmpImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeImageData
	biCompression = 0 ifFalse: [^self errorCanNotWrite].
	biBitCount = 24 ifTrue: [^self writeDepth24Data].
	biBitCount = 8 ifTrue: [^self writeDepth8Data].
	^self errorCanNotWrite! !

!BmpImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeImagePalette
	imagePalette := nil.
	biBitCount = 24 ifTrue: [imagePalette := self writeDepth24Palette].
	biBitCount = 8 ifTrue: [imagePalette := self writeDepth8Palette].
	imagePalette isNil ifTrue: [^self errorCanNotWrite]! !

!BmpImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
copyright
	^'Copyright (C) 1995-1998 AOKI Atsushi, All Rights Reserved.'! !

!BmpImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example1
	"BmpImageStream example1."

	| image filename stream |
	image := Image fromUser.
	filename := 'zzz.bmp' asFilename.
	stream := BmpImageStream on: filename writeStream.
	[Cursor write showWhile: [stream nextPutImage: image]]
		valueNowOrOnUnwindDo: [stream close].
	^image! !

!BmpImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example2
	"BmpImageStream example2."

	| filename stream image |
	filename := 'zzz.bmp' asFilename.
	stream := BmpImageStream on: filename readStream.
	[Cursor read showWhile: [image := stream nextImage]]
		valueNowOrOnUnwindDo: [stream close].
	stream show: image.
	^image! !

!BmpImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example3
	"BmpImageStream example3."

	| image filename stream |
	image := Image fromUser.
	filename := 'zzz.bmp' asFilename.
	stream := BmpImageStream on: filename writeStream.
	[Cursor write
		showWhile: 
			[stream compute: [:value | Transcript cr; show: value printString].
			stream nextPutImage: image]]
		valueNowOrOnUnwindDo: [stream close].
	^image! !

!BmpImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example4
	"BmpImageStream example4."

	| filename stream image |
	filename := 'zzz.bmp' asFilename.
	stream := BmpImageStream on: filename readStream.
	[Cursor read
		showWhile: 
			[stream compute: [:value | Transcript cr; show: value printString].
			image := stream nextImage]]
		valueNowOrOnUnwindDo: [stream close].
	stream show: image.
	^image! !

!BmpImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example5
	"BmpImageStream example5."

	| image filename stream progress |
	image := Image fromUser.
	filename := 'zzz.bmp' asFilename.
	stream := BmpImageStream on: filename writeStream.
	[Cursor write
		showWhile: 
			[progress := Progress new.
			stream compute: [:value | progress value: value].
			progress message: 'writing bmp...'.
			progress do: [stream nextPutImage: image]]]
		valueNowOrOnUnwindDo: [stream close].
	^image! !

!BmpImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example6
	"BmpImageStream example6."

	| filename stream progress image |
	filename := 'zzz.bmp' asFilename.
	stream := BmpImageStream on: filename readStream.
	[Cursor read
		showWhile: 
			[progress := Progress new.
			stream compute: [:value | progress value: value].
			progress message: 'reading bmp...'.
			progress do: [image := stream nextImage]]]
		valueNowOrOnUnwindDo: [stream close].
	stream show: image.
	^image! !

!BmpImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
system
	^'Goodies'! !

!BmpImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
version
	^'003'! !

!BosImageStream methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nextImage
	| size process bos image |
	self readHeader isNil ifTrue: [^nil].
	size := imageStream size max: 1.0e-6.
	process := [[imageStream position < size]
				whileTrue: 
					[self progress: imageStream position / size.
					(Delay forMilliseconds: 3) wait]] newProcess.
	process priority: Processor activeProcess priority + 5.
	process resume.
	
	[bos := BinaryObjectStorage onOldNoScan: imageStream.
	self progress: 0.
	image := bos next.
	self progress: 1]
		valueNowOrOnUnwindDo: 
			[process terminate.
			process := nil].
	^image! !

!BosImageStream methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nextPutImage: anImage 
	| size process bos bytes |
	(anImage isKindOf: Image) not ifTrue: [^self errorCanNotWrite].
	self writeHeader.
	bytes := WriteStream on: (bytes := ByteArray new: 1024).
	self size timesRepeat: [bytes nextPut: 0].
	bos := BinaryObjectStorage onNew: bytes.
	bos nextPut: anImage asImage.
	size := bytes contents size max: 1.0e-6.
	process := [[imageStream position < size]
				whileTrue: 
					[self progress: imageStream position / size.
					(Delay forMilliseconds: 3) wait]] newProcess.
	process priority: Processor activeProcess priority + 5.
	process resume.
	
	[bos := BinaryObjectStorage onNew: imageStream.
	self progress: 0.
	bos nextPut: anImage asImage.
	self progress: 1]
		valueNowOrOnUnwindDo: 
			[process terminate.
			process := nil].
	^anImage! !

!BosImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readHeader
	(self hasMagicNumber: 'BosImage' asByteArray)
		ifFalse: [^self errorCanNotRead]! !

!BosImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeHeader
	self nextPutAll: 'BosImage' asByteArray.! !

!BosImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
copyright
	^'Copyright (C) 1995-1998 AOKI Atsushi, All Rights Reserved.'! !

!BosImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example1
	"BosImageStream example1."

	| image filename stream |
	image := Image fromUser.
	filename := 'zzz.bos' asFilename.
	stream := BosImageStream on: filename writeStream.
	[Cursor write showWhile: [stream nextPutImage: image]]
		valueNowOrOnUnwindDo: [stream close].
	^image! !

!BosImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example2
	"BosImageStream example2."

	| filename stream image |
	filename := 'zzz.bos' asFilename.
	stream := BosImageStream on: filename readStream.
	[Cursor read showWhile: [image := stream nextImage]]
		valueNowOrOnUnwindDo: [stream close].
	stream show: image.
	^image! !

!BosImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example3
	"BosImageStream example3."

	| image filename stream |
	image := Image fromUser.
	filename := 'zzz.bos' asFilename.
	stream := BosImageStream on: filename writeStream.
	[Cursor write
		showWhile: 
			[stream compute: [:value | Transcript cr; show: value printString].
			stream nextPutImage: image]]
		valueNowOrOnUnwindDo: [stream close].
	^image! !

!BosImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example4
	"BosImageStream example4."

	| filename stream image |
	filename := 'zzz.bos' asFilename.
	stream := BosImageStream on: filename readStream.
	[Cursor read
		showWhile: 
			[stream compute: [:value | Transcript cr; show: value printString].
			image := stream nextImage]]
		valueNowOrOnUnwindDo: [stream close].
	stream show: image.
	^image! !

!BosImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example5
	"BosImageStream example5."

	| image filename stream progress |
	image := Image fromUser.
	filename := 'zzz.bos' asFilename.
	stream := BosImageStream on: filename writeStream.
	[Cursor write
		showWhile: 
			[progress := Progress new.
			stream compute: [:value | progress value: value].
			progress message: 'writing bos...'.
			progress do: [stream nextPutImage: image]]]
		valueNowOrOnUnwindDo: [stream close].
	^image! !

!BosImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example6
	"BosImageStream example6."

	| filename stream image progress |
	filename := 'zzz.bos' asFilename.
	stream := BosImageStream on: filename readStream.
	[Cursor read
		showWhile: 
			[progress := Progress new.
			stream compute: [:value | progress value: value].
			progress message: 'reading bos...'.
			progress do: [image := stream nextImage]]]
		valueNowOrOnUnwindDo: [stream close].
	stream show: image.
	^image! !

!BosImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
system
	^'Goodies'! !

!BosImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
version
	^'003'! !

!Class methodsFor: '*Aida' stamp: 'np 10/17/2008 17:46'!
aidaDeepCopyNotIn: aDict
	^nil! !

!Collection methodsFor: '*Aida' stamp: 'janko 4/25/2012 10:58'!
aidaIsRespondingStreamed
	^false! !

!Collection methodsFor: '*Aida-Daily collections' stamp: 'JM 4/22/2007 19:04'!
allDailyCollectionDated: aDate
	"all on that date in any of daily collections"
	^self inject: OrderedCollection new into: [:col :each | col addAll: (each allDated: aDate). col]

"DailyCollection allInstances allDailyCollectionDated: 
		DailyCollection allInstances allDailyCollectionDates asOrderedCollection last."! !

!Collection methodsFor: '*Aida-Daily collections' stamp: 'JM 4/22/2007 19:05'!
allDailyCollectionDates
	"all dates which occur of any of daily collections"
	^self allDailyCollectionDays collect: [:each | Date fromDays: each].

"DailyCollection allInstances allDailyCollectionDates"! !

!Collection methodsFor: '*Aida-Daily collections' stamp: 'JM 4/22/2007 19:04'!
allDailyCollectionDays
	"all day numbers which occur of any of daily collections"
	^self inject: Set new into: [:set :each | set addAll: each allDays. set].

"DailyCollection allInstances allDailyCollectionDays"! !

!Collection methodsFor: '*Aida-Daily collections' stamp: 'JM 4/22/2007 19:05'!
allDailyCollectionEntries
	"sorted by date"
	| days |
	days := self allDailyCollectionDays.
	days := days asSortedCollection. 
	^days inject: OrderedCollection new into: [:col :day | 
		self do: [:daily | (daily days includesKey: day) ifTrue: [col addAll: (daily days at: day)] ].
		col].

"DailyCollection allInstances allDailyCollectionEntries"! !

!Collection methodsFor: '*Aida-Daily collections' stamp: 'JM 4/22/2007 19:05'!
allDailyCollectionFromDate: aStartDate to: anEndDate
	"sorted by date"
	| startDay endDay daysInRange |
	startDay := aStartDate asDays. endDay := anEndDate asDays.
	daysInRange := self allDailyCollectionDays select: [:each | each >= startDay and: [each <= endDay] ].
	daysInRange := daysInRange asSortedCollection. 
	^daysInRange inject: OrderedCollection new into: [:col :day | 
		self do: [:daily | (daily days includesKey: day) ifTrue: [col addAll: (daily days at: day)] ].
		col].

"DailyCollection allInstances allDailyCollectionFromDate: (Date readSloFrom: '1.1.2004' readStream) 
  	to: (Date readSloFrom: '31.12.2006' readStream)"! !

!Collection methodsFor: '*Aida-Daily collections'!
allDailyCollectionYear: aNumber
	| selected |
	selected := self select: [:each | each includesYear: aNumber].
	^selected
		allDailyCollectionFromDate: (Date newDay: 1 monthNumber: 1 year: aNumber)
		to: (Date newDay: 31 monthNumber: 12 year: aNumber)

"DailyCollection allInstances allDailyCollectionYear: 2004 "! !

!Collection methodsFor: '*Aida-Daily collections' stamp: 'JM 4/22/2007 19:05'!
allDailyCollectionYears
	"all years on which occur of anything of daily collections. Sorted!!"
	^SortedCollection 
		withAll: (self allDailyCollectionDates inject: Set new into: [:set :each | set add: each year. set])
		sortBlock: [:a :b | a < b].

"DailyCollection allInstances allDailyCollectionYears"! !

!Collection methodsFor: '*Aida-Daily collections' stamp: 'JM 4/22/2007 19:06'!
allDailyCollectionYearsForKindOf: aClass
	"all years on which occur of anything of that class. Sorted!!"
	"optimize that!!"
	^(self inject: Set new into: [:set :each | set addAll: (each allYearsForKindOf: aClass). set])
		asSortedCollection

"DailyCollection allInstances allDailyCollectionYearsForKindOf: AIDA.Invoice"! !

!Collection methodsFor: '*Aida' stamp: 'JM 4/22/2007 19:06'!
isWebElement
	^true "more or less"! !

!Collection methodsFor: '*Aida' stamp: 'JM 4/22/2007 19:06'!
isWebPage
	^false! !

!Company methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
addEmployee: aPerson
	aPerson becomeEmployeeOf: self! !

!Company methodsFor: 'accessing-events' stamp: ' 10/1/08 16:40'!
allEvents
	^self events all! !

!Company methodsFor: 'import-export' stamp: ' 10/1/08 16:40'!
autoEMailAddressesForPersons
	"Repository default company autoEMailAddressesForPersons"
	self allEmployees do: [:person |
		person email isValidEMailAddress ifFalse:  	
			[person email: (person name asSloveneWithoutCircumflexes asLowercase , '.',
			person surname asSloveneWithoutCircumflexes asLowercase, 
			'@salus.si')] ]! !

!Company methodsFor: 'private' stamp: ' 10/1/08 16:40'!
cleanupEmployeeToOrgUnitsConnections
	"(AIDASite named: 'biart') repository company cleanupEmployeeToOrgUnitsConnections"
	| set employees |
	set := self allEmployees asSet.
	employees := self allOrgUnits "collect them through orgunits hierarchy"
		inject: Set new into: [:sett :each | sett addAll: each allMembers; yourself].
	(employees reject: [:each | set includes: each]) "those dangling"
		do: [:each | each becomeFormerEmployeeOf: self. each removeJobRole.
			self allOrgUnits do: [:unit | unit removeMember: each] ].
	employees := self allOrgUnits inject: Set new into: [:sett :each | 
		sett addAll: each allPersonsWithJobRoles; yourself].
	(employees reject: [:each | set includes: each])
		do: [: each | each removeJobRole].! !

!Company methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
company
	^self! !

!Company methodsFor: 'import-export' stamp: ' 10/1/08 16:40'!
connectEmployeesToOrgUnits
	"salus"	
	"preimenuj zacasno org.enote brez sumnikov!! "
	"Repository default company connectEmployeesToOrgUnits"
	| orgUnit |
	self allEmployees do: [:each |
		orgUnit := self salusOrgUnitFor: each.
		orgUnit notNil ifTrue: [each allOrgUnits isEmpty ifTrue: [each becomeMemberOf: orgUnit] ]]! !

!Company methodsFor: 'import-export' stamp: ' 10/1/08 16:40'!
connectPersonsToWebUsers
	"Repository default company connectPersonsToWebUsers"
	self allEmployees do: [:each | 	AIDASite default securityManager addPerson: each]! !

!Company methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
employeeNamed: aString
	^self allEmployees detect: [:each | aString = each name] ifNone: [nil]! !

!Company methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
employeeNamedSurnamed: aString
	^self allEmployees detect: [:each | aString = each nameSurname] ifNone: [nil]! !

!Company methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
employeeSurnamedNamed: aString
	^self allEmployees detect: [:each | aString = each surnameName] ifNone: [nil]! !

!Company methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
existEmployeeWithId: aString
	^self allEmployees contains: [:each | each id = aString].! !

!Company methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
existEmployeeWithName: aNameString surname: aSurnameString
	^self allEmployees contains: [:each | 
		(each name = aNameString) and: [each surname = aSurnameString]].! !

!Company methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
isCompany
	^true! !

!Company methodsFor: 'private'!
preferredUrl
	| nme |
	nme := (self name copyUpTo: $ ) trimBlanks asSloveneWithoutCircumflexes asHttpFriendly.
	^'/', nme! !

!Company methodsFor: 'private'!
printString
	^'company: ', self name! !

!Company methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
removeEmployee: aPerson
	aPerson noMoreEmployeeOf: self.
	self allOrgUnits do: [:each | each removeMember: aPerson].
	aPerson removeJobRole! !

!Company class methodsFor: 'odb specific' stamp: ' 10/1/08 16:40'!
replicationSpecaa
	"Gemstone"
	^#( 	(id 	replicate)
			(name replicate)
			(description replicate)
			(addresses max 4)
			(roles max 2)
			(relatedPartyRoles max 2)
			(events forwarder)
			(relatedObjects max 1) )! !

!DailyCollection methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
add: newObject

	self add: newObject onDate: newObject date! !

!DailyCollection methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
add: newObject onDate: aDate
	(self includes: newObject onDate: aDate) ifTrue: [^nil].
	self existCheckDate: aDate.
	(self days at: aDate asDays) add: newObject.
	^newObject! !

!DailyCollection methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
addAll: aCollection 

	aCollection do: [:each | self add: each].
	^aCollection! !

!DailyCollection methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
addAll: aCollection onDate: aDate

	self existCheckDate: aDate.
	^aCollection do: [:each | 	self add: each onDate: aDate].! !

!DailyCollection methodsFor: 'adding-removing' stamp: 'JM 4/26/2007 21:29'!
addFirst: newObject inYear: aYear
	"put in first place at 1st jan of this year"
	| date |
	date := SpDate newDay: 1 month: 1 year: aYear.
	(self includes: newObject onDate: date) ifTrue: [^nil].
	self existCheckDate: date.
	(self days at: date asDays) addFirst: newObject.
	^newObject! !

!DailyCollection methodsFor: 'adding-removing' stamp: 'JM 4/26/2007 21:29'!
addLast: newObject inYear: aYear
	"put in first place at 1st jan of this year"
	| date |
	date := SpDate newDay: 31 month: 12 year: aYear.
	(self includes: newObject onDate: date) ifTrue: [^nil].
	self existCheckDate: date.
	(self days at: date asDays) addLast: newObject.
	^newObject! !

!DailyCollection methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
all
	| dayCol |
	dayCol := SortedCollection
		withAll: self days keys
		sortBlock: [:a :b | a > b].
	^dayCol inject: OrderedCollection new into: [:col :each | col addAll: (self days at: each); yourself ].! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allDated: aDate

	^(self days at: aDate asDays ifAbsent: [^#()] ) copy! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allDates
	"all dates on which something exist"
	^self allDays collect: [:each | Date fromDays: each]! !

!DailyCollection methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
allDays
	"all day numbers on which something exist"
	^self days keys! !

!DailyCollection methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
allDaysForKindOf: aClass
	"all day numbers on which something of that class exist"
	^self days keys select: [:day | 
		(self days at: day) contains: [:each | each isKindOf: aClass] ].! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allFromDate: aStartDate to: anEndDate
	| startDay endDay daysInRange |
	startDay := aStartDate asDays. endDay := anEndDate asDays.
	daysInRange := self allDays select: [:each | each >= startDay and: [each <= endDay] ].
	daysInRange := daysInRange asSortedCollection. 
	^daysInRange inject: OrderedCollection new into: [:col :each | col addAll: (self days at: each). col]

"DailyCollection allInstances last allFromDate: (Date readSloFrom: '1.1.2004' readStream) 
  	to: (Date readSloFrom: '31.12.2006' readStream)"! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allLastMonth
	^self allMonthly: Date today - Date today day! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allLastWeek
	^self allWeekly: Date today - 7! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allLastYear
	^self allYear: Date today year - 1! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allMonthly: aDate
	^self 
		allFromDate: aDate firstDayOfMonth
		to: aDate firstDayInMonth + aDate daysInMonth - 1! !

!DailyCollection methodsFor: 'accessing' stamp: 'np 3/29/2008 05:18'!
allSinceDate: aDate
	^self allFromDate: aDate to: SpDate today! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allThisMonth
	^self allMonthly: Date today! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allThisWeek
	^self allWeekly: Date today! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allThisYear
	^self allYear: Date today year! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allToday
	^self allDated: Date today! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allWeekly: aDate
	^self 
		allFromDate: aDate - aDate weekdayIndex + 1
		to: aDate - aDate weekdayIndex + 1 + 7! !

!DailyCollection methodsFor: 'accessing' stamp: 'JM 4/26/2007 21:30'!
allYear: aNumber
	^self 
		allFromDate: (SpDate newDay: 1 month: 1 year: aNumber)
		to: (SpDate newDay: 31 month: 12 year: aNumber)! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allYears
	"all years on which something exist"
	^SortedCollection 
		withAll: (self allDates inject: Set new into: [:set :each | set add: each year. set])
		sortBlock: [:a :b | a < b]

"DailyCollection allInstances last allYears"! !

!DailyCollection methodsFor: 'private-accessing' stamp: 'janko 8/3/2011 20:34'!
allYearsForKindOf: aClass
	"all years on which something of that class exist"
	| allDays year years skipToDay |
	allDays := self days keys asSortedCollection. allDays isEmpty ifTrue: [^#()].
	years := Set new. skipToDay := 0.
	allDays do: [:day |
		day >= skipToDay ifTrue:
			[((self days at: day) contains: [:entry | entry isKindOf: aClass]) ifTrue:
				[year := (Date fromDays: day) year.
				years add: year. 
				skipToDay := (Date newDay: 1 monthNumber: 1 year: year+1) asDays] ] ].
	^years asSortedCollection asOrderedCollection

"DailyCollection allInstances last allYearsForKindOf: Invoice "! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allYesterday
	^self allDated: Date today - 1! !

!DailyCollection methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
contains: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer true if aBlock ever evaluates to true, otherwise answer false."

	self detect: aBlock ifNone: [^false].
	^true! !

!DailyCollection methodsFor: 'private' stamp: ' 21/4/07 22:07'!
days
	days isNil ifTrue: [self initDays].
	^days! !

!DailyCollection methodsFor: 'private' stamp: ' 21/4/07 22:07'!
existCheckDate: aDate

	(self days includesKey: aDate asDays) ifFalse:
		[self days at: aDate asDays put: OrderedCollection new].! !

!DailyCollection methodsFor: 'accessing'!
firstDayInYear: aYear
	"on 1 januar of that year"
	^self allDated: (Date newDay: 1 monthNumber: 1 year: aYear).! !

!DailyCollection methodsFor: 'accessing'!
firstInYear: aYear
	"on 1st january of that year"
	| col |
	col := self firstDayInYear: aYear.
	col isEmpty ifTrue: [^nil].
	^col first! !

!DailyCollection methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
includes: anObject
	"Answer whether anObject is one of the receiver's elements."

	self days values do: [:each | (each includes: anObject) ifTrue: [^true]].
	^false! !

!DailyCollection methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
includes: anObject onDate: aDate
	| values |
	values := self days at: aDate asDays ifAbsent: [^false].
	^values includes: anObject! !

!DailyCollection methodsFor: 'testing'!
includesYear: aNumber
	"anything on that year?"
	| start end |
	self isEmpty ifTrue: [^false].
	start := (Date newDay: 1 monthNumber: 1 year: aNumber) asDays.
	end := (Date newDay: 31 monthNumber: 12 year: aNumber) asDays.
	^self allDays contains: [:day | day between: start and: end]! !

!DailyCollection methodsFor: 'private' stamp: ' 21/4/07 22:07'!
initDays
	days := Dictionary new.! !

!DailyCollection methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isEmpty
	"Answer whether the receiver contains any elements."

	^self size = 0! !

!DailyCollection methodsFor: 'accessing'!
last
	"find last values, starting from today and back in past. Most recent first!!"
	self isEmpty ifTrue: [^nil].
	^(self last: 1) first! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
last: aNumber
	"find last number of values, starting from today and back in past. Most recent first!!"
	| collection dayColl |
	collection := OrderedCollection new.
	dayColl := SortedCollection withAll: self days keys sortBlock: [:a :b | a > b].
	dayColl do: [:day || coll |
		coll := (self days at: day) copy reverse.
		collection addAll: (coll copyFrom: 1 to: ((aNumber - collection size) min: coll size) ).
		collection size = aNumber ifTrue: [^collection] ].
	^collection

"LogisticSystem default owner events size last: 1000"! !

!DailyCollection methodsFor: 'accessing' stamp: 'JM 4/26/2007 21:31'!
lastDayInYear: aYear
	"on 31 december of that year"
	^self allDated: (SpDate newDay: 31 month: 12 year: aYear).! !

!DailyCollection methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
move: anObject fromDate: aDate toDate: aNewDate
	| collection |
	collection := self days at: aDate asDays.
	collection remove: anObject.
	self add: anObject onDate: aNewDate! !

!DailyCollection methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
remove: oldObject 
	^self remove: oldObject ifAbsent: [self notFoundError]! !

!DailyCollection methodsFor: 'adding-removing'!
remove: oldObject ifAbsent: anExceptionBlock
	| result |
	result := self remove: oldObject onDate: oldObject date.
	result isNil ifTrue: [^anExceptionBlock value].! !

!DailyCollection methodsFor: 'adding-removing'!
remove: oldObject onDate: aDate
	"remove if exist on that date, otherwise return nil"
	| collection |
	collection := self days at: oldObject date asDays ifAbsent: [^nil].
	collection remove: oldObject ifAbsent: [^nil].
	^oldObject! !

!DailyCollection methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
removeAll: aCollection 
	"Remove each element of aCollection from the receiver.  If successful for each,
	answer aCollection."
	aCollection do: [:each | self remove: each].
	^aCollection! !

!DailyCollection methodsFor: 'adding-removing'!
removeAnywhere: oldObject 
	"First find the right day then remove it. Use tham method if an object's date was changed later"
	self days values do: [:collection | 
		(collection includes: oldObject) ifTrue: 
			[collection remove: oldObject. 
			^true] ].
	^false! !

!DailyCollection methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
size
	days isNil ifTrue: [^0].
	^self days values inject: 0 into: [:sum :each | sum + each size].! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allDates
	"all dates on which something exist"
	^self days keys collect: [:each | Date fromDays: each]! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allFromDate: aStartDate to: anEndDate

	| collection |
	collection := OrderedCollection new: 100.
	aStartDate to: anEndDate do: [:date |
		collection add: (self at: date) ].
	^collection! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allLastMonth
	^self allMonthly: Date today - Date today day! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allLastWeek
	^self allWeekly: Date today - 7! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allMonthly: aDate
	^self 
		allFromDate: aDate firstDayOfMonth
		to: aDate firstDayInMonth + aDate daysInMonth - 1! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allThisMonth
	^self allMonthly: Date today! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allThisWeek
	^self allWeekly: Date today! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allWeekly: aDate
	^self 
		allFromDate: aDate - aDate weekdayIndex + 1
		to: aDate - aDate weekdayIndex + 1 + 7! !

!DailyValues methodsFor: 'adding-removing'!
at: aDate
	^self at: aDate ifAbsent: [self defaultValue]! !

!DailyValues methodsFor: 'adding-removing'!
at: aDate add: aValue 
	self existCheckDate: aDate.
	^self days at: aDate asDays put: (self at: aDate) + aValue! !

!DailyValues methodsFor: 'adding-removing'!
at: aDate ifAbsent: aBlock
	^self days at: aDate asDays ifAbsent: [aBlock value]! !

!DailyValues methodsFor: 'adding-removing'!
at: aDate put: aValue
	self existCheckDate: aDate.
	^self days at: aDate asDays put: aValue! !

!DailyValues methodsFor: 'adding-removing'!
at: aDate subtract: aValue
	self existCheckDate: aDate.
	^self days at: aDate asDays put: (self at: aDate) - aValue! !

!DailyValues methodsFor: 'adding-removing'!
atOrLastFrom: aDate
	"return value on that date or last date when some value exist"
	^self at: aDate ifAbsent: [self lastFrom: aDate]! !

!DailyValues methodsFor: 'private' stamp: ' 21/4/07 22:07'!
days
	days isNil ifTrue: [self initDays].
	^days! !

!DailyValues methodsFor: 'private' stamp: ' 21/4/07 22:07'!
defaultValue
	^0! !

!DailyValues methodsFor: 'private' stamp: ' 21/4/07 22:07'!
existCheckDate: aDate

	(self days includesKey: aDate asDays) ifFalse:
		[self days at: aDate asDays put: self defaultValue].! !

!DailyValues methodsFor: 'private' stamp: ' 21/4/07 22:07'!
initDays
	days := IdentityDictionary new.! !

!DailyValues methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isEmpty
	"Answer whether the receiver contains any elements."

	^self size = 0! !

!DailyValues methodsFor: 'accessing' stamp: 'jm 8/1/2010 11:13'!
last
	"return value on last (most future) date entered"
	^self at: self lastDate! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
last: aNumber
	"find last number of values, starting from today and back in past. Most recent first!!"
	| collection |
	collection := OrderedCollection new.
	1 to: aNumber do: [:inx | collection add: (self at: Date today - inx + 1)].
	^collection! !

!DailyValues methodsFor: 'accessing'!
lastDate
	"return date on last (most future) value entered"
	| coll |
	coll := self days keys asSortedCollection.  "not very optimized way for big colections!! "
	coll isEmpty ifTrue: [^nil].
	^Date fromDays: coll last! !

!DailyValues methodsFor: 'private' stamp: ' 21/8/07 09:38'!
lastDateFrom: aDate
	"search back in time for some date on which a value exist and return that date"
	| start |
	start := aDate asDays.
	self days keys asSortedCollection reverse do:  "not very optimized way for big colections!! "
		[:day | day <= start ifTrue: [^Date fromDays: day] ].
	^nil! !

!DailyValues methodsFor: 'private' stamp: ' 21/8/07 09:38'!
lastFrom: aDate
	"search back in time for some date on which a value exist and return it"
	| start |
	start := aDate asDays.
	self days keys asSortedCollection reverse do:  "not very optimized way for big colections!! "
		[:day | day <= start ifTrue: [^self days at: day] ].
	^nil! !

!DailyValues methodsFor: 'adding-removing'!
resetAt: aDate
	"put default value at this date"
	^self at: aDate put: self defaultValue! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
size
	^self days values size! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
sumFromDate: aStartDate to: anEndDate

	^(self allFromDate: aStartDate to: anEndDate)
		inject: 0
		into: [:sum :each | sum + each]! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
sumLast: aNumber
	"sum values of aNumber of days, starting from today and back"

	^(self last: aNumber)
		inject: 0
		into: [:sum :each | sum + each]! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
sumMonthly: aDate

	^(self allMonthly: aDate)
		inject: 0
		into: [:sum :each | sum + each]! !

!DailyValues methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
sumWeekly: aDate

	^(self allWeekly: aDate)
		inject: 0
		into: [:sum :each | sum + each]! !

!Date methodsFor: '*Aida' stamp: 'janko 8/3/2011 19:40'!
asDays
	"days between  1jan1901 and receiver,  same as on VisualWorks"
	"Pharo specific!!"
	^self julianDayNumber - 2415386
! !

!Date methodsFor: '*Aida' stamp: 'jm 12/8/2010 22:37'!
monthAndDayString
	"with leading zeros, example: 05-16 for 16may"
	^(self monthIndex < 10 ifTrue: ['0'] ifFalse: ['']), self monthIndex printString, '-',
	 	(self dayOfMonth < 10 ifTrue: ['0'] ifFalse: ['']), self dayOfMonth printString

"Date today monthAndDayString"! !

!Date methodsFor: '*Aida' stamp: 'jm 12/8/2010 22:35'!
printISOString
	^self year printString, 
		(self monthIndex < 10 ifTrue: ['0'] ifFalse: ['']), self monthIndex printString,
		(self dayOfMonth < 10 ifTrue: ['0'] ifFalse: ['']), self dayOfMonth printString

"Date today printISOString   "! !

!Date methodsFor: '*Aida' stamp: 'jm 12/8/2010 22:37'!
shortPrintSloString
	^self dayOfMonth printString, '.', self monthIndex printString, '.', self year printString.

"Date today shortPrintSloString "! !

!Date methodsFor: '*Aida' stamp: 'jm 12/8/2010 22:36'!
shorterPrintSloString
	"year in two digits only"
	| yeart |
	yeart := (self year \\ 100) printString. yeart size = 1 ifTrue: [yeart := '0', yeart].
	^self dayOfMonth printString, '.', self monthIndex printString, '.', yeart.

"Date today shorterPrintSloString"! !

!DefaultAuthenticator methodsFor: 'authenticating'!
authenticateUserNamed: anUsernameString withPassword: aPasswordString
	^(self site securityManager userNamed: anUsernameString withPassword: aPasswordString)
		notNil.! !

!DefaultAuthenticator methodsFor: 'authenticating'!
endAuthentication
	"indicate that authetication is ended"! !

!DefaultAuthenticator methodsFor: 'authenticating'!
existUserNamed: anUsernameString
	^(self site securityManager userNamed: anUsernameString)
		notNil.! !

!DefaultAuthenticator methodsFor: 'accessing'!
site
	^site! !

!DefaultAuthenticator methodsFor: 'private'!
site: anAIDASite
	site := anAIDASite! !

!DefaultAuthenticator methodsFor: 'authenticating'!
startAuthentication
	"indicate that authetication will soon start"! !

!DefaultAuthenticator methodsFor: 'accessing'!
userNamed: anUsernameString
	^self site securityManager userNamed: anUsernameString! !

!DefaultAuthenticator class methodsFor: 'instance creation'!
newOn: anAIDASite
	^super new
		site: anAIDASite! !

!DelimitedFile methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
codepage
	codepage isNil ifTrue: [self codepage: self defaultCodepage].
	^codepage! !

!DelimitedFile methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
codepage: aSymbol
	" #cp1250  #iso2 #'7bit'"
	codepage := aSymbol.! !

!DelimitedFile methodsFor: 'private' stamp: ' 21/4/07 22:07'!
crlf
	"return an cr-lf combination"

	^(Character cr) asSymbol ", (Character lf) asSymbol".! !

!DelimitedFile methodsFor: 'accessing'!
defaultCodepage
	^#UTF8
"	^#cp1250 " "Windows"! !

!DelimitedFile methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
defaultDelimiter
	"default delimiter is ; "

	^$;! !

!DelimitedFile methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
delimiter
	"delimiter is a character, which separate fields in a delimited file"
	delimiter isNil ifTrue: [self delimiter: self defaultDelimiter].
	^delimiter! !

!DelimitedFile methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
delimiter: aCharacter
	"delimiter is a character, which separate fields in a delimited file"
	delimiter := aCharacter.! !

!DelimitedFile methodsFor: 'private' stamp: ' 21/4/07 22:07'!
endOfLine: aStream
	"return true if we are at the end of line (on cr or lf characters)"
	aStream peek isNil ifTrue: [^true].
	^(aStream peek = Character cr or: [aStream peek = Character lf]).! !

!DelimitedFile methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
filename
	^filename! !

!DelimitedFile methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
filename: aFilename
	filename := aFilename.! !

!DelimitedFile methodsFor: 'initialize - release' stamp: ' 21/4/07 22:07'!
initialize! !

!DelimitedFile methodsFor: 'private' stamp: ' 21/4/07 22:07'!
newRecordFrom: aStream

	"read one line from delimited file, detect and separate fields and convert to
	appropriate objects into an ordered collection. return that collection"

	| collection field |
	collection := OrderedCollection new.
	[self endOfLine: aStream] whileFalse:
		[field := self readFieldFrom: aStream.
		collection add: field].
	self skipEndOfLine: aStream.
	^collection! !

!DelimitedFile methodsFor: 'private' stamp: 'mivsek 6/13/2007 16:03'!
readFieldFrom: aStream
	"read one field from delimited file, and convert to appropriate object. Return that object"
	| object stream |
	aStream peek = $" ifTrue:  "start of a text field"
		[object := aStream upTo: $"; upTo: $".
		(self endOfLine: aStream) ifFalse: [aStream upTo: self delimiter].
		^AIDASite convert: object fromCodepage: self codepage].
	stream := WriteStream on: String new.
	[aStream peek = self delimiter or: [self endOfLine: aStream]] 
		whileFalse: [aStream peek isNil ifTrue: [^stream contents]. stream nextPut: aStream next].
	aStream peek = self delimiter ifTrue: [aStream skip: 1].
	object := stream contents. stream close.
	^object
"
	(object includes: $. ) false
		ifTrue:
			[(Date readSloFrom: object readStream) notNil 
				ifTrue: [^Date readSloFrom: object readStream]
				ifFalse: [^object asInteger]]
		ifFalse: [^object asInteger].
"! !

!DelimitedFile methodsFor: 'file reading'!
readFrom: aFilenameString
	"read a delimited file and convert content to object representation in 'records' collection"
	| stream | 
	self filename: (SpFilename named: aFilenameString).
	[stream :=  self filename readStream.
	self readFromStream: stream] 
		ensure: [stream close].

"DelimitedFile readFrom: 'm:\geoplin\tarifni\exports\ddnevnik.txt' "! !

!DelimitedFile methodsFor: 'file reading' stamp: ' 21/4/07 22:07'!
readFromStream: aStream
	"read a delimited file and convert content to object representation in 'records' collection"
	[aStream atEnd] whileFalse: [self records add: (self newRecordFrom: aStream)]! !

!DelimitedFile methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
records
	"when aDelimitedFile is created on a existing file, all records (lines in a file) are 
	converted and stored in this ordered collection. Fields in each record are stored in 
	another ordered collection as objects of appropriate class (texts as Strings, 
	numbers as Integers or Floats, dates as Dates)"

	records isNil ifTrue: [self records:OrderedCollection new].
	^records! !

!DelimitedFile methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
records: aCollection
	records := aCollection.! !

!DelimitedFile methodsFor: 'private' stamp: ' 21/4/07 22:07'!
skipEndOfLine: aStream

	"skip all cr and lf characters)"

	[aStream atEnd] whileFalse: 
		[(aStream peek = Character cr or: [aStream peek = Character lf]) 
			ifTrue:	[aStream skip: 1]
			ifFalse: [^self]
		].! !

!DelimitedFile methodsFor: 'file writing' stamp: ' 21/4/07 22:07'!
writeRecord: anArray to: aStream

	| dm data1 |
	dm := false.
	anArray do: [:data |
		dm ifTrue: [aStream nextPut: self delimiter].
		(data isKindOf: Integer) ifTrue: [aStream nextPutAll: data printString].
		(data isKindOf: String) ifTrue: 
			[data1 := AIDASite returnCSZFromCP852String:  data.
			data1 := data1 select: [:ch | ch asInteger <=255].
			aStream nextPutAll: '"',data1,'"'].
		(data isKindOf: FixedPoint) ifTrue: 
			[data1 := data printDotString select: [:ch | ch ~= $. ].
			aStream nextPutAll: data1].
		dm := true].
	aStream nextPutAll: self crlf.! !

!DelimitedFile methodsFor: 'file writing' stamp: ' 21/4/07 22:07'!
writeToFile
	self writeToFile: self filename.
"
|dmFile|
dmFile := DelimitedFile fileToWrite: 'test.dat'.
dmFile records 
	add: (Array with: 123 with: 'abcd' with: 345);
	add: (Array with: 234 with: 'CDE' with: 567).
dmFile writeToFile
"! !

!DelimitedFile methodsFor: 'file writing' stamp: ' 21/4/07 22:07'!
writeToFile: aFilenameString
	"export all records to delimited file"
	| stream | 
	self filename: aFilenameString asFilename.
	[stream :=  self filename writeStream.
	records do: [:record | self writeRecord: record to: stream] ]
		ensure: [stream close].
"
|dmFile|
dmFile := DelimitedFile new.
dmFile records 
	add: (Array with: 123 with: 'abcd' with: 345);
	add: (Array with: 234 with: 'CDE' with: 567).
dmFile writeToFile: 'test.dat'
"! !

!DelimitedFile class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
fileToWrite: aFilenameString

	"create a new instance on a specified (empty) file to write. After you fill records attribute with all
	data, call writeToFile method to do actual exporting to this file"

	| instance |
	instance := self new.
	instance filename: aFilenameString asFilename.
	^instance.! !

!DelimitedFile class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!DelimitedFile class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
readFrom: aFilenameString

	"read a specified delimited file and store records in a records attribute. Use default delimiter
	for field separator (character ; )"

	| instance |
	instance := self new.
	instance readFrom: aFilenameString.
	^instance.

"DelimitedFile readFrom: 'i:\projekti\dare\proizvod.txt' "! !

!DocLink methodsFor: 'converting' stamp: ' 21/4/07 22:07'!
asWebLink
	^WebLink text: self title linkTo: self url! !

!DocLink methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	^self! !

!DocLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
migrateToUnicode
	"DocLink allInstances do: [:each | each migrateToUnicode]"
	title notNil ifTrue: [title := title ensureUnicodeSloveneChars]! !

!DocLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
object
	^object! !

!DocLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
object: anObject
	object := anObject! !

!DocLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
printString
	^'a Doclink
		title:  ', (self title notNil ifTrue: [self title] ifFalse: ['']), '
		url: ', (self url notNil ifTrue: [self url] ifFalse: ['']), '
		object: ', self object printString! !

!DocLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
title
	^title! !

!DocLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
title: aString
	title := aString! !

!DocLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
url
	^url! !

!DocLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
url: aString
	url := aString! !

!DocLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
uuid
	^self hash printString! !

!DocLink class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	"Answer a newly created and initialized instance."

	^super new initialize! !

!EMailMessenger methodsFor: 'private-sending'!
adapt: aString
	"correct some characters to suit the emailer and its bugs"
	"EMailMessenger new adapt: 'BOZ^IC^' convertToSloveneChars"
	| win in out ch |
	win := true. "SpEnvironment onWindows."
	in := aString readStream.
	out := WriteStream on: aString class new.
	[in atEnd] whileFalse:
		[ch := in next.
		win ifTrue: [ch = AIDASite charC ifTrue: [ch := $C] ].  "problem with SMTPClient on Windows"
		out nextPut: ch].
	^out contents! !

!EMailMessenger methodsFor: 'receiving'!
alreadyExist: aDocument
	^false "later!!"! !

!EMailMessenger methodsFor: 'receiving'!
anyNewMail
	^self mailbox deliveryQueue peek notNil.! !

!EMailMessenger methodsFor: 'private'!
client
	"a SMTP client"
	client isNil ifTrue: [self initClient].
	^client! !

!EMailMessenger methodsFor: 'receiving'!
dealWithDocument: aDocument
	aDocument isReceivedInvoice ifFalse: [^nil].
	(self alreadyExist: aDocument) ifTrue: [^nil].
	aDocument issuer addInvoice: aDocument! !

!EMailMessenger methodsFor: 'private'!
emailAddressFor: aPersonOrCollection
	"one or more email addresses, separated with comma"
	| collection |
	(aPersonOrCollection isKindOf: String) ifTrue: [^(self adapt: aPersonOrCollection)].
	collection := (aPersonOrCollection isKindOf: Collection) 
		ifTrue: [aPersonOrCollection] ifFalse: [Array with: aPersonOrCollection].
	collection := collection select: [:each | each notNil and: [each email isValidEMailAddress]].
	collection isEmpty ifTrue: [^'User has no email!! <info@eranova.si>'].
	^self adapt: (collection inject: '' into: [:string :each |    "no full name, just plain address!! "
				(string = '' ifTrue: [''] ifFalse: [string, ', ']), each email])
"	^self adapt: (collection inject: '' into: [:string :each |
				(string = '' ifTrue: [''] ifFalse: [string, ', ']), '""', each nameSurname, '"" <', each email, '>'])
					ensureUnicodeSloveneChars
"! !

!EMailMessenger methodsFor: 'examples' stamp: 'jm 11/10/2010 15:03'!
exampleICalMeeting
	| event calendar |
	event := ICEvent summary: 'Example meeting'.
	event 
"		textualDescription: (self url, (String with: Character cr), self agendaText); "
		uid: ICSqueakUUIDStrategy new generateUid;
		start: (SpTimestamp now addSeconds: 24*3600)  asSqueakDateAndTime;
		end: (SpTimestamp now addSeconds: 25*3600)  asSqueakDateAndTime;
		organizer: (ICUser new
				commonName: 'Janko'; 
				emailAddress: 'janko@eranova.si');
		location: 'Room 123';
		beMediumPriority; 
		beOpaque;
		beConfirmed. 
	calendar := ICCalendar name: 'aida'.
	calendar method: ICCalendar methodRequest.
	calendar addEvent: event.
 	^(ICCalendarExporter calendar: calendar) 
		export dataStream contents copyReplaceAll: String crlf with: (String with: Character cr)! !

!EMailMessenger methodsFor: 'receiving'!
getDocTypeOfMessage: aMailMessage
	"for now only Mobitel's XML invoices"
	aMailMessage attachments size = 3 ifFalse: [^nil].
	('E-racun za opravljene storitve Mobitel*' match: aMailMessage subject) 
		ifTrue:  [^#XMLSloSimpleInvoice].
	('*e-racun@mobitel.si*' match: aMailMessage from first asLowercase) ifTrue: [^#XMLSloSimpleInvoice].
	^nil! !

!EMailMessenger methodsFor: 'receiving'!
getMailDocument
	"returns appropriate Document, like ReceivedInvoice with atachments"
	| message type |
	message := self getMailMessage.
	type := self getDocTypeOfMessage: message.
	type = #XMLSloSimpleInvoice 
		ifTrue: [^ReceivedInvoice fromMailMessage: message on: self repository].
	^nil

"(AIDASite named: 'biart') repository messenger getMailDocument "! !

!EMailMessenger methodsFor: 'receiving' stamp: 'jm 8/2/2010 13:51'!
getMailMessage
	"gets a MailMEssage from postbox if any. Blocks if there is no messages!! "
	| letterInTransit |
	letterInTransit := self mailbox queue next.
"	^Net.MailMessage readFrom: letterInTransit letterText readStream "! !

!EMailMessenger methodsFor: 'initialize-release'!
initClient
	client := self class smtpClientClass host: self repository emailSMTPServer.
	self repository emailSMTPUsername trimBlanks notEmpty ifTrue:
		[client username: self repository emailSMTPUsername.
		client user password: self repository emailSMTPPassword.]! !

!EMailMessenger methodsFor: 'initialize-release'!
initMailbox
	mailbox notNil ifTrue: [mailbox stopFetchingMail].
	mailbox := AIDA.Mailbox new.
	mailbox 
		username: self repository emailPOP3Username;
		password: self repository emailPOP3Password;
		server: self repository emailPOP3Server.
	mailbox 	startFetchingMail! !

!EMailMessenger methodsFor: 'initialize-release'!
initQueue
	queue := SharedQueue new.
	self initSenderProcess.! !

!EMailMessenger methodsFor: 'initialize-release'!
initSenderProcess
	self sendingLoop notNil ifTrue: [self sendingLoop terminate].
	self sendingLoop: 
		([self senderProcess] forkAt: Processor userBackgroundPriority).! !

!EMailMessenger methodsFor: 'sending'!
isSendingStarted
	^self sendingLoop notNil! !

!EMailMessenger methodsFor: 'accessing'!
mailbox
	mailbox isNil ifTrue: [self initMailbox].
	^mailbox! !

!EMailMessenger methodsFor: 'private-error reports'!
messageForError: anErrorString for: aRFC822Message
	| text |
	text := 'Napaka pri pos^iljanju e-pos^te

	', anErrorString, '

prejemnik: ', aRFC822Message to first.

	text := text, '  

To je samodejno sporoc^ilo iz informacijskega portala sistema kakovosti BiArt.'.

	^text! !

!EMailMessenger methodsFor: 'private-error reports'!
notifyError: anErrorString toSenderOf: aRFC822Message
	"VW specific"
	| msg address |
	msg := Net.MailMessage newTextPlain.
	address := aRFC822Message from notEmpty
		ifTrue: [aRFC822Message from first]
		ifFalse: [''].
	msg 
		subject: 'BiArt: Napaka pri dostavljanju e-pos^te';
		text:  (self messageForError: anErrorString for: aRFC822Message);
		from: address; to: address.
	self privSendMessage: msg reportError: #nomore "try to send only once!! "! !

!EMailMessenger methodsFor: 'private-sending'!
privSendMessage: aRFC822Message reportError: aReportSymbol
	| errorText |
	[aRFC822Message fromSendStrings isEmpty 
		ifTrue: [aRFC822Message from: self repository adminEMail].
	self client 
		connect;
		useAuthentication: false; "for now"
		login;
		sendMessage: aRFC822Message;
		quit.
	self reportMailSend: aRFC822Message]
			on: Error
			do: [:ex | errorText := ex class name, ': ', ex errorString.
				Transcript cr; show: 'e-mail sending on ', self repository site name, ' failed: ', errorText; cr.
				(Delay forMilliseconds: 1000) wait.
				aReportSymbol = #repeat ifTrue:
					[Transcript show: 'repeating: '.
					self privSendMessage: aRFC822Message reportError: #report].
				aReportSymbol = #report ifTrue:
					[self notifyError: errorText toSenderOf: aRFC822Message] ].
	(Delay forMilliseconds: 200) wait.! !

!EMailMessenger methodsFor: 'accessing'!
queue
	queue isNil ifTrue: [self initQueue].
	^queue.! !

!EMailMessenger methodsFor: 'private-receiving'!
receivingLoop
	"doc receiving process"
	^receivingLoop! !

!EMailMessenger methodsFor: 'private-receiving'!
receivingLoop: aProcess
	"doc receiving process"
	receivingLoop := aProcess! !

!EMailMessenger methodsFor: 'private-sending'!
reportMailSend: aRFC822Message
	| receiver subject |
	receiver := aRFC822Message toSendStrings first.
	(receiver includes: $<) ifTrue: [receiver := receiver readStream upTo: $<; upTo: $>].
	subject := aRFC822Message subject asSloveneWithoutCircumflexes contractTo: 40.
	Transcript cr; show: 'e-mail sent to: ', receiver, ' ', subject
		.! !

!EMailMessenger methodsFor: 'accessing'!
repository
	^repository! !

!EMailMessenger methodsFor: 'private'!
repository: aRepository
	repository := aRepository! !

!EMailMessenger methodsFor: 'examples'!
sendExample
	"(AIDASite named: 'aidademo') repository messenger sendExample"
	"Setup SMTP server first in repository settings!!"
	| body from to |
	body := 'Emailing test'.
	from := Person new email: 'aida@eranova.si'.
	to := Person new email: 'janko@eranova.si'.
	self 
		sendSubject: 'Aida Emailer test' body: body 
		from: from to: to! !

!EMailMessenger methodsFor: 'examples'!
sendICalExample
	"(AIDASite named: 'aidademo') repository messenger sendICalExample"
	"Setup SMTP server first in repository settings!!"
	| body from to |
	body := 'Test meeting call'.
	from := Person new email: 'aida@eranova.si'.
	to := Person new email: 'janko.testni@eranova.si'.
	self 
		sendSubject: 'Aida Meeting call test' body: body 
		icalName: 'meeting.ics'
		content: self exampleICalMeeting
		from: from to: to! !

!EMailMessenger methodsFor: 'sending' stamp: 'jm 8/2/2010 13:39'!
sendSubject: aSubjectString body: aBodyString attachFile: aFilenameString content: aContentString from: aPerson to: aPersonOrCollection
	"VW specific!!"
	| message receiverAddresses body attachment |
	receiverAddresses := self emailAddressFor: aPersonOrCollection.
	receiverAddresses isEmpty ifTrue: [^nil].
	message := MailMessage newTextPlain. 
	body := "ObjectMemory versionId at: 5" true >= 76 "7.6?" 
		ifTrue: [aBodyString copyReplaceAll: (String with: Character cr) with: String crlf ] "why after 7.6?"
		ifFalse: [aBodyString].
	message 
		charset: 'UTF-8'; headerCharset: 'UTF-8'; 
		from: (self emailAddressFor: aPerson); 
		to: receiverAddresses; 
		subject: (self adapt: aSubjectString convertToSloveneChars);
		text: (self adapt: body convertToSloveneChars ensureUnicodeSloveneChars).
 	message addContentTransferEncoding: '8bit'.
	aFilenameString notNil ifTrue:
		["attachment := MimeEntity new."
		attachment fileName: aFilenameString; 
			contentType: ("MimeEntity mimeTypeForFile: aFilenameString" true).
		attachment body source: aContentString readStream. 
		attachment addContentTransferEncoding: '8bit'.
		message addPart: attachment].
	self queue nextPut: message.! !

!EMailMessenger methodsFor: 'sending'!
sendSubject: aSubjectString body: aBodyString attachFile: aFilename from: aPerson to: aPersonOrCollection
	"VW specific"
	| message receiverAddresses body |
	receiverAddresses := self emailAddressFor: aPersonOrCollection.
	receiverAddresses isEmpty ifTrue: [^nil].
	message := Net.MailMessage newTextPlain. 
	body := (ObjectMemory versionId at: 5) >= 76 "7.6?" 
		ifTrue: [aBodyString copyReplaceAll: (String with: Character cr) with: String crlf ] "why after 7.6?"
		ifFalse: [aBodyString].
	message 
		charset: 'UTF-8'; headerCharset: 'UTF-8'; 
		from: (self emailAddressFor: aPerson); 
		to: receiverAddresses; 
		subject: (self adapt: aSubjectString convertToSloveneChars);
		text: (self adapt: body convertToSloveneChars ensureUnicodeSloveneChars).
 	message addContentTransferEncoding: '8bit'.
	message addFileAttachment: aFilename .
	self queue nextPut: message.! !

!EMailMessenger methodsFor: 'sending'!
sendSubject: aSubjectString body: aBodyString from: aPerson to: aPersonOrCollection
	^self 
		sendSubject: aSubjectString body: aBodyString 
		attachFile: nil content: nil 
		from: aPerson to: aPersonOrCollection! !

!EMailMessenger methodsFor: 'sending'!
sendSubject: aSubjectString body: aBodyString icalName: anICalNameString content: anICalString from: aPerson to: aPersonOrCollection
	"VW specific"
	| message receiverAddresses body iCalString attachment |
	receiverAddresses := self emailAddressFor: aPersonOrCollection.
	receiverAddresses isEmpty ifTrue: [^nil].
	body := (ObjectMemory versionId at: 5) >= 76 "7.6?"  
			"SystemUtils version"  " SystemUtils.SystemVersionName"
		ifTrue: [aBodyString copyReplaceAll: (String with: Character cr) with: String crlf ] "why after 7.6?"
		ifFalse: [aBodyString].
	message := Net.MailMessage new. 
	message 
		charset: 'UTF-8'; headerCharset: 'UTF-8'; 
		from: (self emailAddressFor: aPerson); 
		to: receiverAddresses; 
		subject: (self adapt: aSubjectString convertToSloveneChars);
		text: (self adapt: body convertToSloveneChars ensureUnicodeSloveneChars).
 	message addContentTransferEncoding: 'base64' "'8bit'".
	anICalNameString notNil ifTrue:
		[attachment := Net.MimeEntity new.
		attachment 
"			fileName: anICalNameString; "
			contentType: ('text/calendar; method=REQUEST; charset=UTF-8; name=', 
				anICalNameString);
"			contentDisposition: 'attachment'. "
			contentDisposition: 'inline'. "Lotus Notes 6.5 requests inline, does not recognize attachment!! "
		iCalString := (ObjectMemory versionId at: 5) >= 76 "7.6?" 
			ifTrue: [anICalString copyReplaceAll: (String with: Character cr) with: String crlf ] "why after 7.6?"
			ifFalse: [anICalString].
		attachment body source: iCalString readStream. 
		attachment addContentTransferEncoding: '7bit'.
		message addPart: attachment].
	self queue nextPut: message.! !

!EMailMessenger methodsFor: 'private-sending'!
senderProcess
	[ [true] whileTrue: [self privSendMessage: self queue next reportError: #repeat] ] 
		on: Error do: [:ex | self halt]. "to find the cause of termination"! !

!EMailMessenger methodsFor: 'private-sending'!
sendingLoop
	"sender process"
	^sendingLoop! !

!EMailMessenger methodsFor: 'private-sending'!
sendingLoop: aProcess
	sendingLoop := aProcess! !

!EMailMessenger methodsFor: 'accessing'!
site
	^self repository site "temporary"! !

!EMailMessenger methodsFor: 'private'!
site: anAIDASite
	self repository: anAIDASite repository "temporary, to more easy migrate"! !

!EMailMessenger methodsFor: 'receiving' stamp: 'janko 8/8/2011 19:12'!
startReceiving
	"start receiving documents from e-mail account"
	| block doc |
"	self mailbox startFetchingMail. "
"temporary off, not yet migrated!! "	
"	self receivingLoop notNil ifTrue: [self stopReceiving].
	block := 
		[ [true] whileTrue: 
			[doc := self getMailDocument.
			self dealWithDocument: doc] ].
	self receivingLoop: block fork."! !

!EMailMessenger methodsFor: 'sending'!
startSending
	self initClient.
	self initSenderProcess.! !

!EMailMessenger methodsFor: 'receiving' stamp: 'janko 8/8/2011 16:48'!
stopReceiving
	self receivingLoop notNil ifTrue: [self receivingLoop terminate. self receivingLoop: nil].
"	self mailbox stopFetchingMail. "! !

!EMailMessenger methodsFor: 'sending'!
stopSending
	self sendingLoop notNil ifTrue: 
		[self sendingLoop terminate. 
		self sendingLoop: nil].
	client := nil.
"	queue := nil."! !

!EMailMessenger class methodsFor: 'instance creation' stamp: 'janko 8/8/2011 16:47'!
newOn: anAIDASite
	^super basicNew 
		site: anAIDASite! !

!FileProxy methodsFor: 'parsing' stamp: ' 21/4/07 22:07'!
absoluteTagFrom: aTagString urlStart: anURLString

	""

	| tag url |
	tag := (aTagString copyReplaceAll: '\' with: '/').
	((tag copyFrom: 1 to: 3) = '../')
		ifFalse:  "not relative to parent directory"
			[^((tag copyUpTo: $"), '"', anURLString, 
				(tag copyFrom: ((tag indexOf: $") + 1) to: tag size))]
		ifTrue:
			[tag := tag readStream upTo: $/; upToEnd.
			url := anURLString copyFrom: 1 to: (anURLString lastIndexOf: $/).
			^self absoluteTagFrom: tag urlStart: url].! !

!FileProxy methodsFor: 'accessing-timestamps' stamp: 'mivsek 8/22/2007 16:02'!
accessedTimestamp
	^self timestamps at: #accessed ifAbsent: [nil]! !

!FileProxy methodsFor: 'accessing'!
aidaContentType
	"MIME type of original content. 'unknown' if not known"
	contentType isNil ifTrue: [self aidaContentType: 'unknown'].
	^contentType.! !

!FileProxy methodsFor: 'private'!
aidaContentType: aMIMEString
	"MIME type of original content"
	contentType := aMIMEString.! !

!FileProxy methodsFor: 'testing' stamp: 'janko 4/25/2012 10:58'!
aidaIsRespondingStreamed
	"should we stream that file directly to TCP socket or not?"
	self content notNil ifTrue: [^false].  "cached content is sent faster without streaming"
	self aidaContentType = 'text/html' ifTrue: [^false]. "pure HTML files also not"
	^true! !

!FileProxy methodsFor: 'private-streaming'!
aidaPresenterFor: aRequest on: aSession 
	self fileStillExist ifFalse: [self removeYourself. ^WebPage new].
	(self content isNil and: [self aidaContentType = 'text/html' or: [self isToBeCached] ]) 
		ifTrue: [^self refreshContent]. 
	self hasFileChanged ifTrue: 
		[self refreshContent.
		self indexContent].
	^self! !

!FileProxy methodsFor: 'servlets'!
argumentsFrom: aMessageString

	^Array new: 0 "for now!! "! !

!FileProxy methodsFor: 'accessing-tags' stamp: ' 21/4/07 22:07'!
bodyTagIndex
	"index of element, which represent body tag in original html file"
	^bodyTagIndex! !

!FileProxy methodsFor: 'accessing-tags' stamp: ' 21/4/07 22:07'!
bodyTagIndex: anInteger
	"set the index of element, which represent body tag in original html file"
	bodyTagIndex := anInteger.! !

!FileProxy methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
clearElements
	elements := OrderedCollection new.! !

!FileProxy methodsFor: 'accessing-tags' stamp: ' 21/4/07 22:07'!
clearImgTagIndexes
	imgTagIndexes := OrderedCollection new.! !

!FileProxy methodsFor: 'accessing-tags' stamp: ' 21/4/07 22:07'!
clearLinkTagIndexes
	linkTagIndexes := OrderedCollection new.! !

!FileProxy methodsFor: 'accessing-tags' stamp: ' 21/4/07 22:07'!
clearServletTagIndexes
	servletTagIndexes := OrderedCollection new.! !

!FileProxy methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
codepage
	" #iso2 by default"
	codepage isNil ifTrue: [self codepage: #'iso-8859-2'].
	^codepage.! !

!FileProxy methodsFor: 'private' stamp: ' 21/4/07 22:07'!
codepage: aSymbol
	codepage := aSymbol.! !

!FileProxy methodsFor: 'accessing' stamp: 'jm 2/16/2011 23:43'!
content
	content isNil ifTrue: 
		[(self aidaContentType ~= 'text/html') 
			ifTrue: [self refreshContent] 
			ifFalse: [self content: ''] ].
	^content! !

!FileProxy methodsFor: 'private' stamp: ' 21/4/07 22:07'!
content: aString
	content := aString.! !

!FileProxy methodsFor: 'accessing-timestamps' stamp: 'mivsek 8/22/2007 16:02'!
createdTimestamp
	^self timestamps at: #created ifAbsent: [nil]! !

!FileProxy methodsFor: 'private' stamp: ' 21/4/07 22:07'!
detectCodepage: aString
	" "
	| win1250 iso2 sevenBit above127 |
	win1250 := 0.
	aString do: [:ch | (#(200 154 138 158 142) includes: ch asInteger) ifTrue: [win1250 := win1250+1] ].
	iso2 := 0.
	aString do: [:ch | (#(200 185 169 190 174) includes: ch asInteger) ifTrue: [iso2 := iso2+1] ].
	sevenBit := 0.
"	aString do: [:ch | (#(94 123 91 96 64) includes: ch asInteger) ifTrue: [sevenBit := sevenBit+1] ]."
	above127 := 0.
	aString do: [:ch | ch asInteger > 127 ifTrue: [above127 := above127+1] ].
	above127 = 0 
		ifTrue: [sevenBit ~= 0 ifTrue: [^#'7bit'] ifFalse: [^#csz] ]
		ifFalse: [iso2 > win1250 ifTrue: [^#'iso-8859-2'] ifFalse: [^#'win-1250'] ].! !

!FileProxy methodsFor: 'private' stamp: 'np 10/20/2008 13:53'!
elements

	"all elements (texts and tags) of a html page"

	elements isNil ifTrue: 
		[self clearElements.
"		(self contentType = 'text/html') ifTrue: [self refreshContent] "].
	^elements! !

!FileProxy methodsFor: 'accessing-timestamps' stamp: 'mivsek 8/22/2007 17:10'!
expiresTimestamp
	"for broswer: after 6 hours by default. It is good to reload from time to time 
	if changes were made "
	^SpTimestamp fromSeconds: (SpTimestamp now asSeconds + (6 * 3600))! !

!FileProxy methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
fileStillExist
	^self filename exists! !

!FileProxy methodsFor: 'accessing'!
filename
	| separator |
	separator := SpEnvironment onUnix ifTrue: ['/'] ifFalse: ['\'].
	(filename isKindOf: SpFilename) ifTrue: [self filename: filename].
	filename isNil ifTrue: [^''].
	SpEnvironment onUnix   "needed in case of migration to other OS"
		ifTrue: [(filename includes: $\ ) ifTrue: 
			[filename := filename copyReplaceAll: '\' with: '/'] ]
		ifFalse: [(filename includes: $/ ) ifTrue: 
			[filename := filename copyReplaceAll: '/' with: '\'] ].
	^SpFilename named:
		(self site homeDirectory, 
			(filename 
				copyReplaceAll: (self site homeDirectory copyReplaceAll: '.', separator with: '')
				with: ''))! !

!FileProxy methodsFor: 'private' stamp: 'janko 3/22/2008 13:20'!
filename: aFilename
	filename := aFilename asString.
	self site notNil ifTrue: 
		[filename := filename copyReplaceAll: self site homeDirectory with: ''].! !

!FileProxy methodsFor: 'initialize-release'!
from: aString
	| file relFilename |
	self releaseContent. "if any from before"
	file := SpFilename named: aString. file exists ifFalse: [^nil].
	relFilename := (file asString copyReplaceAll: self site homeDirectory with: '').
	self filename: (relFilename isEmpty ifTrue: ['\'] ifFalse: [relFilename]).
	self refreshTimestamps.
	self aidaContentType: (self site mimeMap typeForExtension: file extension).
	self size: file fileSize.
	self aidaContentType = 'text/html' 
		ifTrue:
			[self content: file contentsOfEntireFile.
			self codepage: #utf8. "(self detectCodepage: self content)."
"			self content: (AIDASite convert: self content fromCodepage: self codepage). "
			self setSize
			"self prepareHTMLPage. self makeAbsoluteImgTags. self content: nil"]
		ifFalse: 
			[self isToBeCached ifTrue:  "otherwise we will stream directly"
				[| stream | 
				[stream := file readStream binary. self content: stream contents] ensure: [stream close] ] ]! !

!FileProxy methodsFor: 'testing' stamp: 'mivsek 8/22/2007 17:07'!
hasFileChanged
	"check if original file changed since last visit"
	^self modifiedTimestamp ~= self filename modifiedTimestamp.! !

!FileProxy methodsFor: 'accessing-tags' stamp: ' 21/4/07 22:07'!
imgTagIndexes
	"indexes of elements, which represent image tags in original html file"
	imgTagIndexes isNil ifTrue: [self clearImgTagIndexes].
	^imgTagIndexes! !

!FileProxy methodsFor: 'indexing'!
indexContent
	"index text in server global index"
	self aidaContentType = 'text/html' ifTrue: [self site index indexObject: self]! !

!FileProxy methodsFor: 'indexing' stamp: ' 21/4/07 22:07'!
indexText
	"pure text, without tags, for indexer"
	| stream bodyStart element text |
	bodyStart := (1 to: self elements size) 
		detect: [:index | '<BODY*' match: (self elements at: index)] ifNone: [1].
	stream := WriteStream on: String new.
	bodyStart + 1 to: self elements size do:  [:index | 
		element := self elements at: index.
		(element notEmpty and: [element first ~= $<]) ifTrue: [stream nextPutAll: element] ].
	text := stream contents "copyReplaceAll: WebElement new eol with: ' '". 
	text := text copyReplaceAll: '&nbsp;' with: ' '.
	^text! !

!FileProxy methodsFor: 'indexing' stamp: ' 21/4/07 22:07'!
indexTitle
	"find title, if noone, then return url"
	1 to: self elements size do: [:index |
		('<TITLE*' match: (self elements at: index)) ifTrue: [^self elements at: index+1] ].
	^self site urlResolver halfUrlFor: self! !

!FileProxy methodsFor: 'testing' stamp: 'jm 2/16/2011 23:31'!
isCaching
	"should this file be always cached?"
	caching isNil ifTrue: [self resetCaching].
	^caching! !

!FileProxy methodsFor: 'testing' stamp: 'jm 2/16/2011 23:30'!
isToBeCached
	"cache this file or not?"
	^self isCaching or: [self size < self sizeToCache]! !

!FileProxy methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebElement
	^false! !

!FileProxy methodsFor: 'testing' stamp: ' 21/8/07 09:38'!
isWebPage
	^true "not actually, but let pretend it is"! !

!FileProxy methodsFor: 'accessing-tags' stamp: ' 21/4/07 22:07'!
linkTagIndexes
	"indexes of elements, which represent link tags in original html file"
	linkTagIndexes isNil ifTrue: [self clearLinkTagIndexes].
	^linkTagIndexes! !

!FileProxy methodsFor: 'parsing' stamp: 'mivsek 1/10/2008 19:16'!
makeAbsoluteImgTags
	"if image url's are relative, make them absolute. Also do it for a body tag (background image). 
	Url is constructed from a imageServer address from WebServer settings, and from filename with 	homeDirectory substracted. "
	| fname urlStart index tag bodyTag |
	fname := (self filename asString) copyReplaceAll: (self site homeDirectory) with: ''.
	fname := fname copyFrom: 1 to: (fname lastIndexOf: (AIDASite slash at: 1)).
	urlStart := 'http://', self site host, (fname copyReplaceAll: '\' with: '/').
	self imgTagIndexes do: [:inx  | tag := self elements at: inx.
		('*http://*' match: tag) ifFalse:    "not an absolute source url"
			[self elements at: inx put: (self absoluteTagFrom: tag urlStart: urlStart)] ].
	self bodyTagIndex notNil ifTrue:
		[bodyTag := self elements at: bodyTagIndex.
		(('*background*' match:  bodyTag) and: [('*http://*' match:  bodyTag) not]) 
			ifTrue: 
				[index := bodyTag asLowercase findString: 'background' startingAt: 1.
				index := bodyTag findString: '"' startingAt: index.
				(( bodyTag at: index+1) = $#) ifTrue: [^self]. "only colored background"
				self elements at: bodyTagIndex put:
					((bodyTag copyFrom: 1 to: index), urlStart, 
						(bodyTag copyFrom: index + 1 to: bodyTag size)) ] ].! !

!FileProxy methodsFor: 'servlets'!
methodFrom: aMessageString

	^aMessageString asSymbol "for now!! "! !

!FileProxy methodsFor: 'accessing-timestamps' stamp: 'mivsek 8/22/2007 16:01'!
modifiedTimestamp
	^self timestamps at: #modified ifAbsent: [nil]! !

!FileProxy methodsFor: 'parsing' stamp: ' 21/8/07 09:38'!
prepareHTMLPage
	"decompose content into elements (texts and tags)"
	| stream tag index |
	self clearElements. self clearImgTagIndexes. 
	self clearLinkTagIndexes. self clearServletTagIndexes.
	stream := ReadStream on: self content.
	index := 1.
	[stream atEnd] whileFalse:
		[self elements add: (stream upTo: $<). index := index + 1.
		tag := ('<', (stream upTo: $>), '>').
		('<aida*' match: tag) ifTrue: [self servletTagIndexes add: index].
		('*img*' match: tag) ifTrue: [self imgTagIndexes add: index].
		('*href*' match: tag) 
			ifTrue: [self linkTagIndexes add: index]
			ifFalse: 
				[(('*body*' match: tag) and: [('*/body*' match: tag) not])
					ifTrue: [self bodyTagIndex: index]].
		self elements add: tag. index := index + 1.
		].! !

!FileProxy methodsFor: 'parsing'!
prepareHtmlPage
	"decompose content into elements (texts and tags)"
	| stream tag index |
	self clearElements. self clearImgTagIndexes. 
	self clearLinkTagIndexes. self clearServletTagIndexes.
	stream := ReadStream on: self content.
	index := 1.
	[stream atEnd] whileFalse:
		[self elements add: (stream upTo: $<). index := index + 1.
		tag := ('<', (stream upTo: $>), '>').
		('<aida*' match: tag) ifTrue: [self servletTagIndexes add: index].
		('*img*' match: tag) ifTrue: [self imgTagIndexes add: index].
		('*href*' match: tag) 
			ifTrue: [self linkTagIndexes add: index]
			ifFalse: 
				[(('*body*' match: tag) and: [('*/body*' match: tag) not])
					ifTrue: [self bodyTagIndex: index]].
		self elements add: tag. index := index + 1.
		].! !

!FileProxy methodsFor: 'private'!
printString
	^('aFileProxy for: ', self filename asString)! !

!FileProxy methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
put: aString
	"replace self with contents in aString from PUT request"
	self content: aString.
	self writeToFile! !

!FileProxy methodsFor: 'initialize-release' stamp: 'np 10/20/2008 13:44'!
refreshContent
	self releaseContent. "in case we switch from cached to non cached because of size change"
	self from: self filename asString.! !

!FileProxy methodsFor: 'private' stamp: 'mivsek 8/22/2007 16:34'!
refreshTimestamps
	self timestamps at: #created put: self filename createdTimestamp.
	self timestamps at: #modified put: self filename modifiedTimestamp.! !

!FileProxy methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
releaseContent
	"release origContent and elements to save memory"
	content := nil.
	elements := nil.! !

!FileProxy methodsFor: 'private'!
removeYourself
	"remove from url resolver and elsewhere"
	self releaseContent.
	self site urlResolver removeObject: self.
	self fileStillExist ifTrue: [self filename delete]! !

!FileProxy methodsFor: 'accessing' stamp: 'jm 2/16/2011 23:33'!
resetCaching
	"don't cahce this file,except if it is smallter than "
	caching := false! !

!FileProxy methodsFor: 'servlets'!
servletPerform: aMessageString on: aWebApp

	| method |
	method := (self methodFrom: aMessageString).
	(aWebApp class canUnderstand: method) ifFalse: [^nil].
	^aWebApp
		perform: method
		withArguments: (self argumentsFrom: aMessageString).! !

!FileProxy methodsFor: 'accessing-tags' stamp: ' 21/4/07 22:07'!
servletTagIndexes
	"indexes of elements, which represent servlet in original html file"
	servletTagIndexes isNil ifTrue: [self clearServletTagIndexes].
	^servletTagIndexes! !

!FileProxy methodsFor: 'accessing' stamp: 'jm 2/16/2011 23:33'!
setCaching
	"this file should always be cached, regardless of size"
	caching := true! !

!FileProxy methodsFor: 'private' stamp: ' 21/8/07 09:38'!
setSize
	"size of content in bytes"
	(self elements notEmpty)
		ifTrue: [self size: (self elements inject: 0 into: [:sum : e | sum + e size]) ]
		ifFalse: [self size: self content size]! !

!FileProxy methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
site
	^site! !

!FileProxy methodsFor: 'private' stamp: ' 21/4/07 22:07'!
site: anAIDASite
	site := anAIDASite.! !

!FileProxy methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
size
	"size of content"
	size isNil ifTrue: [self setSize].
	^size! !

!FileProxy methodsFor: 'private' stamp: ' 21/8/07 09:38'!
size: anInteger
	size := anInteger! !

!FileProxy methodsFor: 'testing' stamp: 'mivsek 2/10/2008 15:53'!
sizeAboveMark

	"test if content is above specified size"
	^self size > (5 * 1024) "bytes" "5KB"! !

!FileProxy methodsFor: 'accessing' stamp: 'jm 2/16/2011 23:34'!
sizeToCache
	"file size below which files are always cached"
	^(5 * 1024) "bytes" "5KB"! !

!FileProxy methodsFor: 'private-streaming' stamp: 'janko 3/19/2012 14:24'!
streamFileToResponse: aHTTPStreamedResponse
	| stream | 
	[stream := self filename asFilename readStream binary. 
	[stream atEnd] whileFalse: [aHTTPStreamedResponse nextPut: stream next] ] 
		ensure: [stream close]! !

!FileProxy methodsFor: 'private' stamp: ' 21/4/07 22:07'!
timestamps
	timestamps isNil ifTrue: [self timestamps: Dictionary new.].
	^timestamps! !

!FileProxy methodsFor: 'private' stamp: ' 21/4/07 22:07'!
timestamps: aDictionary
	" a dictionary with a DateAndTime at: 
	#accessed #modified #statusChanged #created"
	timestamps := aDictionary.! !

!FileProxy methodsFor: 'private' stamp: ' 21/4/07 22:07'!
writeToFile
	| stream |
	[stream := self filename writeStream. stream binary.
	stream nextPutAll: self content]
		ensure: [stream close].
	self refreshTimestamps.! !

!FileProxy class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
from: aFilenameString onSite: aSite
	"read a file and make a HTML proxy of it. Return nil, if file does not exist or cannot be opened. 
	Also record a server for which you make a proxy"
	| proxy |
	proxy := self new site: aSite; from: aFilenameString.
	proxy indexContent.
	^proxy! !

!Float methodsFor: '*Aida' stamp: 'janko 8/3/2011 19:14'!
asScaledDecimal: aScaleInteger
	^ScaledDecimal  newFromNumber: self scale: aScaleInteger! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checkCodeSize
	(freeCode > maxCode and: [codeSize < 12])
		ifTrue:
			[codeSize := codeSize + 1.
			maxCode := (1 bitShift: codeSize) - 1]! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
colorValueFrom: rgbInteger 
	| scalingValue |
	scalingValue := ColorValue scalingValue.
	^ColorValue
		scaledRed: (self
				convertValue: ((rgbInteger bitShift: -16)
						bitAnd: 255)
				from: 255
				to: scalingValue)
		scaledGreen: (self
				convertValue: ((rgbInteger bitShift: -8)
						bitAnd: 255)
				from: 255
				to: scalingValue)
		scaledBlue: (self
				convertValue: (rgbInteger bitAnd: 255)
				from: 255
				to: scalingValue)! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
convertToCoverageWithTransparentPixel: pixelValue with: anImage 
	| image row |
	image := Image
				extent: anImage extent
				depth: 1
				palette: CoveragePalette monoMaskPalette.
	0 to: anImage height - 1
		do: 
			[:i | 
			row := anImage rowAt: i.
			row := row collect: [:p | p = pixelValue
							ifTrue: [0]
							ifFalse: [1]].
			image rowAt: i putAll: row].
	^image! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
convertToGray: coverageValue 
	coverageValue = CoverageValue transparent ifTrue: [^ColorValue white].
	coverageValue = CoverageValue opaque ifTrue: [^ColorValue black].
	^ColorValue brightness: coverageValue coverage! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
convertToMappedPalette: coveragePalette 
	coveragePalette size = 2 ifTrue: [^MappedPalette whiteBlack].
	^MappedPalette withColors: (coveragePalette collect: [:coverage | self convertToGray: coverage])! !

!GifImageStream methodsFor: 'packing' stamp: ' 21/4/07 22:07'!
fillBuffer
	| packSize |
	packSize := self next.
	bufStream := ReadStream on: (self next: packSize)! !

!GifImageStream methodsFor: 'bits access' stamp: ' 21/4/07 22:07'!
flushBits
	remainBitCount = 0
		ifFalse: 
			[self nextBytePut: bufByte.
			remainBitCount := 0].
	self flushBuffer! !

!GifImageStream methodsFor: 'packing' stamp: ' 21/4/07 22:07'!
flushBuffer
	bufStream isEmpty ifTrue: [^self].
	self nextPut: bufStream size.
	self nextPutAll: bufStream contents.
	bufStream := WriteStream on: (ByteArray new: 256)! !

!GifImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
flushCode
	self flushBits! !

!GifImageStream methodsFor: 'bits access' stamp: ' 21/4/07 22:07'!
nextBits
	| integer readBitCount shiftCount |
	integer := 0.
	remainBitCount = 0
		ifTrue: 
			[readBitCount := 8.
			shiftCount := 0]
		ifFalse: 
			[readBitCount := remainBitCount.
			shiftCount := remainBitCount - 8].
	[readBitCount < codeSize]
		whileTrue: 
			[self peekByte isNil ifTrue: [^eoiCode].
			integer := integer + (self nextByte bitShift: shiftCount).
			shiftCount := shiftCount + 8.
			readBitCount := readBitCount + 8].
	self peekByte isNil ifTrue: [^eoiCode].
	(remainBitCount := readBitCount - codeSize) = 0
		ifTrue: [integer := integer + (self nextByte bitShift: shiftCount)]
		ifFalse: [integer := integer + (self peekByte bitShift: shiftCount)].
	^integer bitAnd: maxCode! !

!GifImageStream methodsFor: 'bits access' stamp: ' 21/4/07 22:07'!
nextBitsPut: anInteger 
	| integer writeBitCount shiftCount |
	shiftCount := 0.
	remainBitCount = 0
		ifTrue: 
			[writeBitCount := 8.
			integer := anInteger]
		ifFalse: 
			[writeBitCount := remainBitCount.
			integer := bufByte + (anInteger bitShift: 8 - remainBitCount)].
	[writeBitCount < codeSize]
		whileTrue: 
			[self nextBytePut: ((integer bitShift: shiftCount)
					bitAnd: 255).
			shiftCount := shiftCount - 8.
			writeBitCount := writeBitCount + 8].
	(remainBitCount := writeBitCount - codeSize) = 0
		ifTrue: [self nextBytePut: (integer bitShift: shiftCount)]
		ifFalse: [bufByte := integer bitShift: shiftCount].
	^anInteger! !

!GifImageStream methodsFor: 'packing' stamp: ' 21/4/07 22:07'!
nextByte
	bufStream atEnd
		ifTrue:
			[self atEnd ifTrue: [^nil].
			self fillBuffer].
	^bufStream next! !

!GifImageStream methodsFor: 'packing' stamp: ' 21/4/07 22:07'!
nextBytePut: aByte
	bufStream nextPut: aByte.
	bufStream size >= 254 ifTrue: [self flushBuffer]! !

!GifImageStream methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nextImage
	| bits depth image |
	self readHeader isNil ifTrue: [^nil].
	bits := self readBitData.
	depth := bitsPerPixel > 8
				ifTrue: [^self error: 'unexpected bits per pixel']
				ifFalse: [bitsPerPixel = 1
						ifTrue: [1]
						ifFalse: [bitsPerPixel = 2
								ifTrue: [2]
								ifFalse: [bitsPerPixel <= 4
										ifTrue: [4]
										ifFalse: [8]]]].
	depth < 8 ifTrue: [bits := self
					packBits: bits
					depthFrom8To: depth
					width: width
					height: height
					pad: 8].
	image := Image
				extent: width @ height
				depth: depth
				palette: colorPalette
				bits: bits
				pad: 8.
	transparentPixel notNil ifTrue: [image := OpaqueImage figure: image shape: (CachedImage on: (self convertToCoverageWithTransparentPixel: transparentPixel with: image) asRetainedMedium)].
	^image! !

!GifImageStream methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nextPutImage: anImage 
	| theImage trueBitsPerPixel achievableBitsPerPixel bits |
	(anImage isKindOf: Image)
		ifFalse: [^self errorCanNotWrite].
	anImage bitsPerPixel > 8
		ifTrue: [theImage := anImage convertToPalette: self class colorPalette256 "renderedBy: ErrorDiffusion new"]
		ifFalse: [theImage := anImage].
	width := theImage width.
	height := theImage height.
	colorPalette := theImage palette.
	trueBitsPerPixel := theImage bitsPerPixel.
	achievableBitsPerPixel := 2 raisedTo: ((colorPalette size - 1) highBit - 1) highBit.
	bitsPerPixel := achievableBitsPerPixel.
	colorPalette := theImage palette.
	colorPalette paintBasis == CoverageValue
		ifTrue: 
			[transparentPixel := 0.
			colorPalette := self convertToMappedPalette: colorPalette].
	bits := theImage bits.
	trueBitsPerPixel < 8 ifTrue: [bits := self
					unpackBits: bits
					depthTo8From: bitsPerPixel
					width: theImage width
					height: theImage height
					pad: 32].
	interlace := true.
	
	[self writeHeader.
	self writeBitData: bits]
		valueNowOrOnUnwindDo: [self close].
	^theImage! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
packBits: bits depthFrom8To: depth width: xSize height: ySize pad: pad 
	| maxPixelVal pixelInByte bitsWidth pBitsWidth pBits |
	(#(1 2 4) includes: depth)
		ifFalse: [^self error: 'depth must be 1, 2, or 4'].
	(#(8 16 32) includes: pad)
		ifFalse: [^self error: 'pad must be 8, 16, or 32'].
	maxPixelVal := (1 bitShift: depth)
				- 1.
	pixelInByte := 8 / depth.
	bitsWidth := xSize * 8 + pad - 1 // pad * (pad / 8).
	pBitsWidth := xSize * depth + pad - 1 // pad * (pad / 8).
	pBits := ByteArray new: pBitsWidth * ySize.
	1 to: ySize
		do: 
			[:i | 
			| bitIndex pBitIndex pixelVal count |
			bitIndex := i - 1 * bitsWidth.
			pBitIndex := i - 1 * pBitsWidth.
			pixelVal := 0.
			count := 0.
			1 to: xSize
				do: 
					[:j | 
					| val |
					val := bits at: (bitIndex := bitIndex + 1).
					val > maxPixelVal ifTrue: [^self error: 'can''t pack bits'].
					pixelVal := (pixelVal bitShift: depth)
								+ val.
					(count := count + 1) >= pixelInByte
						ifTrue: 
							[pBits at: (pBitIndex := pBitIndex + 1) put: pixelVal.
							pixelVal := 0.
							count := 0]].
			count > 0 ifTrue: [pBits at: (pBitIndex := pBitIndex + 1) put: (pixelVal bitShift: depth * (pixelInByte - count))]].
	^pBits! !

!GifImageStream methodsFor: 'packing' stamp: ' 21/4/07 22:07'!
peekByte
	bufStream atEnd
		ifTrue:
			[self atEnd ifTrue: [^nil].
			self fillBuffer].
	^bufStream peek! !

!GifImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readBitData
	| bits outCodes outCount bitMask initCodeSize code curCode oldCode inCode finChar set |
	pass := 0.
	xpos := 0.
	ypos := 0.
	rowByteSize := width * 8 + 7 // 8.
	remainBitCount := 0.
	bufByte := 0.
	bufStream := ReadStream on: ByteArray new.
	bits := ByteArray new: width * height.
	outCodes := ByteArray new: 1025.
	outCount := 0.
	bitMask := (1 bitShift: bitsPerPixel)
				- 1.
	prefixTable := Array new: 4096.
	suffixTable := Array new: 4096.
	initCodeSize := self next.
	self setParameters: initCodeSize.
	set := Set new: height.
	self progress: set size / height.
	[(code := self readCode) = eoiCode]
		whileFalse: [code = clearCode
				ifTrue: 
					[self setParameters: initCodeSize.
					curCode := oldCode := code := self readCode.
					finChar := curCode bitAnd: bitMask.
					set add: ypos.
					self progress: set size / height.
					self writePixel: finChar to: bits]
				ifFalse: 
					[curCode := inCode := code.
					curCode >= freeCode
						ifTrue: 
							[curCode := oldCode.
							outCodes at: (outCount := outCount + 1) put: finChar].
					[curCode > bitMask]
						whileTrue: 
							[outCount > 1024 ifTrue: [^self error: 'corrupt GIF file (OutCount)'].
							outCodes at: (outCount := outCount + 1) put: (suffixTable at: curCode + 1).
							curCode := prefixTable at: curCode + 1].
					finChar := curCode bitAnd: bitMask.
					outCodes at: (outCount := outCount + 1) put: finChar.
					outCount
						to: 1
						by: -1
						do: 
							[:i | 
							set add: ypos.
							self progress: set size / height.
							self writePixel: (outCodes at: i)
								to: bits].
					outCount := 0.
					prefixTable at: freeCode + 1 put: oldCode.
					suffixTable at: freeCode + 1 put: finChar.
					oldCode := inCode.
					freeCode := freeCode + 1.
					self checkCodeSize]].
	prefixTable := suffixTable := nil.
	^bits! !

!GifImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readCode
	^self nextBits! !

!GifImageStream methodsFor: 'GIF89a' stamp: ' 21/4/07 22:07'!
readExtension
	| label |
	label := self next.
	label == GraphicControlLabel
		ifTrue: [self readGraphicControlExtensionBlock]
		ifFalse: [self error: 'unsupported extension block']! !

!GifImageStream methodsFor: 'GIF89a' stamp: ' 21/4/07 22:07'!
readGraphicControlExtensionBlock
	| isTransparent |
	self next.
	isTransparent := (self next bitAnd: 1)
				= 1.
	self next: 2.
	isTransparent
		ifTrue: [transparentPixel := self next]
		ifFalse: [self next].
	self next! !

!GifImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readHeader
	| byte hasColorMap |
	((self hasMagicNumber: 'GIF89a' asByteArray)
		or: [self hasMagicNumber: 'GIF87a' asByteArray])
		ifFalse: [^self errorCanNotRead].
	self readWord.
	self readWord.
	byte := self next.
	hasColorMap := (byte bitAnd: 128)
				~= 0.
	bitsPerPixel := (byte bitAnd: 7)
				+ 1.
	byte := self next.
	byte := self next.
	hasColorMap
		ifTrue: 
			[| array |
			array := Array new: (1 bitShift: bitsPerPixel).
			1 to: array size do: [:i | array at: i put: (self colorValueFrom: (self next bitShift: 16)
							+ (self next bitShift: 8) + self next)].
			colorPalette := MappedPalette withColors: array]
		ifFalse: 
			[Transcript cr; show: 'GIF file does not have a color map.'.
			colorPalette := MappedPalette monochromeDefault].
	
	[byte := self next.
	byte == Extension]
		whileTrue: [self readExtension].
	byte = ImageSeparator ifFalse: [^self error: 'corrupt GIF file (nosep)'].
	self readWord.
	self readWord.
	width := self readWord.
	height := self readWord.
	interlace := (self next bitAnd: 64)
				~= 0! !

!GifImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
readPixelFrom: bits
	| pixel |
	ypos >= height ifTrue: [^nil].
	pixel := bits at: (ypos * rowByteSize + xpos + 1).
	self updatePixelPosition.
	^pixel! !

!GifImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
readWord
	^self next + (self next bitShift: 8)! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
rgbIntegerArrayFor: aPalette 
	| colors |
	colors := Array new: aPalette maxIndex + 1.
	1 to: colors size do: [:i | colors at: i put: (self rgbIntegerFrom: (aPalette at: i - 1 ifAbsent: [ColorValue white]))].
	^colors! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
rgbIntegerFrom: aColorValue 
	| scalingValue |
	scalingValue := ColorValue scalingValue.
	^((self
		convertValue: aColorValue scaledRed
		from: scalingValue
		to: 255)
		bitShift: 16)
		+ ((self
				convertValue: aColorValue scaledGreen
				from: scalingValue
				to: 255)
				bitShift: 8) + (self
			convertValue: aColorValue scaledBlue
			from: scalingValue
			to: 255)! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
setParameters: initCodeSize
	clearCode := 1 bitShift: initCodeSize.
	eoiCode := clearCode + 1.
	freeCode := clearCode + 2.
	codeSize := initCodeSize + 1.
	maxCode := (1 bitShift: codeSize) - 1! !

!GifImageStream methodsFor: 'GIF89a' stamp: ' 21/4/07 22:07'!
transparentPixel: aPixelValueOrNil 
	transparentPixel := aPixelValueOrNil! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
unpackBits: bits depthTo8From: depth width: xSize height: ySize pad: pad 
	| bitMask pixelInByte bitsWidth upBitsWidth stopWidth trailingSize upBits |
	(#(1 2 4) includes: depth)
		ifFalse: [^self error: 'depth must be 1, 2, or 4'].
	(#(8 16 32) includes: pad)
		ifFalse: [^self error: 'pad must be 8, 16, or 32'].
	bitMask := (1 bitShift: depth)
				- 1.
	pixelInByte := 8 / depth.
	bitsWidth := xSize * depth + pad - 1 // pad * (pad / 8).
	upBitsWidth := xSize * 8 + pad - 1 // pad * (pad / 8).
	stopWidth := xSize * depth + 7 // 8.
	trailingSize := xSize - (stopWidth - 1 * pixelInByte).
	upBits := ByteArray new: upBitsWidth * ySize.
	1 to: ySize
		do: 
			[:i | 
			| bitIndex upBitIndex val |
			bitIndex := i - 1 * bitsWidth.
			upBitIndex := i - 1 * upBitsWidth.
			1 to: stopWidth - 1
				do: 
					[:j | 
					val := bits at: (bitIndex := bitIndex + 1).
					upBitIndex := upBitIndex + pixelInByte.
					1 to: pixelInByte
						do: 
							[:k | 
							upBits at: upBitIndex - k + 1 put: (val bitAnd: bitMask).
							val := val bitShift: depth negated]].
			val := (bits at: (bitIndex := bitIndex + 1))
						bitShift: depth negated * (pixelInByte - trailingSize).
			upBitIndex := upBitIndex + trailingSize.
			1 to: trailingSize
				do: 
					[:k | 
					upBits at: upBitIndex - k + 1 put: (val bitAnd: bitMask).
					val := val bitShift: depth negated]].
	^upBits! !

!GifImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
updatePixelPosition
	(xpos := xpos + 1) >= width ifFalse: [^self].
	xpos := 0.
	interlace
		ifFalse: 
			[ypos := ypos + 1.
			^self].
	pass = 0
		ifTrue: 
			[(ypos := ypos + 8) >= height
				ifTrue: 
					[pass := pass + 1.
					ypos := 4].
			^self].
	pass = 1
		ifTrue: 
			[(ypos := ypos + 8) >= height
				ifTrue: 
					[pass := pass + 1.
					ypos := 2].
			^self].
	pass = 2
		ifTrue: 
			[(ypos := ypos + 4) >= height
				ifTrue: 
					[pass := pass + 1.
					ypos := 1].
			^self].
	pass = 3
		ifTrue: 
			[ypos := ypos + 2.
			^self].
	^self error: 'can''t happen'! !

!GifImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeBitData: bits 
	| maxBits maxMaxCode tSize initCodeSize ent tShift fCode pixel set |

	pass := 0.
	xpos := 0.
	ypos := 0.
	rowByteSize := width * 8 + 31 // 32 * 4.
	remainBitCount := 0.
	bufByte := 0.
	bufStream := WriteStream on: (ByteArray new: 256).
	maxBits := 12.
	maxMaxCode := 1 bitShift: maxBits.
	tSize := 5003.
	prefixTable := Array new: tSize.
	suffixTable := Array new: tSize.
	initCodeSize := bitsPerPixel <= 1
				ifTrue: [2]
				ifFalse: [bitsPerPixel].
	self nextPut: initCodeSize.
	self setParameters: initCodeSize.
	tShift := 0.
	fCode := tSize.
	[fCode < 65536]
		whileTrue: 
			[tShift := tShift + 1.
			fCode := fCode * 2].
	tShift := 8 - tShift.
	1 to: tSize do: [:i | suffixTable at: i put: -1].

"	set := Set new: height.
	self progress: set size / height.
	set add: ypos. 
	self progress: set size / height."

	self writeCodeAndCheckCodeSize: clearCode.
	ent := self readPixelFrom: bits.
	[(pixel := self readPixelFrom: bits) == nil]
		whileFalse: 
			[| index disp nomatch |

"			set add: ypos. 
			self progress: set size / height."

			fCode := (pixel bitShift: maxBits)
						+ ent.
			index := ((pixel bitShift: tShift)
						bitXor: ent)
						+ 1.
			(suffixTable at: index)
				= fCode
				ifTrue: [ent := prefixTable at: index]
				ifFalse: 
					[nomatch := true.
					(suffixTable at: index)
						>= 0
						ifTrue: 
							[disp := tSize - index + 1.
							index = 1 ifTrue: [disp := 1].
							
							[(index := index - disp) < 1 ifTrue: [index := index + tSize].
							(suffixTable at: index)
								= fCode
								ifTrue: 
									[ent := prefixTable at: index.
									nomatch := false].
							nomatch and: [(suffixTable at: index)
									> 0]] whileTrue].
					nomatch
						ifTrue: 
							[self writeCodeAndCheckCodeSize: ent.
							ent := pixel.
							freeCode < maxMaxCode
								ifTrue: 
									[prefixTable at: index put: freeCode.
									suffixTable at: index put: fCode.
									freeCode := freeCode + 1]
								ifFalse: 
									[self writeCodeAndCheckCodeSize: clearCode.
									1 to: tSize do: [:i | suffixTable at: i put: -1].
									self setParameters: initCodeSize]]].
"			set add: ypos. 
			self progress: set size / height"].

	prefixTable := suffixTable := nil.
	self writeCodeAndCheckCodeSize: ent.
	self writeCodeAndCheckCodeSize: eoiCode.
	self flushCode.
	self nextPut: 0.
	self nextPut: Terminator! !

!GifImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeCode: aCode
	self nextBitsPut: aCode! !

!GifImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeCodeAndCheckCodeSize: aCode
	self writeCode: aCode.
	self checkCodeSize! !

!GifImageStream methodsFor: 'GIF89a' stamp: ' 21/4/07 22:07'!
writeGraphicControlExtensionBlock
	self nextPut: Extension.
	self nextPut: GraphicControlLabel.
	self nextPut: 4.
	transparentPixel notNil
		ifTrue: [self nextPut: 1]
		ifFalse: [self nextPut: 0].
	self nextPut: 0.
	self nextPut: 0.
	transparentPixel notNil
		ifTrue: [self nextPut: transparentPixel]
		ifFalse: [self nextPut: 0].
	self nextPut: 0! !

!GifImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeHeader
	| byte array |
	self nextPutAll: 'GIF89a' asByteArray.
	self writeWord: width.
	self writeWord: height.
	byte := 128.
	byte := byte bitOr: (bitsPerPixel - 1 bitShift: 5).
	byte := byte bitOr: bitsPerPixel - 1.
	self nextPut: byte.
	self nextPut: 0.
	self nextPut: 0.
	array := self rgbIntegerArrayFor: colorPalette.
	array do: [:rgb | self nextPut: ((rgb bitShift: -16)
				bitAnd: 255); nextPut: ((rgb bitShift: -8)
				bitAnd: 255); nextPut: (rgb bitAnd: 255)].
	array size + 1 to: (1 bitShift: bitsPerPixel)
		do: [:i | self nextPut: 0; nextPut: 0; nextPut: 0].
	transparentPixel notNil ifTrue: [self writeGraphicControlExtensionBlock].
	self nextPut: ImageSeparator.
	self writeWord: 0.
	self writeWord: 0.
	self writeWord: width.
	self writeWord: height.
	byte := interlace
				ifTrue: [64]
				ifFalse: [0].
	self nextPut: byte! !

!GifImageStream methodsFor: 'decoding' stamp: ' 21/4/07 22:07'!
writePixel: pixel to: bits 
	bits at: ypos * rowByteSize + xpos + 1 put: pixel.
	self updatePixelPosition! !

!GifImageStream methodsFor: 'encoding' stamp: ' 21/4/07 22:07'!
writeWord: aWord 
	self nextPut: (aWord bitAnd: 255).
	self nextPut: ((aWord bitShift: -8)
			bitAnd: 255).
	^aWord! !

!GifImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
copyright
	^'Copyright (C) 1995-1998 AOKI Atsushi, All Rights Reserved.'! !

!GifImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example1
	"GifImageStream example1."

	| image filename stream |
	image := Image fromUser.
	filename := 'zzz.gif' asFilename.
	stream := GifImageStream on: filename writeStream.
	[Cursor write showWhile: [stream nextPutImage: image]]
		valueNowOrOnUnwindDo: [stream close].
	^image! !

!GifImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example2
	"GifImageStream example2."

	| filename stream image |
	filename := 'zzz.gif' asFilename.
	stream := GifImageStream on: filename readStream.
	[Cursor read showWhile: [image := stream nextImage]]
		valueNowOrOnUnwindDo: [stream close].
	stream show: image.
	^image! !

!GifImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example3
	"GifImageStream example3."

	| image filename stream |
	image := Image fromUser.
	filename := 'zzz.gif' asFilename.
	stream := GifImageStream on: filename writeStream.
	[Cursor write
		showWhile: 
			[stream compute: [:value | Transcript cr; show: value printString].
			stream nextPutImage: image]]
		valueNowOrOnUnwindDo: [stream close].
	^image! !

!GifImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example4
	"GifImageStream example4."

	| filename stream image |
	filename := 'zzz.gif' asFilename.
	stream := GifImageStream on: filename readStream.
	[Cursor read
		showWhile: 
			[stream compute: [:value | Transcript cr; show: value printString].
			image := stream nextImage]]
		valueNowOrOnUnwindDo: [stream close].
	stream show: image.
	^image! !

!GifImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example5
	"GifImageStream example5."

	| image filename stream progress |
	image := Image fromUser.
	filename := 'zzz.gif' asFilename.
	stream := GifImageStream on: filename writeStream.
	[Cursor write
		showWhile: 
			[progress := Progress new.
			stream compute: [:value | progress value: value].
			progress message: 'writing gif...'.
			progress do: [stream nextPutImage: image]]]
		valueNowOrOnUnwindDo: [stream close].
	^image! !

!GifImageStream class methodsFor: 'examples' stamp: ' 21/4/07 22:07'!
example6
	"GifImageStream example6."

	| filename stream image progress |
	filename := 'zzz.gif' asFilename.
	stream := GifImageStream on: filename readStream.
	[Cursor read
		showWhile: 
			[progress := Progress new.
			stream compute: [:value | progress value: value].
			progress message: 'reading gif...'.
			progress do: [image := stream nextImage]]]
		valueNowOrOnUnwindDo: [stream close].
	stream show: image.
	^image! !

!GifImageStream class methodsFor: 'class initialization' stamp: ' 21/4/07 22:07'!
initialize
	"GifImageStream initialize."

	ImageSeparator := $, asInteger.
	Extension := $!! asInteger.
	Terminator := $; asInteger.
	GraphicControlLabel := 249! !

!GifImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
system
	^'Goodies'! !

!GifImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
version
	^'003'! !

!HTTPPost methodsFor: '*Aida'!
ajaxSingleInputName
	"Single form field Ajax posts have additional parameter carying the name of that field"
	"except for autocomplete and inplace editing fields, where a first and only field is returned"
	| pdata |
	pdata := self postDataAt: 'ajaxSingleField' ifAbsent: [nil].
	pdata notNil ifTrue: [^pdata value].
	(self isAjaxAutocompleteRequest | self isAjaxInPlaceEditingRequest) ifTrue: 
		[^self postDataKeys detect: [:each | 'field*' match: each] ifNone: nil].
	^nil! !

!HTTPPost methodsFor: '*Aida' stamp: 'np 10/20/2008 16:44'!
postDataKeysNotStreamed
	"keys for a postData which is not streamed"
	self ensureFullRead. "defered parsing of postData"
	^(self postData underlyingCollection select: [:assoc | assoc value isStreamed not])
		collect: [:assoc | assoc key]! !

!HTTPRequest methodsFor: '*Aida' stamp: 'janko 3/19/2012 13:29'!
aidaPresentationType
	"depending on URL extension it can be #web, #json or #xml"
	| lastPart |
	lastPart := self requestLine requestURI identifierPath last.
	('*.json' match: lastPart) ifTrue: [^#json].
	('*.xml' match: lastPart) ifTrue: [^#xml].
	^#web! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 11/10/2010 21:23'!
ajaxElementId
	"Asynchronous JavaScript (AJAX) request, it has additional parameter ajaxGetElementId, 
       usually used to identify an element to update"
	| id |
	id := self queryAt: 'ajaxGetElementId' ifAbsent: [nil].
	id notNil ifTrue: [^id asSymbol].
	^self isPost 
		ifTrue: [(self postDataAt: 'ajaxGetElementId' ifAbsent: [^nil]) value asSymbol]
		ifFalse: [nil]
! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 11/10/2010 21:23'!
ajaxElementToRecreateId
	"for Ajax updates from contents of another element "
	"see WebElement>>onClickPopup:, WebApplication>>ajaxUpdate:with: etc."
	| id |
	id := self queryAt: 'ajaxElementToRecreateId' ifAbsent: [nil].
	id notNil ifTrue: [^id asSymbol].
	^self isPost 
		ifTrue: [(self postDataAt: 'ajaxElementToRecreateId' ifAbsent: [^nil]) value asSymbol]
		ifFalse: [nil]! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 4/24/2009 20:08'!
context
	"an execution context for that request"
	^self environmentAt: #context ifAbsent: [nil]! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 4/24/2009 20:08'!
context: aWebContext
	"an execution context for that request"
	self environmentAt: #context put: aWebContext! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 4/24/2009 20:14'!
contextId
	"unique id of the web context this request is executing. May be in query part or post data"
	| id |
	id := self queryAt: WebContext contextIdName "aidaCtx" ifAbsent: [nil].
	id notNil ifTrue: [^id asInteger].
	^self isPost 
		ifTrue: [(self postDataAt: WebContext contextIdName ifAbsent: [^nil]) value asInteger]
		ifFalse: [nil]! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 12/14/2010 23:42'!
creationStContexts
	"Smalltalk contexts of element creation methods, to determine, which elements are 
	created first in each method. See WebElement class new, checkIfFirstInMethod, isFirstInMethod"
	^self environmentAt: #creationStContexts ifAbsent: 
		[self environmentAt: #creationStContexts put: Set new.
		^self creationStContexts]! !

!HTTPRequest methodsFor: '*Aida' stamp: 'mivsek 1/10/2008 18:06'!
idFromCookie
	"return session id from our cookie. nil if not aida field present in cookie"
	| stream part |
	stream := self cookie readStream.
	[stream atEnd] whileFalse:
		[part := stream upTo: $; .
		('*aida9357*' match: part) ifTrue:
			[^part readStream upTo: $=; upToEnd] ].
	^nil! !

!HTTPRequest methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:18'!
isAjaxAutocompleteRequest
	"AJAX autocomplete input field request, see WebAutocompleteField"
	self isAjaxRequest ifFalse: [^false].
	^self includesQuery: 'ajaxAutocompleteField'! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 8/20/2009 22:05'!
isAjaxCloseWindowRequest
	"to Ajax close the window and its context (by WebElement>>addCloseWindowText: )"
	| parm2 |
	(self isPost and: [self isAjaxRequest]) ifFalse: [^false].
	parm2 := (self postDataAt: 'parm2').
	^parm2 notNil and: [parm2 value = 'aidaCloseWindow']! !

!HTTPRequest methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:18'!
isAjaxInPlaceEditingRequest
	"AJAX in place editor request, see WebInPlaceEditingText"
	self isAjaxRequest ifFalse: [^false].
	^self includesQuery: 'ajaxInPlaceEditing'! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 8/20/2009 22:05'!
isAjaxPopupWindowRequest
	"to Ajax open some element in a popup window, (WebElement>>onClickPopup: )"
	| parm2 |
	(self isPost and: [self isAjaxRequest]) ifFalse: [^false].
	parm2 := (self postDataAt: 'parm2').
	^parm2 notNil and: [parm2 value = 'aidaPopupWindow']! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 8/20/2009 22:05'!
isAjaxPostRequest
	"Asynchronous JavaScript (AJAX) request, with posting an input field in a query"
	^self isAjaxRequest and: [self isPost]
! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 8/25/2009 22:46'!
isAjaxPostWithInput
	"Asynchronous JavaScript (AJAX) request, with posting an input field in a post data"
	(self isPost and: [self isAjaxRequest]) ifFalse: [^false].
	^(self postDataKeys contains: [:each | 'field*' match: each]) 
		or: [self isAjaxPostWithSingleInput "uncheck a single checkbox doesn't have any add. field !! "
			or: [self postDataKeys includes: 'ajaxPressedButton'] ]! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 8/20/2009 22:06'!
isAjaxPostWithSingleInput
	"Ajax post with of one form element only"
	(self isPost and: [self isAjaxRequest]) ifFalse: [^false].
	^(self postDataKeys includes: 'ajaxSingleField')
		or: [self isAjaxAutocompleteRequest | self isAjaxInPlaceEditingRequest]! !

!HTTPRequest methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:19'!
isAjaxRequest
	"Asynchronous JavaScript (AJAX) request, it has additional parameter ajaxRequest"
	^(self headerAt: 'X-Requested-With' ifAbsent: [^false]) value = 'XMLHttpRequest'! !

!HTTPRequest methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:19'!
isAjaxWikiFormatedRequest
	"AJAX in place editor request, see WebInPlaceEditingText"
	self isAjaxRequest ifFalse: [^false].
	^self includesQuery: 'wikiFormated'! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 2/1/2011 21:13'!
isClassicalRequest
	"a classical (not Ajax) request"
	^self isAjaxRequest not! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 12/14/2010 23:42'!
isForwarded
	"Request is forwarded by Proxy server"
	^(self headerAt: 'X-Forwarded-For' ifAbsent: [^false]) notNil! !

!HTTPRequest methodsFor: '*Aida' stamp: 'janko 7/13/2008 11:28'!
isPing
	"/ping.html, for monitoring the site etc."
	^self requestLine requestURI identifier = '/ping.html'! !

!HTTPRequest methodsFor: '*Aida' stamp: 'jm 2/1/2011 21:14'!
isWebEvent
	^false! !

!HTTPRequest methodsFor: '*Aida'!
view
	| view |
	view := self queryAt: 'view' ifAbsent: [nil].
	view notNil ifTrue: [^(view readStream upTo: $# )  asSymbol]. "skip #anchor if any"
	^self isPost 
		ifTrue: [(self postDataAt: 'view' ifAbsent: [^#main]) value asSymbol]
		ifFalse: [#main]! !

!HistoryOfValue methodsFor: 'private-history arrays' stamp: ' 21/4/07 22:07'!
activeFromArray: anArray

	"return a active flag from entries in history array"

	^anArray at: 5! !

!HistoryOfValue methodsFor: 'private-adding-removing' stamp: ' 21/4/07 22:07'!
addValue: aValue dated: aDate author: aString comment: aCommentString
	"adds data, which is newer than any existing one"
	self dates add: aDate asDays.
	self values add: aValue.
	self changedDates add: Date today asDays.
	self authors add: aString.
	self comments add: aString.! !

!HistoryOfValue methodsFor: 'private-history arrays' stamp: ' 21/4/07 22:07'!
arrayWithDate: aDate time: aTime value: aValue active: aBoolean

	"return a array with argument vaules for entry to history collection"

	| array |
	array := Array new: 5.
	array 
		at: 1 put: aDate year;
		at: 2 put: aDate day;
		at: 3 put: (aTime notNil ifTrue: [aTime asSeconds] ifFalse: [0]);
		at: 4 put: aValue;
		at: 5 put: aBoolean.
	^array! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
authors
	" a collection of authors, which made changes, (as a String or reference to a WebUser)"
	^authors! !

!HistoryOfValue methodsFor: 'private-adding-removing'!
changeValue: aValue author: aString comment: aCommentString onIndex: anIndexNumber
	"change data in a specified index"
	self values at: anIndexNumber put: aValue.
	self changedDates at: anIndexNumber put: Date today asDays.
	self authors at: anIndexNumber put: aString.
	self comments at: anIndexNumber put: aString.! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
changedDates
	" a collection of dates, when value was changed in asDays format"
	^changedDates! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
comments
	" a collection of comments about changes"
	^comments! !

!HistoryOfValue methodsFor: 'private-history arrays' stamp: ' 21/4/07 22:07'!
dateFromArray: anArray

	"return a date from entries in history array"

	^Date
		newDay: (anArray at: 2)
		year: (anArray at: 1)! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
dates
	" a collection of dates of changes in asDays format"
	^dates! !

!HistoryOfValue methodsFor: 'private-adding-removing' stamp: ' 21/4/07 22:07'!
hasDuplicateDates

	"maintenance - check if more than one entry with the same date exist"

	| unique |
	unique := Set new.
	self dates do: [: date | (unique includes: date)
		ifTrue: [^true]
		ifFalse: [unique add: date] ].
	^false! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
historyCollection
	"this is an ordered collection of array with year, day in year, time, value, active flag. 
	Collection is ordered from oldest to newest version of value. Active flag is used to 
	'delete' some version from history, but you can still have a trace, who/when some 
	change occured.

	3.11.98 NOT USED anymore. Here just for migration!!"


	historyCollection isNil ifTrue: [self initHistoryCollection].
	^historyCollection! !

!HistoryOfValue methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
historyOfChanges

	"return a history of all changes of value. It is returned as ordered collection of collections, each with:
	valid from date
	valid to date (for last change: nil)
	new value
	date of change
	author of change
	comment of change	

Returned collection has the oldest change (by valied from date) as first, the newest as last. "! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
indexForDate: aDate

	"return index of entry in dates collection, which fits most to the specified date. If no direct 
	entry on a specified date exist, then entry for previous date is used. If aDate is older than
	any date in collection, nil is returned!!"


	| first last days mdays index |

	first := 1. last := self dates size.
	last = 0 ifTrue: [^nil].
	days := aDate asDays.
	days >= self dates last ifTrue: [^last].
	days < self dates first ifTrue: [^nil].
	[last >= first] whileTrue: 	
		[ "(first = last and: [days = (self dates at: first)]) ifTrue: [^first].  " " not needed!! "
		index := (first + last) // 2.
		mdays := self dates at: index.
		days = mdays ifTrue: [^index].
		days < mdays
			ifTrue: [last := index - 1.]
			ifFalse: [first := index + 1.]].
"2.11.98 Sivec prej :
		^1 max: index - 1.
"
	index := (first + last) // 2.
	^1 max: index.




"
| h |
h := History new.
h dates
	add: (Date today) asDays;
	add: (Date today + 1) asDays;
	add: (Date today + 3) asDays;
	add: (Date today + 4) asDays.
Transcript cr;show: (h indexForDate: Date today - 1) printString.
Transcript cr;show: (h indexForDate: Date today + 1) printString.
Transcript cr;show: (h indexForDate: Date today + 2) printString.
Transcript cr;show: (h indexForDate: Date today + 3) printString.
h inspect.
"





"
	self historyCollection keysAndValuesDo: [:index :array |
		(self activeFromArray: array) 
			ifTrue:
				[(self dateFromArray: array) < (aDate + 1)
					ifTrue: [prevIndex := index]
					ifFalse: [^prevIndex]	] ].
	^prevIndex
"! !

!HistoryOfValue methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initAuthors
	authors := OrderedCollection new.! !

!HistoryOfValue methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initChangedDates
	changedDates := OrderedCollection new.! !

!HistoryOfValue methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initComments
	comments := OrderedCollection new.! !

!HistoryOfValue methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initDates
	"adds default entry: 1.1.1901"
	dates := OrderedCollection new.! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
initHistoryCollection
	historyCollection := OrderedCollection new.! !

!HistoryOfValue methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initValues
	values := OrderedCollection new.! !

!HistoryOfValue methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	"2.11.1998 all inits do not add default values anymore"

	self initDates.
	self initValues.
	self initChangedDates.
	self initAuthors.
	self initComments.! !

!HistoryOfValue methodsFor: 'private-adding-removing' stamp: ' 21/4/07 22:07'!
insertValue: aValue dated: aDate author: aString comment: aCommentString beforeIndex: anIndex
	"adds data in position before specified index"
	self dates add: aDate asDays beforeIndex: anIndex.
	self values add: aValue beforeIndex: anIndex.
	self changedDates add: Date today asDays beforeIndex: anIndex.
	self authors add: aString beforeIndex: anIndex.
	self comments add: aString beforeIndex: anIndex.! !

!HistoryOfValue methodsFor: 'private-history arrays' stamp: ' 21/4/07 22:07'!
migrateHistoryCollection

	"migrate from historyCollection to bunch of collections. Remove duplicates"

	| date |
	date := nil.
	self initialize.
	self historyCollection reverseDo: [:array |
		date = (self dateFromArray: array)
			ifFalse: 
				[self 
					value: (self valueFromArray: array)
					dated: (self dateFromArray: array)
					author: ('')
					comment: ('').
				date := self dateFromArray: array] ].


"
Janko := History selectFromOdb select: [:h | h historyCollection size > 10].
(Janko at: 3) migrateHistoryCollection
Janko do: [:each | each migrateHistoryCollection].
Janko  select: [:h | h dates size > 3].
"! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
newestDate

	"return a date of newest version of value"

	self dates isEmpty
		ifTrue: [^nil]
		ifFalse: 	[^Date fromDays: self dates last]

"History new newestDate"! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
newestValue

	"return a newest version of value in historyCollection."

	self values isEmpty
		ifTrue: [^nil]
		ifFalse: 	[^self values last]
	

"History new newestValue"! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
oldestDate

	"return a date of oldest version of value"

	self dates isEmpty
		ifTrue: [^nil]
		ifFalse: 	[^self dates first]
	

"History new oldestDate"! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
oldestValue

	"return a oldest version of value"

	self values isEmpty
		ifTrue: [^nil]
		ifFalse: 	[^self values last]
	

"History new oldestValue"! !

!HistoryOfValue methodsFor: 'private' stamp: ' 21/4/07 22:07'!
printString

	^('aHistory: ', self value printString)! !

!HistoryOfValue methodsFor: 'private-adding-removing' stamp: ' 21/4/07 22:07'!
removeAllNils
	"REPARING BAD HISTORIES - remove all nil entries. Initialize if no more entries"

	2 to: self values size do: [:index |
		(self values at: index) isNil ifTrue: 
			[self removeIndex: index. ^self removeAllNils] ]! !

!HistoryOfValue methodsFor: 'private-adding-removing' stamp: ' 21/4/07 22:07'!
removeDuplicateDates

	"maintenance - remove all duplicate entries with same dates. Live last one"

	| date index |
	self hasDuplicateDates ifTrue: 
		[date := 0. index := nil.
		1 to: self dates size do: 
			[:inx | 
				(self dates at: inx) = date ifTrue: [index := inx].
				date := self dates at: inx].
		index notNil 
			ifTrue: 
				[self removeIndex: index-1.
				self removeDuplicateDates].
		 ].! !

!HistoryOfValue methodsFor: 'private-adding-removing' stamp: ' 21/4/07 22:07'!
removeIndex: aNumber
	"remove all entries on specified index"
	self dates removeIndex: aNumber.
	self values removeIndex: aNumber.
	self changedDates removeIndex: aNumber.
	self authors removeIndex: aNumber.
	self comments removeIndex: aNumber.! !

!HistoryOfValue methodsFor: 'private-adding-removing' stamp: ' 21/4/07 22:07'!
removeLastNil
	"REPARING BAD HISTORIES - remove last entry if value nil. Initialize if no more entries"
	self values isEmpty 
		ifTrue: 
			[self initialize. self values removeLast; addLast: true.
			Transcript cr; show: 'init, true']
		ifFalse: [self values last isNil ifTrue: 
			[self removeIndex: (self dates size).
			self removeLastNil] ]! !

!HistoryOfValue methodsFor: 'private-history arrays' stamp: ' 21/4/07 22:07'!
timeFromArray: anArray

	"return a time from entries in history array"

	^Time fromSeconds: (anArray at: 3)! !

!HistoryOfValue methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
value
	"get the curently valid value"

	^self valueDated: Date today

"History new value"! !

!HistoryOfValue methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
value: aValue author: aString comment: aCommentString 
	"change a value of time series, which will be valid immediately - today. You should state author and a short comment about changes. see other methods for detailed explanation"

	self value: aValue
		dated: Date today
		author: aString
		comment: aCommentString! !

!HistoryOfValue methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
value: aValue dated: aDate author: aString comment: aCommentString 
	""

	| index |

	index := self indexForDate: aDate. 
	index isNil   "older than any existing or first" 
		ifTrue: 
			[self 
				insertValue: aValue 
				dated: aDate
				author: aString 
				comment: aCommentString
				beforeIndex: 1.
			^self].

"Sprememba 18.11.1998 Sivec, prej 'index >= self dates  size'."
	index > self dates  size  "newer than any existing"
		ifTrue: 
			[self addValue: aValue dated: aDate author: aString comment: aCommentString. ^self].


	(index ~= 0 and: [(self dates at: index) = aDate asDays]) "already exists"
		ifTrue: 
			[self 
				changeValue: aValue 
				author: aString 
				comment: aCommentString 
				onIndex: index.
			^self].

		self    "insert new somewhere in the middle"
			insertValue: aValue 
			dated: aDate
			author: aString 
			comment: aCommentString
			beforeIndex: index+1.



"History new value: 1234 dated: Date today author: 'Janko' comment: 'test'"! !

!HistoryOfValue methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
valueDated: aDate 
	"get the value from history, which was valid on specified date. Returns nil if aDate is older from 
	oldest entry in history"

	
	| index |
	index := self indexForDate: aDate.
	index = 0 ifTrue: [^nil].
	index = nil ifTrue: [^nil].
	^self values at: index.! !

!HistoryOfValue methodsFor: 'private-history arrays' stamp: ' 21/4/07 22:07'!
valueFromArray: anArray

	"return a value from entries in history array"

	^anArray at: 4! !

!HistoryOfValue methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
values
	" a collection of values, each valid from date in dates at the same index"
	^values! !

!HistoryOfValue class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
instancesAreForwarders
	"Gemstone"

	^false! !

!HistoryOfValue class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!HistoryOfValue class methodsFor: 'examples' stamp: 'jm 11/16/2010 17:19'!
tests
	"some test of histories. Use it directly from code with doIt/printIt/inspectIt "

	| history |
	history := HistoryOfValue new.
	history value: 0 dated: (Date today ) author: '' comment: ''.
	history value: -2000 dated: (Date today - (365*100) -2) author: '' comment: ''.
	history value: -3 dated: (Date today -3) author: '' comment: ''.
	history value: -1 dated: (Date today -1) author: '' comment: ''.
	history value: 2 dated: (Date today +2) author: '' comment: ''.
	history value: 1 dated: (Date today +1) author: '' comment: ''.! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
atEnd
	^imageStream atEnd! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
close
	imageStream close! !

!ImageStream methodsFor: 'progress' stamp: ' 21/4/07 22:07'!
compute: aBlock 
	(self progressValue isKindOf: ValueHolder)
		ifTrue: [self progressValue compute: aBlock]! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
contents
	^imageStream contents! !

!ImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
convertValue: value from: fromScale to: toScale 
	^value = 0
		ifTrue: [0]
		ifFalse: [value = fromScale
				ifTrue: [toScale]
				ifFalse: [(value + 1 * (toScale + 1) / (fromScale + 1)) rounded - 1 max: 0]]! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
cr
	^imageStream nextPut: Character cr asInteger! !

!ImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
errorCanNotRead
	self error: 'can''t read the image'.
	^nil! !

!ImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
errorCanNotWrite
	self error: 'can''t write the image'.
	^nil! !

!ImageStream methodsFor: 'private' stamp: ' 21/4/07 22:07'!
hasMagicNumber: aByteArray 
	| position array |
	position := imageStream position.
	imageStream size - position >= aByteArray size
		ifTrue: 
			[array := (imageStream next: aByteArray size) asByteArray.
			array = aByteArray ifTrue: [^true]].
	imageStream position: position.
	^false! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
lf
	^imageStream nextPut: Character lf asInteger! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
next
	^imageStream next! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
next: size 
	^imageStream next: size! !

!ImageStream methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nextImage
	^self subclassResponsibility! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextLong
	^(imageStream next bitShift: 24)
		+ (imageStream next bitShift: 16) + (imageStream next bitShift: 8) + imageStream next! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextLongPut: a32BitW 
	imageStream nextPut: ((a32BitW bitShift: -24)
			bitAnd: 255).
	imageStream nextPut: ((a32BitW bitShift: -16)
			bitAnd: 255).
	imageStream nextPut: ((a32BitW bitShift: -8)
			bitAnd: 255).
	imageStream nextPut: (a32BitW bitAnd: 255).
	^a32BitW! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextPut: aByte 
	^imageStream nextPut: aByte! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextPutAll: aByteArray 
	^imageStream nextPutAll: aByteArray! !

!ImageStream methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nextPutImage: anImage 
	^self subclassResponsibility! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextWord
	^(imageStream next bitShift: 8)
		+ imageStream next! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
nextWordPut: a16BitW 
	imageStream nextPut: ((a16BitW bitShift: -8)
			bitAnd: 255).
	imageStream nextPut: (a16BitW bitAnd: 255).
	^a16BitW! !

!ImageStream methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
on: aStream 
	imageStream := aStream.
	(imageStream respondsTo: #binary)
		ifTrue: [imageStream binary].
	self progressValue: (ValueHolder with: nil)! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
position
	^imageStream position! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
position: anInteger 
	^imageStream position: anInteger! !

!ImageStream methodsFor: 'progress' stamp: ' 21/4/07 22:07'!
progress
	^self progressValue value! !

!ImageStream methodsFor: 'progress' stamp: ' 21/4/07 22:07'!
progress: normalizedNumber 
	(0 <= normalizedNumber and: [normalizedNumber <= 1])
		ifTrue: 
			[| truncatedValue |
			truncatedValue := normalizedNumber roundTo: 0.005.
			self progressValue value = truncatedValue ifFalse: [self progressValue value: truncatedValue]]! !

!ImageStream methodsFor: 'progress' stamp: ' 21/4/07 22:07'!
progressValue
	^progressValue! !

!ImageStream methodsFor: 'progress' stamp: ' 21/4/07 22:07'!
progressValue: aValueHolder 
	progressValue := aValueHolder! !

!ImageStream methodsFor: 'viewing' stamp: ' 21/4/07 22:07'!
show: anImage 
	^self class show: anImage! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
size
	^imageStream size! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
skip: anInteger 
	^imageStream skip: anInteger! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
space
	^imageStream nextPut: Character space asInteger! !

!ImageStream methodsFor: 'stream access' stamp: ' 21/4/07 22:07'!
tab
	^imageStream nextPut: Character tab asInteger! !

!ImageStream class methodsFor: 'controls' stamp: ' 21/4/07 22:07'!
assert: assertBlock do: doBlock ensure: ensureBlock 
	assertBlock value.
	[doBlock value]
		valueNowOrOnUnwindDo: [ensureBlock value]! !

!ImageStream class methodsFor: 'constants of palette' stamp: ' 21/8/07 09:38'!
colorPalette256
	"ImageStream colorPalette256."

	| anArray |
	ColorPalette256 notNil ifTrue: [^ColorPalette256].
	anArray := self colorPalette256Array
				collect: 
					[:array | 
					| r g b color |
					r := array at: 1.
					g := array at: 2.
					b := array at: 3.
					ColorValue scalingValue = 8191
						ifTrue: [color := ColorValue
										scaledRed: r
										scaledGreen: g
										scaledBlue: b]
						ifFalse: 
							[r := r / 8191.
							g := g / 8191.
							b := b / 8191.
							color := ColorValue
										red: r
										green: g
										blue: b].
					color yourself].
	ColorPalette256 := MappedPalette withColors: anArray reverse.
	^ColorPalette256! !

!ImageStream class methodsFor: 'constants of palette' stamp: ' 21/8/07 09:38'!
colorPalette256Array
	"ImageStream colorPalette256Array."
	^#(	#(8191 8191 8191)
		#(8191 8191 6553)
		#(8191 8191 4915)
		#(8191 8191 3276)
		#(8191 8191 1638)
		#(8191 8191 0)
		#(8191 6553 8191)
		#(8191 6553 6553)
		#(8191 6553 4915)
		#(8191 6553 3276)
		#(8191 6553 1638)
		#(8191 6553 0)
		#(8191 4915 8191)
		#(8191 4915 6553)
		#(8191 4915 4915)
		#(8191 4915 3276)
		#(8191 4915 1638)
		#(8191 4915 0)
		#(8191 3276 8191)
		#(8191 3276 6553)
		#(8191 3276 4915)
		#(8191 3276 3276)
		#(8191 3276 1638)
		#(8191 3276 0)
		#(8191 1638 8191)
		#(8191 1638 6553)
		#(8191 1638 4915)
		#(8191 1638 3276)
		#(8191 1638 1638)
		#(8191 1638 0)
		#(8191 0 8191)
		#(8191 0 6553)
		#(8191 0 4915)
		#(8191 0 3276)
		#(8191 0 1638)
		#(8191 0 0)
		#(6553 8191 8191)
		#(6553 8191 6553)
		#(6553 8191 4915)
		#(6553 8191 3276)
		#(6553 8191 1638)
		#(6553 8191 0)
		#(6553 6553 8191)
		#(6553 6553 6553)
		#(6553 6553 4915)
		#(6553 6553 3276)
		#(6553 6553 1638)
		#(6553 6553 0)
		#(6553 4915 8191)
		#(6553 4915 6553)
		#(6553 4915 4915)
		#(6553 4915 3276)
		#(6553 4915 1638)
		#(6553 4915 0)
		#(6553 3276 8191)
		#(6553 3276 6553)
		#(6553 3276 4915)
		#(6553 3276 3276)
		#(6553 3276 1638)
		#(6553 3276 0)
		#(6553 1638 8191)
		#(6553 1638 6553)
		#(6553 1638 4915)
		#(6553 1638 3276)
		#(6553 1638 1638)
		#(6553 1638 0)
		#(6553 0 8191)
		#(6553 0 6553)
		#(6553 0 4915)
		#(6553 0 3276)
		#(6553 0 1638)
		#(6553 0 0)
		#(4915 8191 8191)
		#(4915 8191 6553)
		#(4915 8191 4915)
		#(4915 8191 3276)
		#(4915 8191 1638)
		#(4915 8191 0)
		#(4915 6553 8191)
		#(4915 6553 6553)
		#(4915 6553 4915)
		#(4915 6553 3276)
		#(4915 6553 1638)
		#(4915 6553 0)
		#(4915 4915 8191)
		#(4915 4915 6553)
		#(4915 4915 4915)
		#(4915 4915 3276)
		#(4915 4915 1638)
		#(4915 4915 0)
		#(4915 3276 8191)
		#(4915 3276 6553)
		#(4915 3276 4915)
		#(4915 3276 3276)
		#(4915 3276 1638)
		#(4915 3276 0)
		#(4915 1638 8191)
		#(4915 1638 6553)
		#(4915 1638 4915)
		#(4915 1638 3276)
		#(4915 1638 1638)
		#(4915 1638 0)
		#(4915 0 8191)
		#(4915 0 6553)
		#(4915 0 4915)
		#(4915 0 3276)
		#(4915 0 1638)
		#(4915 0 0)
		#(3276 8191 8191)
		#(3276 8191 6553)
		#(3276 8191 4915)
		#(3276 8191 3276)
		#(3276 8191 1638)
		#(3276 8191 0)
		#(3276 6553 8191)
		#(3276 6553 6553)
		#(3276 6553 4915)
		#(3276 6553 3276)
		#(3276 6553 1638)
		#(3276 6553 0)
		#(3276 4915 8191)
		#(3276 4915 6553)
		#(3276 4915 4915)
		#(3276 4915 3276)
		#(3276 4915 1638)
		#(3276 4915 0)
		#(3276 3276 8191)
		#(3276 3276 6553)
		#(3276 3276 4915)
		#(3276 3276 3276)
		#(3276 3276 1638)
		#(3276 3276 0)
		#(3276 1638 8191)
		#(3276 1638 6553)
		#(3276 1638 4915)
		#(3276 1638 3276)
		#(3276 1638 1638)
		#(3276 1638 0)
		#(3276 0 8191)
		#(3276 0 6553)
		#(3276 0 4915)
		#(3276 0 3276)
		#(3276 0 1638)
		#(3276 0 0)
		#(1638 8191 8191)
		#(1638 8191 6553)
		#(1638 8191 4915)
		#(1638 8191 3276)
		#(1638 8191 1638)
		#(1638 8191 0)
		#(1638 6553 8191)
		#(1638 6553 6553)
		#(1638 6553 4915)
		#(1638 6553 3276)
		#(1638 6553 1638)
		#(1638 6553 0)
		#(1638 4915 8191)
		#(1638 4915 6553)
		#(1638 4915 4915)
		#(1638 4915 3276)
		#(1638 4915 1638)
		#(1638 4915 0)
		#(1638 3276 8191)
		#(1638 3276 6553)
		#(1638 3276 4915)
		#(1638 3276 3276)
		#(1638 3276 1638)
		#(1638 3276 0)
		#(1638 1638 8191)
		#(1638 1638 6553)
		#(1638 1638 4915)
		#(1638 1638 3276)
		#(1638 1638 1638)
		#(1638 1638 0)
		#(1638 0 8191)
		#(1638 0 6553)
		#(1638 0 4915)
		#(1638 0 3276)
		#(1638 0 1638)
		#(1638 0 0)
		#(0 8191 8191)
		#(0 8191 6553)
		#(0 8191 4915)
		#(0 8191 3276)
		#(0 8191 1638)
		#(0 8191 0)
		#(0 6553 8191)
		#(0 6553 6553)
		#(0 6553 4915)
		#(0 6553 3276)
		#(0 6553 1638)
		#(0 6553 0)
		#(0 4915 8191)
		#(0 4915 6553)
		#(0 4915 4915)
		#(0 4915 3276)
		#(0 4915 1638)
		#(0 4915 0)
		#(0 3276 8191)
		#(0 3276 6553)
		#(0 3276 4915)
		#(0 3276 3276)
		#(0 3276 1638)
		#(0 3276 0)
		#(0 1638 8191)
		#(0 1638 6553)
		#(0 1638 4915)
		#(0 1638 3276)
		#(0 1638 1638)
		#(0 1638 0)
		#(0 0 8191)
		#(0 0 6553)
		#(0 0 4915)
		#(0 0 3276)
		#(0 0 1638)
		#(7645 0 0)
		#(7099 0 0)
		#(6007 0 0)
		#(5461 0 0)
		#(4369 0 0)
		#(3822 0 0)
		#(2730 0 0)
		#(2184 0 0)
		#(1092 0 0)
		#(546 0 0)
		#(0 7645 0)
		#(0 7099 0)
		#(0 6007 0)
		#(0 5461 0)
		#(0 4369 0)
		#(0 3822 0)
		#(0 2730 0)
		#(0 2184 0)
		#(0 1092 0)
		#(0 546 0)
		#(0 0 7645)
		#(0 0 7099)
		#(0 0 6007)
		#(0 0 5461)
		#(0 0 4369)
		#(0 0 3822)
		#(0 0 2730)
		#(0 0 2184)
		#(0 0 1092)
		#(0 0 546)
		#(7645 7645 7645)
		#(7099 7099 7099)
		#(6007 6007 6007)
		#(5461 5461 5461)
		#(4369 4369 4369)
		#(3822 3822 3822)
		#(2730 2730 2730)
		#(2184 2184 2184)
		#(1092 1092 1092)
		#(546 546 546)
		#(0 0 0)
	)! !

!ImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
copyright
	^'Copyright (C) 1995-1998 AOKI Atsushi, All Rights Reserved.'! !

!ImageStream class methodsFor: 'constants of palette' stamp: ' 21/4/07 22:07'!
flushPalettes
	"ImageStream flushPalettes."

	ColorPalette256 := nil.
	GrayPalette256 := nil! !

!ImageStream class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
fromClipboard
	"ImageStream show: ImageStream fromClipboard."

	| pixmap image |
	pixmap := Pixmap fromClipboard.
	image := pixmap asImage.
	^image! !

!ImageStream class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
fromDisplay
	"ImageStream show: ImageStream fromDisplay."

	^self fromDisplay: Screen default bounds! !

!ImageStream class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
fromDisplay: aRectangle 
	"ImageStream show: (ImageStream fromDisplay: (0 @ 0 extent: 100 @ 100))."

	^Screen default completeContentsOfArea: aRectangle! !

!ImageStream class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
fromUser
	"ImageStream show: ImageStream fromUser."

	^self fromDisplay: Rectangle fromUser! !

!ImageStream class methodsFor: 'constants of palette' stamp: ' 21/4/07 22:07'!
grayPalette256
	"ImageStream grayPalette256."

	| paletteSize anArray |
	GrayPalette256 notNil ifTrue: [^GrayPalette256].
	paletteSize := 256.
	anArray := Array new: paletteSize.
	1 to: paletteSize
		do: 
			[:index | 
			| color |
			color := ColorValue brightness: 1 - (index - 1 / (paletteSize - 1)).
			anArray at: index put: color].
	GrayPalette256 := MappedPalette withColors: anArray reverse.
	^GrayPalette256! !

!ImageStream class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
imageKindTable
	"ImageStream imageKindTable."

	ImageKindTable isNil
		ifTrue: 
			[| aDictionary |
			aDictionary := Dictionary new.
			aDictionary at: 'bos' put: #BosImageStream.
			aDictionary at: 'boss' put: #BosImageStream.
			aDictionary at: 'bmp' put: #BmpImageStream.
			aDictionary at: 'bmpf' put: #BmpImageStream.
			aDictionary at: 'gif' put: #GifImageStream.
			aDictionary at: 'giff' put: #GifImageStream.
			aDictionary at: 'jpg' put: #JpegImageStream.
			aDictionary at: 'jpeg' put: #JpegImageStream.
			aDictionary at: 'pic' put: #PictImageStream.
			aDictionary at: 'pict' put: #PictImageStream.
			ImageKindTable := aDictionary].
	^ImageKindTable! !

!ImageStream class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
imageStreamClassForFileName: aFilename 
	"ImageStream imageStreamClassForFileName: 'zzz.gif' asFilename."

	| aString aSymbol aClass |
	aString := (aFilename asString reverse copyUpTo: $.) reverse.
	aString := aString asLowercase.
	aSymbol := self imageKindTable at: aString ifAbsent: [nil].
	aSymbol isNil ifTrue: [^nil].
	aClass := Smalltalk at: aSymbol ifAbsent: [nil].
	^aClass! !

!ImageStream class methodsFor: 'class initialization' stamp: ' 21/4/07 22:07'!
initialize
	"ImageStream initialize."

	ImageKindTable := nil.
	self flushPalettes! !

!ImageStream class methodsFor: 'class initialization' stamp: ' 21/4/07 22:07'!
install
	"ImageStream install."

	self colorPalette256.
	self grayPalette256! !

!ImageStream class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
on: aStream 
	^self new on: aStream! !

!ImageStream class methodsFor: 'saving' stamp: ' 21/4/07 22:07'!
save
	"ImageStream save."

	| encodingName fileName classCollection aStream |
	encodingName := #default.
	fileName := 'ImgStrm.st'.
	classCollection := self saveClasses.
	aStream := (fileName asFilename withEncoding: encodingName) writeStream.
	[Cursor write
		showWhile: 
			[| timeStamp |
			timeStamp := Date today shortPrintString , ' ' , Time now shortPrintString.
			aStream cr.
			aStream nextChunkPut: timeStamp printString.
			aStream cr; cr.
			(self comment isNil or: [self comment isEmpty])
				ifFalse: 
					[aStream nextChunkPut: self comment printString.
					aStream cr; cr].
			classCollection
				do: 
					[:aClass | 
					aStream nextChunkPut: aClass definition.
					aStream cr; cr].
			classCollection
				do: 
					[:aClass | 
					| sourceCodeStream |
					aStream nextPut: Character newPage.
					aStream cr.
					sourceCodeStream := SourceCodeStream on: aStream.
					aClass fileOutSourceOn: sourceCodeStream.
					aStream cr]]]
		valueNowOrOnUnwindDo: [aStream close].
	^classCollection! !

!ImageStream class methodsFor: 'saving' stamp: ' 21/4/07 22:07'!
saveClasses
	"ImageStream saveClasses."

	| patternCollection classCollection |
	patternCollection := #('*ImageStream*' '*Progress*').
	classCollection := Smalltalk organization superclassOrder: self category.
	classCollection := classCollection
				select: 
					[:aClass | 
					| string something |
					string := aClass name asString.
					something := patternCollection detect: [:it | it match: string]
								ifNone: [nil].
					something notNil].
	^classCollection , Progress saveClasses! !

!ImageStream class methodsFor: 'viewing' stamp: ' 21/4/07 22:07'!
show: anImage 
	"ImageStream show: Image fromUser."

	| image extent window |
	(anImage isKindOf: OpaqueImage)
		ifTrue: [image := anImage]
		ifFalse: [image := CachedImage on: anImage].
	extent := 64 @ 64 max: (image extent min: Screen default bounds extent - 60 asPoint).
	window := ScheduledWindow new.
	window label: 'Image'.
	window minimumSize: extent.
	window component: image.
	window open.
	^anImage! !

!ImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
system
	^'Goodies'! !

!ImageStream class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
toClipboard: anImage 
	"ImageStream toClipboard: Image fromUser."

	| pixmap |
	pixmap := anImage asRetainedMedium.
	pixmap toClipboard.
	^anImage! !

!ImageStream class methodsFor: 'copyright' stamp: ' 21/4/07 22:07'!
version
	^'003'! !

!Integer methodsFor: '*Aida' stamp: 'janko 8/3/2011 19:13'!
asScaledDecimal: aScaleInteger
	^ScaledDecimal  newFromNumber: self scale: aScaleInteger

! !

!MIMEMap methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
addType: aTypeString andExtension: anExtensionString
	| exts |
	exts := self mimeTypes at: aTypeString ifAbsentPut: [OrderedCollection new].
	(exts includes: anExtensionString) ifFalse: [exts add: anExtensionString].
	self fileExtensions at: anExtensionString ifAbsentPut: [aTypeString].! !

!MIMEMap methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
extensionForType: aString
	"only first one if more than one ext exist for this mime type"
	| exts string |
	string := aString = 'image/pjpeg' ifTrue: ['image/jpeg'] ifFalse: [aString]. "wierd IE problem"
	string := aString = 'image/x-png' ifTrue: ['image/png'] ifFalse: [string]. "wierd IE problem"
	exts := self mimeTypes at: string asLowercase ifAbsent: [#()].
	^exts notEmpty ifTrue: [exts first] ifFalse: [nil]

"MIMEMap new extensionForType: 'image/jpeg'"! !

!MIMEMap methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
extensionsForType: aString
	^self mimeTypes at: aString asLowercase ifAbsent: [#()].

"MIMEMap new extensionsForType: 'image/jpeg'"! !

!MIMEMap methodsFor: 'private' stamp: ' 21/4/07 22:07'!
fileExtensions
	fileExtensions isNil ifTrue: [self initFileExtensions].
	^fileExtensions! !

!MIMEMap methodsFor: 'accessing'!
iconForType: aString
	"a name of icon to represent this content type, from WebStyle imgs-filetype icons"
	aString isNil ifTrue: [^#unknownSmallPng].
	'text/plain' = aString ifTrue: [^#txtSmallPng].
	'text/xml' = aString ifTrue: [^#xmlSmallPng].
	'application/pdf' = aString ifTrue: [^#pdfSmallPng].
	'application/msword' = aString ifTrue: [^#wordSmallPng].
	'application/rtf' = aString ifTrue: [^#wordSmallPng].
	'application/excel' = aString ifTrue: [^#excelSmallPng]. "depreceated!!"
	'application/vnd.ms-excel' = aString ifTrue: [^#excelSmallPng].
	'application/powerpoint' = aString ifTrue: [^#powerpointSmallPng].   "depreceated!!"
	'application/vnd.ms-powerpoint' = aString ifTrue: [^#powerpointSmallPng].
	'application/zip' = aString ifTrue: [^#zipSmallPng].
	('image/*' match: aString) ifTrue: [^#imageSmallPng].
	('audio/*' match: aString) ifTrue: [^#multimediaSmallPng].
	('video/*' match: aString) ifTrue: [^#multimediaSmallPng].
	^#unknownSmallPng

"MIMEMap new iconForType: 'image/jpeg'"! !

!MIMEMap methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initFileExtensions
	fileExtensions := Dictionary new.! !

!MIMEMap methodsFor: 'initialize-release'!
initFromApacheMimeTypes
	"see class method. Only mime types, which have some extension defined, are set!! "
	"MIMEMap allInstances do: [:each | each initFromApacheMimeTypes] "
	| collection |
	self initMimeTypes; initFileExtensions.
	collection := self class arrayFromApacheMimeTypes.
	collection do: [:col | 
		2 to: col size do: [:inx | self addType: col first andExtension: (col at: inx)] ]! !

!MIMEMap methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initMimeTypes
	mimeTypes := Dictionary new.! !

!MIMEMap methodsFor: 'initialize-release'!
initialize
	"MIMEMap allInstances do: [:each | each initialize]"
	self initFromApacheMimeTypes! !

!MIMEMap methodsFor: 'testing'!
isTextType: aTypeString
	"is this content type text based?"
	^self class arrayFromTextMimeTypes includes: aTypeString! !

!MIMEMap methodsFor: 'private' stamp: ' 21/4/07 22:07'!
mimeTypes
	mimeTypes isNil ifTrue: [self initMimeTypes].
	^mimeTypes! !

!MIMEMap methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
removeType: aTypeString andExtension: anExtensionString
	| exts |
	exts := self mimeTypes at: aTypeString ifAbsent: [OrderedCollection new].
	(exts includes: anExtensionString) ifTrue: [exts remove: anExtensionString].
	exts isEmpty ifTrue: [self mimeTypes removeKey: aTypeString ifAbsent: [] ].
	self fileExtensions removeKey: anExtensionString ifAbsent: [].! !

!MIMEMap methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
typeForExtension: aString
	| ext |
	ext := aString asLowercase copyWithout: $. .
	^self fileExtensions at: ext ifAbsent: [nil].

"MIMEMap new typeForExtension: 'jpg'"! !

!MIMEMap class methodsFor: 'accessing'!
apacheMimeTypes
	"from /etc/apache2/mime.types after Apache v2.x is installed. docx, xlsx added manually"
	"Dont forget to initialize all MIMEMaps after any change here!!"
	"MIMEMap allInstances do: [:each | each initialize]"
	"# This file controls what Internet media types are sent to the client for
# given file extension(s).  Sending the correct media type to the client
# is important so they know how to handle the content of the file.
# For more information about Internet media types, please read 
# RFC 2045, 2046, 2047, 2048, and 2077.  The Internet media type
# registry is at <ftp://ftp.iana.org/assignments/media-types/>.

# MIME type			Extension"

	^'application/andrew-inset ez
application/chemtool cht
application/dicom dcm
application/docbook+xml docbook
application/ecmascript ecma
application/flash-video flv
application/illustrator ai
application/javascript
application/mac-binhex40
application/mathematica nb
application/msword doc docx
application/octet-stream bin
application/oda oda
application/ogg ogg
application/pdf pdf
application/pgp pgp
application/pgp-encrypted
application/pgp-encrypted pgp gpg
application/pgp-keys
application/pgp-keys skr pkr
application/pgp-signature
application/pgp-signature sig
application/pkcs7-mime
application/pkcs7-signature p7s
application/postscript ps
application/rtf rtf
application/sdp sdp
application/smil smil smi sml
application/stuffit sit
application/vnd.corel-draw cdr
application/vnd.hp-hpgl hpgl
application/vnd.hp-pcl pcl
application/vnd.lotus-1-2-3 123 wk1 wk3 wk4 wks
application/vnd.mozilla.xul+xml xul
application/vnd.ms-excel xls xlc xll xlm xlw xla xlt xld xlsx xltx
application/vnd.ms-powerpoint ppz ppt pps pot pptx potx ppsx
application/vnd.oasis.opendocument.chart odc
application/vnd.oasis.opendocument.database odb
application/vnd.oasis.opendocument.formula odf
application/vnd.oasis.opendocument.graphics odg
application/vnd.oasis.opendocument.graphics-template otg
application/vnd.oasis.opendocument.image odi
application/vnd.oasis.opendocument.presentation odp
application/vnd.oasis.opendocument.presentation-template otp
application/vnd.oasis.opendocument.spreadsheet ods
application/vnd.oasis.opendocument.spreadsheet-template ots
application/vnd.oasis.opendocument.text odt
application/vnd.oasis.opendocument.text-master odm
application/vnd.oasis.opendocument.text-template ott
application/vnd.oasis.opendocument.text-web oth
application/vnd.palm pdb
application/vnd.rn-realmedia
application/vnd.rn-realmedia rm
application/vnd.rn-realmedia-secure rms
application/vnd.rn-realmedia-vbr rmvb
application/vnd.stardivision.calc sdc
application/vnd.stardivision.chart sds
application/vnd.stardivision.draw sda
application/vnd.stardivision.impress sdd sdp
application/vnd.stardivision.mail smd
application/vnd.stardivision.math smf
application/vnd.stardivision.writer sdw vor sgl
application/vnd.sun.xml.calc sxc
application/vnd.sun.xml.calc.template stc
application/vnd.sun.xml.draw sxd
application/vnd.sun.xml.draw.template std
application/vnd.sun.xml.impress sxi
application/vnd.sun.xml.impress.template sti
application/vnd.sun.xml.math sxm
application/vnd.sun.xml.writer sxw
application/vnd.sun.xml.writer.global sxg
application/vnd.sun.xml.writer.template stw
application/vnd.wordperfect wpd
application/x-abiword abw abw.CRASHED abw.gz zabw
application/x-amipro sam
application/x-anjuta-project prj
application/x-applix-spreadsheet as
application/x-applix-word aw
application/x-arc
application/x-archive a
application/x-arj arj
application/x-asax asax
application/x-ascx ascx
application/x-ashx ashx
application/x-asix asix
application/x-asmx asmx
application/x-asp asp
application/x-awk
application/x-axd axd
application/x-bcpio bcpio
application/x-bittorrent torrent
application/x-blender blender blend BLEND
application/x-bzip bz bz2
application/x-bzip bz2 bz
application/x-bzip-compressed-tar tar.bz tar.bz2
application/x-bzip-compressed-tar tar.bz tar.bz2 tbz tbz2
application/x-cd-image iso
application/x-cgi cgi
application/x-chess-pgn pgn
application/x-chm chm
application/x-class-file
application/x-cmbx cmbx
application/x-compress Z
application/x-compressed-tar tar.gz tar.Z tgz taz
application/x-compressed-tar tar.gz tgz
application/x-config config
application/x-core
application/x-cpio cpio
application/x-cpio-compressed cpio.gz
application/x-csh csh
application/x-cue cue
application/x-dbase dbf
application/x-dbm
application/x-dc-rom dc
application/x-deb deb
application/x-designer ui
application/x-desktop desktop kdelnk
application/x-devhelp devhelp
application/x-dia-diagram dia
application/x-disco disco
application/x-dvi dvi
application/x-e-theme etheme
application/x-egon egon
application/x-executable exe
application/x-font-afm afm
application/x-font-bdf bdf
application/x-font-dos
application/x-font-framemaker
application/x-font-libgrx
application/x-font-linux-psf psf
application/x-font-otf
application/x-font-pcf pcf
application/x-font-pcf pcf.gz
application/x-font-speedo spd
application/x-font-sunos-news
application/x-font-tex
application/x-font-tex-tfm
application/x-font-ttf ttc TTC
application/x-font-ttf ttf
application/x-font-type1 pfa pfb gsf pcf.Z
application/x-font-vfont
application/x-frame
application/x-frontline aop
application/x-gameboy-rom gb
application/x-gdbm
application/x-gdesklets-display display
application/x-genesis-rom gen md
application/x-gettext-translation gmo
application/x-glabels glabels
application/x-glade glade
application/x-gmc-link
application/x-gnome-db-connection connection
application/x-gnome-db-database database
application/x-gnome-stones caves
application/x-gnucash gnucash gnc xac
application/x-gnumeric gnumeric
application/x-graphite gra
application/x-gtar gtar
application/x-gtktalog
application/x-gzip gz
application/x-gzpostscript ps.gz
application/x-hdf hdf
application/x-ica ica
application/x-ipod-firmware
application/x-jamin jam
application/x-jar jar
application/x-java class
application/x-java-archive jar ear war
application/x-java-jnlp-file jnlp
application/x-jbuilder-project jpr jpx
application/x-karbon karbon
application/x-kchart chrt
application/x-kformula kfo
application/x-killustrator kil
application/x-kivio flw
application/x-kontour kon
application/x-kpovmodeler kpm
application/x-kpresenter kpr kpt
application/x-krita kra
application/x-kspread ksp
application/x-kspread-crypt
application/x-ksysv-package
application/x-kugar kud
application/x-kword kwd kwt
application/x-kword-crypt
application/x-lha lha lzh
application/x-lha lzh
application/x-lhz lhz
application/x-linguist ts
application/x-lyx lyx
application/x-lzop lzo
application/x-lzop-compressed-tar tar.lzo tzo
application/x-macbinary
application/x-machine-config
application/x-magicpoint mgp
application/x-master-page master
application/x-matroska mkv
application/x-mdp mdp
application/x-mds mds
application/x-mdsx mdsx
application/x-mergeant mergeant
application/x-mif mif
application/x-mozilla-bookmarks
application/x-mps mps
application/x-ms-dos-executable exe
application/x-mswinurl
application/x-mswrite wri
application/x-msx-rom msx
application/x-n64-rom n64
application/x-nautilus-link
application/x-nes-rom nes
application/x-netcdf cdf nc
application/x-netscape-bookmarks
application/x-object o
application/x-ole-storage
application/x-oleo oleo
application/x-palm-database
application/x-palm-database pdb prc
application/x-par2 PAR2 par2
application/x-pef-executable
application/x-perl pl pm al perl
application/x-php php php3 php4
application/x-pkcs12 p12 pfx
application/x-planner planner mrproject
application/x-planperfect pln
application/x-prjx prjx
application/x-profile
application/x-ptoptimizer-script pto
application/x-pw pw
application/x-python-bytecode pyc pyo
application/x-quattro-pro wb1 wb2 wb3
application/x-quattropro wb1 wb2 wb3
application/x-qw qif
application/x-rar rar
application/x-rar-compressed rar
application/x-rdp rdp
application/x-reject rej
application/x-remoting rem
application/x-resources resources
application/x-resourcesx resx
application/x-rpm rpm
application/x-ruby
application/x-sc
application/x-sc sc
application/x-scribus sla sla.gz scd scd.gz
application/x-shar shar
application/x-shared-library-la la
application/x-sharedlib so
application/x-shellscript sh
application/x-shockwave-flash swf
application/x-siag siag
application/x-slp
application/x-smil kino
application/x-smil smi smil
application/x-sms-rom sms gg
application/x-soap-remoting soap
application/x-streamingmedia ssm
application/x-stuffit
application/x-stuffit bin sit
application/x-sv4cpio sv4cpio
application/x-sv4crc sv4crc
application/x-tar tar
application/x-tarz tar.Z
application/x-tex-gf gf
application/x-tex-pk k
application/x-tgif obj
application/x-theme theme
application/x-toc toc
application/x-toutdoux
application/x-trash   bak old sik
application/x-troff tr roff t
application/x-troff-man man
application/x-troff-man-compressed
application/x-tzo tar.lzo tzo
application/x-ustar ustar
application/x-wais-source src
application/x-web-config
application/x-wpg wpg
application/x-wsdl wsdl
application/x-x509-ca-cert der cer crt cert pem
application/x-xbel xbel
application/x-zerosize
application/x-zoo zoo
application/xhtml+xml xhtml
application/zip zip
audio/ac3 ac3
audio/basic au snd
audio/midi mid midi
audio/mpeg mp3
audio/prs.sid sid psid
audio/vnd.rn-realaudio ra
audio/x-aac aac
audio/x-adpcm
audio/x-aifc
audio/x-aiff aif aiff
audio/x-aiff aiff aif aifc
audio/x-aiffc
audio/x-flac flac
audio/x-m4a m4a
audio/x-mod mod ult uni XM m15 mtm 669
audio/x-mp3-playlist
audio/x-mpeg
audio/x-mpegurl m3u
audio/x-ms-asx
audio/x-pn-realaudio ra ram rm
audio/x-pn-realaudio ram rmm
audio/x-riff
audio/x-s3m s3m
audio/x-scpls pls
audio/x-scpls pls xpl
audio/x-stm stm
audio/x-voc voc
audio/x-wav wav
audio/x-xi xi
audio/x-xm xm
image/bmp bmp
image/cgm cgm
image/dpx
image/fax-g3 g3
image/g3fax
image/gif gif
image/ief ief
image/jpeg jpeg jpg jpe
image/jpeg2000 jp2
image/png png
image/rle rle
image/svg+xml svg
image/tiff tif tiff
image/vnd.djvu djvu djv
image/vnd.dwg dwg
image/vnd.dxf dxf
image/x-3ds 3ds
image/x-applix-graphics ag
image/x-cmu-raster ras
image/x-compressed-xcf xcf.gz xcf.bz2
image/x-dcraw bay BAY bmq BMQ cr2 CR2 crw CRW cs1 CS1 dc2 DC2 dcr DCR fff FFF k25 K25 kdc KDC mos MOS mrw MRW nef NEF orf ORF pef PEF raf RAF rdc RDC srf SRF x3f X3F
image/x-dib
image/x-eps eps epsi epsf
image/x-fits fits
image/x-fpx
image/x-icb icb
image/x-ico ico
image/x-iff iff
image/x-ilbm ilbm
image/x-jng jng
image/x-lwo lwo lwob
image/x-lws lws
image/x-msod msod
image/x-niff
image/x-pcx
image/x-photo-cd pcd
image/x-pict pict pict1 pict2
image/x-portable-anymap pnm
image/x-portable-bitmap pbm
image/x-portable-graymap pgm
image/x-portable-pixmap ppm
image/x-psd psd
image/x-rgb rgb
image/x-sgi sgi
image/x-sun-raster sun
image/x-tga tga
image/x-win-bitmap cur
image/x-wmf wmf
image/x-xbitmap xbm
image/x-xcf xcf
image/x-xfig fig
image/x-xpixmap xpm
image/x-xwindowdump xwd
inode/blockdevice
inode/chardevice
inode/directory
inode/fifo
inode/mount-point
inode/socket
inode/symlink
message/delivery-status
message/disposition-notification
message/external-body
message/news
message/partial
message/rfc822
message/x-gnu-rmail
model/vrml wrl
multipart/alternative
multipart/appledouble
multipart/digest
multipart/encrypted
multipart/mixed
multipart/related
multipart/report
multipart/signed
multipart/x-mixed-replace
text/calendar vcs ics
text/css css CSSL
text/directory vcf vct gcrd
text/enriched
text/html html htm
text/htmlh
text/javascript js
text/mathml mml
text/plain txt asc
text/rdf rdf
text/rfc822-headers
text/richtext rtx
text/rss rss
text/sgml sgml sgm
text/spreadsheet sylk slk
text/tab-separated-values tsv
text/vnd.rn-realtext rt
text/vnd.wap.wml wml
text/x-adasrc adb ads
text/x-authors
text/x-bibtex bib
text/x-boo boo
text/x-c++hdr hh
text/x-c++src cpp cxx cc C c++
text/x-chdr h h++ hp
text/x-comma-separated-values csv
text/x-copying
text/x-credits
text/x-csrc c
text/x-dcl dcl
text/x-dsl dsl
text/x-dsrc d
text/x-dtd dtd
text/x-emacs-lisp el
text/x-fortran f
text/x-gettext-translation po
text/x-gettext-translation-template pot
text/x-gtkrc
text/x-haskell hs
text/x-idl idl
text/x-install
text/x-java java
text/x-js js
text/x-ksysv-log
text/x-literate-haskell lhs
text/x-log log
text/x-makefile
text/x-moc moc
text/x-msil il
text/x-nemerle n
text/x-objcsrc m
text/x-pascal p pas
text/x-patch diff patch
text/x-python py
text/x-readme
text/x-rng rng
text/x-scheme scm
text/x-setext etx
text/x-speech
text/x-sql sql
text/x-suse-ymp ymp
text/x-suse-ymu ymu
text/x-tcl tcl tk
text/x-tex tex ltx sty cls
text/x-texinfo texi texinfo
text/x-texmacs tm ts
text/x-troff-me me
text/x-troff-mm mm
text/x-troff-ms ms
text/x-uil uil
text/x-uri uri url
text/x-vb vb
text/x-xds xds
text/x-xmi xmi
text/x-xsl xsl
text/x-xslfo fo xslfo
text/x-xslt xslt xsl
text/xmcd
text/xml xml
video/3gpp 3gp
video/dv dv dif
video/isivideo
video/mpeg mpeg mpg mp2 mpe vob dat
video/quicktime qt mov moov qtvr
video/vivo
video/vnd.rn-realvideo rv
video/wavelet
video/x-3gpp2 3g2
video/x-anim anim[1-9j]
video/x-avi
video/x-flic fli flc
video/x-mng mng
video/x-ms-asf asf asx
video/x-ms-wmv wmv
video/x-msvideo avi
video/x-nsv nsv NSV
video/x-real-video
video/x-sgi-movie movie
'! !

!MIMEMap class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
arrayFromApacheMimeTypes
	| collection stream |
	collection:= OrderedCollection new.
	stream := ReadStream on: self apacheMimeTypes.
	[stream atEnd] whileFalse:
		[ | col line word |
		col := OrderedCollection new.
		line := (stream upTo: Character cr) readStream.
		[line atEnd] whileFalse: [word := line upToSeparator. word notEmpty ifTrue: [col add: word] ].
		collection add: col].
	^collection

"MIMEMap arrayFromApacheMimeTypes"! !

!MIMEMap class methodsFor: 'accessing'!
arrayFromTextMimeTypes
	"MIMEMap arrayFromTextMimeTypes"
	| collection stream |
	collection:= OrderedCollection new.
	stream := ReadStream on: self textMimeTypes.
	[stream atEnd] whileFalse:
		[ | line word |
		line := (stream upTo: Character cr) readStream.
		word := line upToSeparator. word notEmpty ifTrue: [collection add: word] ].
	^collection! !

!MIMEMap class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
default
	^AIDASite default mimeMap! !

!MIMEMap class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!MIMEMap class methodsFor: 'accessing'!
textMimeTypes
	"which content/mime types are text based"
	"warning, not necessary complete!!"

	^'
application/docbook+xml
application/ecmascript
application/javascript
application/x-javascript
application/pkcs7-mime
application/pkcs7-signature
application/postscript
application/rtf
application/vnd.hp-hpgl
application/vnd.hp-pc
application/vnd.mozilla.xul+xml
application/x-cgi
application/x-config
application/x-csh
application/x-gettext-translation
application/x-jar
application/x-java
application/x-machine-config
application/x-perl
application/x-php
application/x-pkcs12
application/x-ruby
application/x-toc
application/x-web-config
application/x-wsdl
application/x-x509-ca-cert
application/xhtml+xml
image/svg+xml
message/delivery-status
message/disposition-notification
message/external-body
message/news
message/partial
message/rfc822
multipart/alternative
multipart/digest
multipart/encrypted
multipart/mixed
multipart/related
multipart/report
multipart/signed
multipart/x-mixed-replace
text/calendar
text/css
text/directory
text/enriched
text/html
text/htmlh
text/mathml
text/javascript
text/plain
text/rdf
text/rfc822-headers
text/richtext
text/rss
text/sgml sgml
text/spreadsheet sylk
text/tab-separated-values
text/vnd.rn-realtext
text/vnd.wap.wml
text/x-adasrc
text/x-authors
text/x-bibtex
text/x-boo
text/x-c++hdr
text/x-c++src
text/x-chdr
text/x-comma-separated-values
text/x-copying
text/x-credits
text/x-csrc
text/x-dcl
text/x-dsl
text/x-dsrc
text/x-dtd
text/x-emacs-lisp
text/x-fortran
text/x-gettext-translation
text/x-gettext-translation-template
text/x-gtkrc
text/x-haskell
text/x-idl
text/x-install
text/x-java
text/x-js
text/x-ksysv-log
text/x-literate-haskell
text/x-log
text/x-makefile
text/x-moc
text/x-msil
text/x-nemerle
text/x-objcsrc
text/x-pascal
text/x-patch
text/x-python
text/x-readme
text/x-rng
text/x-scheme
text/x-setext
text/x-speech
text/x-sql
text/x-suse-ymp
text/x-suse-ymu
text/x-tcl
text/x-tex
text/x-texinfo
text/x-texmacs
text/x-troff-me
text/x-troff-mm
text/x-troff-ms
text/x-uil
text/x-uri
text/x-vb
text/x-xds
text/x-xmi
text/x-xsl
text/x-xslfo
text/x-xslt
text/xmcd
text/xml

'! !

!MemberRole methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isEmployeeRole
	^true! !

!MemberRole methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isMemberRole
	^true! !

!MemberRole methodsFor: 'private' stamp: ' 10/1/08 16:41'!
printString
	^'aMemberRole ', self name! !

!Number methodsFor: '*Aida' stamp: 'JM 4/22/2007 18:59'!
printDotString
	"format and return the number with dots between thousandths:  '3.120.123' "
	| mrds millions thousanths rest text number |
	number := self abs.
	mrds := number // 1000000000.
	millions := (number \\ 1000000000)  // 1000000.
	thousanths := (number \\ 1000000) // 1000.
	rest := (number \\ 1000).
	text := ''.
	mrds > 0 ifTrue: 
		[text := mrds printString, '.', (millions withZeros), '.', 
		(thousanths withZeros), '.', (rest withZeros).
		^text].
	millions > 0 	ifTrue: 
		[text := millions printString, '.', 
		(thousanths withZeros), '.', (rest withZeros).
		^text].
	thousanths > 0 
		ifTrue: 
			[text := thousanths printString, '.', 
			(rest withZeros)]
		ifFalse: [text := rest printString].
	^(self < 0 ifTrue: ['- '] ifFalse: ['']), text

"
-123 printDotString  '- 123'
"! !

!Number methodsFor: '*Aida' stamp: 'JM 4/22/2007 18:59'!
withZeros
	"return three digit number with leading zeros"
	^(self < 100 ifTrue: ['0'] ifFalse: ['']), 
	(self < 10 ifTrue: ['0'] ifFalse: ['']), 
	self printString.! !

!Numberer methodsFor: 'private' stamp: ' 21/4/07 22:07'!
counters
	counters isNil ifTrue: [self initCounters].
	^counters! !

!Numberer methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
currentCounter: aSymbol
	"get curent (last nextCounter) number"
	(self counters includesKey: aSymbol) ifFalse: [self resetCounter: aSymbol].
	^self counters at: aSymbol! !

!Numberer methodsFor: 'accessing'!
decreaseCounter: aSymbol
	"decrease a current number, for instance if you deleted something with last number"
	(self currentCounter: aSymbol) = 0 ifTrue: [^nil].
	^self counters at: aSymbol put: (self currentCounter: aSymbol) - 1! !

!Numberer methodsFor: 'private' stamp: ' 21/4/07 22:07'!
decrementCounter: aSymbol
	"get next number and increment this counter"
	^self counters at: aSymbol put: (((self currentCounter: aSymbol) - 1) max: 0)! !

!Numberer methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initCounters
	counters := Dictionary new! !

!Numberer methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nextCounter: aSymbol
	"get next number and increment this counter"
	^self counters at: aSymbol put: (self peekCounter: aSymbol)! !

!Numberer methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
peekCounter: aSymbol
	"get next number but not increment it"
	(self counters includesKey: aSymbol) ifFalse: [self resetCounter: aSymbol].
	^(self counters at: aSymbol) + 1! !

!Numberer methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
resetCounter: aSymbol
	"put counter to 0, peekCounter will then return 1"
	self counters at: aSymbol put: 0! !

!Numberer methodsFor: 'private' stamp: ' 21/4/07 22:07'!
setCounter: aSymbol to: aNumber
	"use it sparingly!!"
	^self counters at: aSymbol put: aNumber! !

!Object methodsFor: '*Aida' stamp: 'np 3/16/2009 12:40'!
aidaCacheTimeout
	"how many seconds this object is globally cached in site's global cache"
	"nil = global default, set in site's global cache settings"
	^nil! !

!Object methodsFor: '*Aida' stamp: 'np 3/16/2009 12:40'!
aidaCacheView: aSymbol on: aWebSession
	"if true, then this object's view will be globally cached in site's cache"
	^false! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:23'!
aidaCanBeLocked
	"can we get an exclusive lock on that object (not already locked)?"
	^false! !

!Object methodsFor: '*Aida' stamp: 'jm 7/29/2010 12:40'!
aidaContentType
	"return 'text/html' as content type for web pages"
	"changed from previous #contentType, which can clash with other projects (already on 
	KomHTTPServer on Squeak/Pharo)"
	^'text/html'! !

!Object methodsFor: '*Aida' stamp: 'np 10/17/2008 17:47'!
aidaDeepCopy
	"Answer a copy of the receiver and copy down all its objects reachable from him"

	| objectDictionary |
	objectDictionary := IdentityDictionary new.
	^self aidaDeepCopyNotIn: objectDictionary.! !

!Object methodsFor: '*Aida' stamp: 'np 10/17/2008 17:47'!
aidaDeepCopyNotIn: aDictionary

	"Answer a copy of the receiver and copy down all its objects reachable from him. If altready in aDictionary, then not copy, return reference to already copied object"

	| class newObject index |

	self isNil ifTrue: [^self].
	(aDictionary includesKey: self) ifTrue:
		[^aDictionary at: self].

	class := self class.
	newObject := self copy.
	aDictionary at: self put: newObject.
	class isVariable
		ifTrue: 
			[class isPointers 
				ifTrue: 
					[index := self basicSize.
					1 to: index do:
						[ :i |  newObject basicAt: i put: 
							((self basicAt: i) aidaDeepCopyNotIn: aDictionary)  ]]
				ifFalse: ["already copied by self copy"] ]

		ifFalse: ["already copied by self copy"].
		
	1 to: class instSize do:
		[ :inx |  newObject 
				instVarAt: inx
				put: ((self instVarAt: inx) aidaDeepCopyNotIn: aDictionary)  
		].
	^newObject! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:23'!
aidaDontCache
	"don't cache web content in a browser. Appropriate header is added to http response"
	^false! !

!Object methodsFor: '*Aida'!
aidaIsAssociation
	"used for Aida/Web translation support, multilingual strings are namelly assocs: #fr->'Bonjour'"
	^false! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:24'!
aidaIsLocked
	"is object locked exclusively?"
	^false! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:24'!
aidaLock
	"get an exclusive lock on that object. Until unlocked, noon else can get that lock. Return false if already locked, true if successfull"
	^false! !

!Object methodsFor: '*Aida'!
aidaPresenterFor: aRequest on: aSession 
	"find appropriate web application or other presenter to represent itself"
	| ptype presenter |
	ptype := aRequest aidaPresentationType. "#web, #json, #xml"
	ptype = #web ifTrue:
		[presenter := self aidaWebAppFor: aSession.
		presenter notNil ifTrue: [^presenter composeWebPageFor: aRequest]].
	ptype = #json ifTrue:
		[^WebJSONPresenter newFor: self on: aSession].
	^self asWebAppNotFoundFor: aSession! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:24'!
aidaUnlock
	"release an exclusive lock if any"
	^true! !

!Object methodsFor: '*Aida' stamp: 'janko 8/25/2012 15:09'!
aidaWebAppFor: aSession
	"return an instance of appropriate App class for me. 
	If mobile app class exist, return that for request from mobile device"
	| webApp mobileApp|
	aSession isNil ifTrue: [^nil].
	webApp := aSession webAppFor: self.  "if already registered in a session"
	webApp notNil ifTrue: [^webApp].
	aSession isMobile ifTrue: "for mobile devices try to finf mobile App first"
		[mobileApp := WebMobileApplication newFor: self on: aSession. 
		mobileApp notNil ifTrue: [^aSession addWebApp: mobileApp for: self] ].
	webApp := WebMobileApplication newFor: self on: aSession. 
	webApp := WebApplication newFor: self on: aSession. "find and instantiate a right App for me"
	webApp notNil ifTrue: [^aSession addWebApp: webApp for: self].
	(self isBehavior and: [self allSuperclasses includes: WebApplication]) ifTrue: 
		[^aSession          "standalone App w/o link to domain"
			addWebApp: 
				(self basicNew session: aSession; initialize; setStandaloneApp) 
			for: self. ].
	^nil! !

!Object methodsFor: '*Aida' stamp: 'jm 8/3/2010 10:18'!
app
	"fastest and most convinient way to find a web app for that object"
	^self aidaWebAppFor: self firstSessionFromStack! !

!Object methodsFor: '*Aida' stamp: 'janko 3/19/2012 14:20'!
asWebAppNotFoundFor: aSession 
	| page |
	page := WebPage new.
	page addText: 'Cannot find aWebApplication for object a', self class name.
	^page! !

!Object methodsFor: '*Aida' stamp: 'janko 3/19/2012 14:47'!
changeToPreferredUrl
	"URL of that object is changed to one suggested by its #prefferedUrl method."
	"Note that its existing URLs are removed!!"
	"Call that method only from Apps, Widgets or Styles!!"
	^self app site urlResolver changeToPreferredUrl: self! !

!Object methodsFor: '*Aida' stamp: 'np 10/17/2008 17:40'!
deepSearchOfClass: aClassName 
	"finf all objects of that class down in object hierarchy"
	| objectDictionary class |
	objectDictionary := IdentityDictionary new.
	self aidaDeepCopyNotIn: objectDictionary.
	class := aClassName asSymbol.
	^ objectDictionary keys select: [ :each | each class name = class ]! !

!Object methodsFor: '*Aida' stamp: 'np 10/17/2008 17:40'!
deepSearchOfObsoleteClasses
	"find all objects of obsolete classes down in object hierarchy"
	| objectDictionary |
	objectDictionary := IdentityDictionary new.
	self aidaDeepCopyNotIn: objectDictionary.
	^ objectDictionary keys select: [ :each | each class isObsolete ]! !

!Object methodsFor: '*Aida' stamp: 'janko 3/19/2012 14:48'!
defaultToPreferredUrl
	"Default URL of that object is set to one suggested by its #prefferedUrl method."
	"Existing URLs are preserved, but just default URL used for automatic URL management"
	"Call that method only from Apps, Widgets or Styles!!"
	^self app site urlResolver defaultToPreferredUrl: self! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:26'!
expiresTimestamp
	"until when content of this object wont be changed"
	"used in http response, override if you like to be included"
	^self modifiedTimestamp  "to reload pages immediately"! !

!Object methodsFor: '*Aida' stamp: 'jm 8/20/2009 21:58'!
firstAppFromStack
	"try to find a first sender up in calling stack, who is  WebApplication"
	"Squeak specific!! "
	| stContext |
	stContext := thisContext.
	[stContext notNil] whileTrue: [
		(stContext receiver isKindOf: WebApplication) ifTrue: [^stContext receiver].
		stContext := stContext sender].
	^self firstContextFromStack app! !

!Object methodsFor: '*Aida' stamp: 'janko 11/1/2011 14:50'!
firstContextFromStack
	"try to find a first web execution context"
	"have we something faster?"
	| stContext request event |
	"Squeak specific!! "
	stContext := thisContext sender.
	[stContext notNil] whileTrue: [
		(stContext receiver isKindOf: WebContext) ifTrue:
			[^stContext receiver].
		(stContext receiver isKindOf: WebElement) ifTrue: 
			[stContext selector = #update ifTrue: 
				[^stContext receiver creationContext] ].  "a context of element to be updated, 
									  not necessary currenlty excecuting context!!"
		stContext := stContext sender].
	event := self firstEventFromStack.
	event notNil ifTrue: [^event context].
	request := self firstRequestFromStack.
	^request notNil ifTrue: [request context] ifFalse: [nil]! !

!Object methodsFor: '*Aida' stamp: 'jm 2/1/2011 21:21'!
firstEventFromStack
	"try to find a first sender up in calling stack which is an App and get a WebEvent of that call"
	"Squeak specific!! "
	| stContext isBlock |
	stContext := thisContext.
	[stContext notNil] whileTrue: [
		isBlock := AIDASite onPharo
			ifTrue: [stContext outerContext notNil] ifFalse: [stContext isBlock].	
		(isBlock not 
			and: [(stContext receiver isKindOf: WebApplication) 
				and: [stContext selector = #respondToEvent:]]) 				
					ifTrue: [^stContext at: 1].
		stContext := stContext sender].
	 stContext := thisContext.         "in case we execute in a separate web context's process"
	[stContext notNil] whileTrue: [
		(stContext receiver isKindOf: WebContext) ifTrue: [^stContext receiver request].
		stContext := stContext sender].
	^nil! !

!Object methodsFor: '*Aida' stamp: 'janko 6/25/2012 14:39'!
firstRequestFromStack
	"try to find a first sender up in calling stack, who is  AIDASite and get request of that call"
	"Squeak specific!! "
	| stContext isBlock |
	stContext := thisContext.
	[stContext notNil] whileTrue: [
		isBlock := AIDASite onPharo
			ifTrue: [stContext outerContext notNil] ifFalse: [stContext isBlock].	
		(isBlock not 
			and: [(stContext receiver isKindOf: AIDASite) 
				and: [stContext method numArgs > 1 
					and: [(stContext at: 2) isKindOf: HTTPRequest]] ])
						ifTrue: "AIDASite>>answer:toGetOrPost:on:"
							[^stContext at: 2].
		stContext := stContext sender].
	 stContext := thisContext.         "in case we execute in a separate web context's process"
	[stContext notNil] whileTrue: [
		(stContext receiver isKindOf: WebContext) ifTrue: [^stContext receiver request].
		stContext := stContext sender].
	^nil! !

!Object methodsFor: '*Aida' stamp: 'janko 6/25/2012 15:24'!
firstSessionFromStack
	"try to find a first sender up in calling stack, who is  AIDASite and get session if that call"
	"Squeak specific!! "
	| stContext isBlock |
	stContext := thisContext.
	[stContext notNil] whileTrue: [
		isBlock := AIDASite onPharo
			ifTrue: [stContext outerContext notNil] ifFalse: [stContext isBlock].	
		(isBlock not and: [stContext receiver isKindOf: AIDASite]) ifTrue: 	
			[(1 to: stContext method numArgs) do: [:inx | 
				(stContext at: inx) class == WebSession 
					ifTrue: [^(stContext at: inx)] ].
			^nil].
		stContext := stContext sender].
	stContext := thisContext.
	[stContext notNil] whileTrue: [
		isBlock := AIDASite onPharo
			ifTrue: [stContext outerContext notNil] ifFalse: [stContext isBlock].	
		(isBlock not and: [stContext receiver isKindOf: WebContext]) ifTrue: 	
			[^(stContext receiver app session)].
		stContext := stContext sender].
	^nil! !

!Object methodsFor: '*Aida' stamp: 'jm 11/10/2010 21:25'!
firstWidgetOrAppFromStack
	"try to find a first sender up in calling stack, which is subclass of Widget or WebApplication"
	"Squeak specific!! "
	| stContext |
	stContext := thisContext.
	[stContext notNil] whileTrue: [
		((stContext receiver isKindOf: WebWidget) or: [stContext receiver isKindOf: WebApplication]) 
			ifTrue: [^stContext receiver].
		stContext := stContext sender].
	^nil! !

!Object methodsFor: '*Aida' stamp: 'mivsek 1/10/2008 18:14'!
forLanguage: aLanguageCodeSymbol
	"for multilingual support: returns an apropriate instance of itself for that language. 
	Langage is defined by ISO 639 2-letter language code, see 
	http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes"
	^false! !

!Object methodsFor: '*Aida' stamp: 'mivsek 1/10/2008 18:14'!
isMultilingual
	"for multilingual support: override this if your domain object responds 
	to #forLanguage: and returns an apropriate instance of itself for that language"
	^false! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:27'!
isVersionedObject
	^false! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:27'!
isWebApplication
	^false! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:27'!
isWebStyle
	^false! !

!Object methodsFor: '*Aida' stamp: 'jm 12/14/2010 23:43'!
isWebWidget
	^false! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:27'!
modifiedTimestamp
	"when this object was last modified"
	"used in http response, override if you like to be included"
	^nil! !

!Object methodsFor: '*Aida'!
preferedUrl
	"OBSOLETE!! Use a corrently spelling method with double r instead!!"
	^self preferredUrl! !

!Object methodsFor: '*Aida' stamp: 'janko 3/19/2012 13:21'!
preferredUrl
	"override with a suggestion for url of this method!! If not already used, 
	it will be considered by URLResolver during automatic url generation"
	^nil! !

!Object methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:29'!
sendOver: aStream 
	"from Wiki rendering"
	self printOn: aStream! !

!Object methodsFor: '*Aida' stamp: 'janko 3/19/2012 14:51'!
widgetsAndAppsFromStack
	"try to find a first sender up in calling stack, which is subclass of Widget or WebApplication"
	"Squeak specific!! "
	| stContext coll |
	stContext := thisContext.
	coll := OrderedCollection new.
	[stContext notNil] whileTrue: [
		((stContext receiver isKindOf: WebWidget) or: [stContext receiver isKindOf: WebApplication]) 
			ifTrue: [(coll includes: stContext receiver) ifFalse: [coll add: stContext receiver] ].
		stContext := stContext sender].
	^coll! !

!OrderedCollection methodsFor: '*Aida' stamp: 'np 8/22/2008 18:40'!
moveDown: anElement
	"move that element down (after current position) in a collection"
	| inx |
	(self notEmpty and: [self last = anElement]) ifTrue: [^self].
	inx := self indexOf: anElement.
	self add: anElement beforeIndex: inx+2.
	self removeAt: inx
	"#(1 2 3) asOrderedCollection moveDown: 1"! !

!OrderedCollection methodsFor: '*Aida' stamp: 'np 8/22/2008 18:40'!
moveUp: anElement
	"move that element up (before current position) in a collection"
	| inx |
	(self notEmpty and: [self first = anElement]) ifTrue: [^self].
	inx := self indexOf: anElement.
	self add: anElement beforeIndex: inx-1.
	self removeAt: inx+1
	"#(1 2 3) asOrderedCollection moveUp: 3"! !

!OrderedCollection methodsFor: '*Aida' stamp: 'mivsek 2/20/2008 10:21'!
removeAll
	"remove all elements quickly"
	self removeAllSuchThat: [:each | true]. "Squeak specific. #become: is VERY slow!!"
"	self become: OrderedCollection new " "VW specific"! !

!OrganizationUnit methodsFor: 'job roles' stamp: 'janko 8/6/2011 19:38'!
addJobRoleNamed: aString
	(self existJobRoleNamed: aString) ifTrue: [^nil].
	self otherAt: #jobRoles ifAbsent: 
		[self otherAt: #jobRoles put: OrderedCollection new].
	(self otherAt: #jobRoles) add: (JobRole new name: aString)! !

!OrganizationUnit methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
addMember: aPerson
	aPerson becomeMemberOf: self! !

!OrganizationUnit methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
addOrganizationUnit: anOrganizationUnit
	units isNil ifTrue: [self initUnits].
	(self units includes: anOrganizationUnit) ifFalse:
		[self units add: anOrganizationUnit. anOrganizationUnit parent: self]! !

!OrganizationUnit methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
addOrganizationUnitNamed: aString
	self addOrganizationUnit: (OrganizationUnit newNamed: aString)! !

!OrganizationUnit methodsFor: 'roles-special' stamp: ' 10/1/08 16:40'!
addSpecialRoleNamed: aName
	(self existSpecialRoleNamed: aName) ifFalse:
		[self specialRoles add: (Role new name: aName)]! !

!OrganizationUnit methodsFor: 'job roles' stamp: 'janko 8/6/2011 19:42'!
allJobRoles
	^self otherAt: #jobRoles ifAbsent: [^#()]! !

!OrganizationUnit methodsFor: 'accessing' stamp: 'np 10/20/2008 16:37'!
allJobRolesDownHierarchy
	"incudes me"
	^self allOrgUnits "down hierarchy"
		inject: Set new
		into: [:set :each | set addAll: each allJobRoles; yourself]! !

!OrganizationUnit methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
allMembers
	"all members of that org.unit"
	| parties |
	parties :=  (self roles select: [:role | role isMemberRole]) 
		collect: [:each | each relatedParty].
	parties := parties addAll:
		((self relatedPartyRoles select: [:role | role isMemberRole]) 
			collect: [:each | each party]);
		yourself.
	^parties asSet asOrderedCollection! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
allOrgUnits
	"all units down in hierarchy, together with self"
	| collection |
	collection := OrderedCollection new.
	collection add: self.
	self units do: [:each | collection addAll: each allOrgUnits].
	^collection! !

!OrganizationUnit methodsFor: 'job roles' stamp: ' 10/1/08 16:40'!
allPersonsWithJobRoles
	"collect all persons holding job roles in this org unit"
	^self allJobRoles inject: Set new into: [:set :role | set addAll: role allPersons; yourself].! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
company
	"return a company whom belongs that org.unit"
	^self parent company! !

!OrganizationUnit methodsFor: 'job roles' stamp: 'janko 8/6/2011 19:42'!
existJobRoleNamed: aString
	^(self otherAt: #jobRoles ifAbsent: [^false])
		contains: [:each | each name = aString]! !

!OrganizationUnit methodsFor: 'roles-special' stamp: ' 10/1/08 16:40'!
existSpecialRoleNamed: aName
	^(self specialRoleNamed: aName) notNil! !

!OrganizationUnit methodsFor: 'initialize-release' stamp: ' 10/1/08 16:40'!
initSpecialRoles
	specialRoles := OrderedCollection new! !

!OrganizationUnit methodsFor: 'initialize-release' stamp: ' 10/1/08 16:40'!
initUnits
	units := OrderedCollection new! !

!OrganizationUnit methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
isOrganizationUnit
	^true! !

!OrganizationUnit methodsFor: 'job roles' stamp: 'janko 8/6/2011 19:42'!
jobRoleNamed: aString
	^(self otherAt: #jobRoles ifAbsent: [^nil])
		detect: [:each | each name = aString] ifNone: [nil]! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
jobRoleWithUuid: aString
	"search for this job role through hierarchy starting from self"
	| found |
	^self allJobRoles detect: [:each | each uuid = aString] ifNone:
		[self units do: [:each | found := each jobRoleWithUuid: aString. found notNil ifTrue: [^found] ].
		nil]! !

!OrganizationUnit methodsFor: 'private' stamp: ' 10/1/08 16:40'!
migrateToUnicode
	"from iso8859-2"
	"OrganizationUnit allInstances do: [:each | each migrateToUnicode]"
	super migrateToUnicode.! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
orgUnitWithName: aString
	"search for this org.unit through hierarchy starting from self"
	| found |
	self name = aString ifTrue: [^self].
	self units do: [:each | each name = aString ifTrue: [^each] ].
	self units do: [:each | 
		found := each orgUnitWithName: aString. found notNil ifTrue: [^found] ].
	^nil! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
orgUnitWithUuid: aString
	"search for this org.unit through hierarchy starting from self"
	| found |
	self uuid = aString ifTrue: [^self].
	self units do: [:each | each uuid = aString ifTrue: [^each] ].
	self units do: [:each | found := each orgUnitWithUuid: aString. found notNil ifTrue: [^found] ].
	^nil! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
parent
	^parent! !

!OrganizationUnit methodsFor: 'private' stamp: ' 10/1/08 16:40'!
parent: anOrganizationUnit
	parent := anOrganizationUnit! !

!OrganizationUnit methodsFor: 'private' stamp: 'janko 3/19/2012 13:21'!
preferredUrl
	| nme |
	nme := self name trimBlanks asSloveneWithoutCircumflexes.
	^'/org-enota/', nme asHttpFriendly.

"OrganizationUnit allInstances do: [:each | 
	each repository notNil ifTrue: [each repository site urlResolver changeToPreferedURL: each] ]"! !

!OrganizationUnit methodsFor: 'private'!
printString
	^'orgUnit: ', self name! !

!OrganizationUnit methodsFor: 'job roles' stamp: 'janko 8/6/2011 19:39'!
removeJobRole: aJobRole
	self otherAt: #jobRoles ifAbsent: [^nil].
	(self otherAt: #jobRoles) remove: aJobRole ifAbsent: [^nil]! !

!OrganizationUnit methodsFor: 'job roles' stamp: 'janko 8/6/2011 19:39'!
removeJobRoleNamed: aString
	(self existJobRoleNamed: aString) ifFalse: [^nil].
	(self otherAt: #jobRoles) remove: (self jobRoleNamed: aString)! !

!OrganizationUnit methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
removeMember: aPerson
	aPerson noMoreMemberOf: self! !

!OrganizationUnit methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
removeOrganizationUnit: anOrganizationUnit
	units isNil ifTrue: [^nil].
	(self units includes: anOrganizationUnit) ifTrue:
		[self units remove: anOrganizationUnit. anOrganizationUnit parent: nil]! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
repository
	self parent isNil ifTrue: [^nil].
	self parent class == Repository ifTrue: [^self parent].
	^self parent repository! !

!OrganizationUnit methodsFor: 'roles-special' stamp: ' 10/1/08 16:40'!
specialRoleCollection
	"all specail roles for that and parent org.units up in to the top of hierarchy.
	sorted by the top first!!"
	^(self parent notNil and: [self parent isKindOf: Party])
		ifTrue: [self parent specialRoleCollection addAll: self specialRoles; yourself]
		ifFalse: [self specialRoles]! !

!OrganizationUnit methodsFor: 'roles-special' stamp: ' 10/1/08 16:40'!
specialRoleNamed: aName
	^self specialRoles detect: [:each | each name = aName] ifNone: [nil]! !

!OrganizationUnit methodsFor: 'roles-special'!
specialRoles
	"a set of roles, special a for member of that org.unit, like aprover, tester etc"
	specialRoles isNil ifTrue: [self initSpecialRoles].
	^specialRoles! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
type
	^type! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
type: aSymbol
	"kind of org.unit like #division #sector #group etc."
	type := aSymbol! !

!OrganizationUnit methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
units
	units isNil ifTrue: [^#()].
	^units! !

!OrganizationUnit class methodsFor: 'instance creation' stamp: ' 10/1/08 16:40'!
newNamed: aString
	^self new name: aString! !

!OrganizationUnit class methodsFor: 'odb specific' stamp: ' 10/1/08 16:40'!
replicationSpecaa
	"Gemstone"
	^super replicationSpec! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testAddress! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testCompany! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testCompanyEmployees! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testEvents! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testOrgUnitJobRoles! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testOrganizationUnit! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testPerson! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testPersonDocumentsToKnow! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testPersonRecordFlows! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testPersonResponsibilities! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testPersonRoles! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testRoleGroups! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testRoles! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testRolesBasic! !

!PartiesTest methodsFor: 'testing' stamp: ' 10/1/08 23:12'!
testRolesSpecific! !

!Party methodsFor: 'related objects' stamp: ' 10/1/08 16:40'!
addRelatedObject: anObject
	(self relatedObjects includes: anObject) ifFalse:
		[self relatedObjects add: anObject].! !

!Party methodsFor: 'private' stamp: ' 10/1/08 16:40'!
addRelatedPartyRole: aRole
	(self relatedPartyRoles includes: aRole) ifTrue: [^nil].
	self relatedPartyRoles add: aRole.! !

!Party methodsFor: 'private' stamp: ' 10/1/08 16:40'!
addRole: aRole
	(self roles includes: aRole) ifTrue: [^nil].
	self roles add: aRole.! !

!Party methodsFor: 'role groups' stamp: ' 10/1/08 16:40'!
addRoleGroup: aRoleGroup
	(self roleGroups includes: aRoleGroup) ifFalse: [self roleGroups add: aRoleGroup]! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
addresses
	addresses isNil ifTrue: [self initAddresses].
	^addresses! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
allCustomers
	"return all parties which are my customers, therefore I am a supplier to them"
	| parties |
	parties :=  (self roles select: [:role | role isSupplierRole]) 
		collect: [:each | each relatedParty].
	parties := parties addAll:
		((self relatedPartyRoles select: [:role | role isCustomerRole]) 
			collect: [:each | each party]);
		yourself.
	^parties asSet asOrderedCollection! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
allEmployees
	"all employees of that party"
	| parties |
	parties :=  (self roles select: [:role | role isEmployeeRole]) 
		collect: [:each | each relatedParty].
	parties := parties addAll:
		((self relatedPartyRoles select: [:role | role isEmployeeRole]) 
			collect: [:each | each party]);
		yourself.
	^parties asSet asOrderedCollection! !

!Party methodsFor: 'roles-basic' stamp: ' 10/1/08 16:40'!
allRelatedRolesFrom: aParty
	"return all roles this party has to me"
	^self relatedPartyRoles select: [:each | each party == aParty]! !

!Party methodsFor: 'role groups' stamp: ' 10/1/08 16:40'!
allRoleGroups
	^self roleGroups copy! !

!Party methodsFor: 'roles-basic' stamp: ' 10/1/08 16:40'!
allRoles
	^self roles copy! !

!Party methodsFor: 'roles-basic' stamp: ' 10/1/08 16:40'!
allRolesTo: aParty
	"return all roles I have to this party"
	^self roles select: [:each | each relatedParty == aParty]! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
allSuppliers
	"return all parties which supply goods to me, therefore I am a customer of them"
	| parties |
	parties :=  (self roles select: [:role | role isCustomerRole]) 
		collect: [:each | each relatedParty].
	parties := parties addAll:
		((self relatedPartyRoles select: [:role | role isSupplierRole]) 
			collect: [:each | each party]); 
		yourself.
	^parties asSet asOrderedCollection! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
becomeCustomerOf: aParty
	"I become a customer of related party, I buy goods from this party"
	| role |
	(self isCustomerOf: aParty) ifTrue: [^false].
	role := CustomerRole new.
	role name: 'customer role'.
	self newRole: role relatedTo: aParty! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
becomeSiteOwner
	"usual for Companies, SiteOwnerRole has a reference to his WebSite"! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
becomeSupplierTo: aParty 
	"I become a supplier to related party, I supply goods to this party"
	| role |
	(self isSupplierTo: aParty) ifTrue: [^false].
	role := SupplierRole new.
	role name: 'supplier role'.
	self newRole: role relatedTo: aParty! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
becomeWebUserTo: aWebSiteOwnerPary! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
city
	^self mainAddress city! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
city: aString
	self mainAddress city: aString! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
country
	^self mainAddress country! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
country: aString
	self mainAddress country: aString! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
description
	description isNil ifTrue: [self description: ''].
	^description! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
description: aString
	description := aString! !

!Party methodsFor: 'roles-basic' stamp: ' 10/1/08 16:40'!
discontinueAllRoles
	self roles copy do: [:each | self discontinueRole: each].
	self relatedPartyRoles copy do: [:each | self discontinueRole: each]! !

!Party methodsFor: 'roles-basic' stamp: ' 10/1/08 16:40'!
discontinueAllRolesTo: aParty
	(self roles select: [:role | role relatedParty == aParty])
		do: [:each | self discontinueRole: each].! !

!Party methodsFor: 'roles-basic' stamp: ' 10/1/08 16:40'!
discontinueRole: aRole
	self roles remove: aRole ifAbsent: [].
	aRole relatedParty relatedPartyRoles remove: aRole ifAbsent: [].! !

!Party methodsFor: 'roles-basic'!
discontinueRoleNamed: aString
	| r |
	r := self roleNamed: aString.
	r notNil ifTrue: [self discontinueRole: r]! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
email
	^self mainAddress email! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
email: aString
	self mainAddress email: aString! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
events
	events isNil ifTrue: [self initEvents].
	^events! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
fax
	^self mainAddress fax! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
fax: aString
	self mainAddress fax: aString! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
id
	id isNil ifTrue: [self id: ''].
	^id! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
id: aString
	id := aString.! !

!Party methodsFor: 'initialize - release' stamp: ' 10/1/08 16:40'!
initAddresses
	addresses := Dictionary new.! !

!Party methodsFor: 'initialize - release' stamp: ' 10/1/08 16:40'!
initEvents
	events := DailyCollection new.! !

!Party methodsFor: 'initialize - release' stamp: 'janko 8/6/2011 19:49'!
initOtherValues
	other := Dictionary new.! !

!Party methodsFor: 'initialize - release' stamp: ' 10/1/08 16:40'!
initRelatedObjects
	relatedObjects := OrderedCollection new.! !

!Party methodsFor: 'initialize - release' stamp: ' 10/1/08 16:40'!
initRelatedPartyRoles
	relatedPartyRoles := OrderedCollection new.! !

!Party methodsFor: 'initialize - release' stamp: ' 10/1/08 16:40'!
initRoles
	roles := OrderedCollection new.! !

!Party methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
isCompany
	^false! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
isCustomerOf: aParty

	| isCustomer |
	isCustomer := self roles contains: [:role | role relatedParty == aParty and: [role isCustomerRole] ].
	isCustomer ifTrue: [^true].
	"check also a complementary role"
	^self relatedPartyRoles contains: [:role | role party == aParty and: [role isSupplierRole] ].! !

!Party methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
isOrganizationUnit
	^false! !

!Party methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
isPerson
	^false! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
isSupplierTo: aParty

	| isSupplier |
	isSupplier := self roles contains: [:role | role relatedParty == aParty and: [role isSupplierRole] ].
	isSupplier ifTrue: [^true].
	"check also a complementary role"
	^self relatedPartyRoles contains: [:role | role party == aParty and: [role isCustomerRole] ].! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
mainAddress
	
	^self addresses 
		at: #MainAddress 
		ifAbsent: [self addresses at: #MainAddress put: Address new. self mainAddress].! !

!Party methodsFor: 'addresses' stamp: 'janko 4/20/2012 17:15'!
mobile
	^self mainAddress mobile! !

!Party methodsFor: 'addresses' stamp: 'janko 4/20/2012 17:16'!
mobile: aString
	self mainAddress mobile: aString! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
name
	name isNil ifTrue: [self name: ''].
	^name! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
name: aString
	name := aString trimBlanks.! !

!Party methodsFor: 'accessing'!
nameNonEmpty
	^self name trimBlanks notEmpty 
		ifTrue: [self name] 
		ifFalse: ['-- no name --'].! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
nameToDisplay
	"on web pages for instance"
	^self name! !

!Party methodsFor: 'roles-basic' stamp: ' 10/1/08 16:40'!
newRole: aRole
	"new role, but not in relationship with anyone"! !

!Party methodsFor: 'roles-basic' stamp: ' 10/1/08 16:40'!
newRole: aRole relatedTo: aParty
	"new role in relationship with other party"

	aRole party: self.
	aRole relatedParty: aParty.
	self addRole: aRole.
	aParty addRelatedPartyRole: aRole.! !

!Party methodsFor: 'roles-basic'!
newRoleNamed: aString
	"new role, but not in relationship with anyone"
	| new |
	(self roleNames includes: aString) ifTrue: [^self error: 'role with that name already exist'].
	new := Role new name: aString.
	self newRole: new! !

!Party methodsFor: 'roles-basic'!
newRoleNamed: aString relatedTo: aParty
	"new role in relationship with other party"
	| new |
	(self roleNames includes: aString) ifTrue: [^self error: 'role with that name already exist'].
	new := Role new name: aString.
	self newRole: new relatedTo: aParty! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
noMoreCustomerOf: aParty 
	"no more a customer of related party"
	(self isCustomerOf: aParty) ifFalse: [^nil].
	self discontinueRole:
		(self roles detect: [:role | role relatedParty == aParty and: [role isCustomerRole] ] ifNone: [^nil])! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
noMoreSupplierTo: aParty 
	"no more a supplier to related party"
	(self isSupplierTo: aParty) ifFalse: [^nil].
	self discontinueRole:
		(self roles detect: [:role | role relatedParty == aParty and: [role isSupplierRole] ] ifNone: [^nil])! !

!Party methodsFor: 'private' stamp: 'janko 8/6/2011 19:49'!
other
	^other! !

!Party methodsFor: 'private' stamp: 'janko 8/6/2011 19:43'!
otherAt: aString
	^self otherAt: aString ifAbsent: [nil]! !

!Party methodsFor: 'private' stamp: 'janko 8/6/2011 19:44'!
otherAt: aString ifAbsent: aBlock
	self other isNil ifTrue: [^aBlock value].
	^self other at: aString ifAbsent: [aBlock value]! !

!Party methodsFor: 'private' stamp: 'janko 8/6/2011 19:44'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOtherValues].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!Party methodsFor: 'private' stamp: 'janko 8/6/2011 19:44'!
otherAt: aString put: anObject
	self other isNil ifTrue: [self initOtherValues].
	^self other at: aString put: anObject! !

!Party methodsFor: 'private' stamp: ' 10/1/08 16:40'!
partialyConnectedRoles
	"roles, which are not correctly connected to related party and back"
	"not working well yet !!!!!! "
	| col |
	col := self roles reject: [:each | each relatedParty roles contains: [:role | role relatedParty == self] ].
	col addAll: (self relatedPartyRoles 
		reject: [:each | each relatedParty roles contains: [:role | role party == self] ]).
	^col

"Company allInstances select: [:each | each partialyConnectedRoles notEmpty]"! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
phone
	^self mainAddress phone! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
phone: aString
	self mainAddress phone: aString! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
post
	^self mainAddress post! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
post: anObject
	^self mainAddress post: anObject! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
postalCode
	^self mainAddress postalCode! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
postalCode: aString
	self mainAddress postalCode: aString! !

!Party methodsFor: 'private' stamp: ' 10/1/08 16:40'!
printString
	^'party: ', self name! !

!Party methodsFor: 'private' stamp: ' 10/1/08 16:40'!
reconnectEmployees
	"for debugging"
	self allEmployees do: [:each | self removeEmployee: each; addEmployee: each]! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
relatedObjects
	relatedObjects isNil ifTrue: [self initRelatedObjects].
	^relatedObjects! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
relatedParty
	"which party is the 'owner', e.g. doing business in elogis terms with that party"

	| thirdPLCustomers parties |
	thirdPLCustomers := LogisticSystem default owner all3PLCustomers.
	parties := thirdPLCustomers select: [:party | party isSupplierTo: self].
	^parties isEmpty 
		ifTrue: 
			[parties := thirdPLCustomers select: [:party | party isCustomerOf: self].
			parties isEmpty ifTrue: [^nil] ifFalse: [parties first] ]
		ifFalse: [parties first]! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
relatedPartyRoles
	relatedPartyRoles isNil ifTrue: [self initRelatedPartyRoles].
	^relatedPartyRoles! !

!Party methodsFor: 'related objects' stamp: ' 10/1/08 16:40'!
removeRelatedObject: anObject
	self relatedObjects remove: anObject ifAbsent: []! !

!Party methodsFor: 'role groups' stamp: ' 10/1/08 16:40'!
removeRoleGroup: aRoleGroup
	(self roleGroups includes: aRoleGroup) ifTrue: [self roleGroups remove: aRoleGroup]! !

!Party methodsFor: 'role groups' stamp: ' 10/1/08 16:40'!
roleGroupNamed: aString
	^self roleGroups detect: [:each | each name = aString] ifNone: [nil]! !

!Party methodsFor: 'role groups' stamp: ' 10/1/08 16:40'!
roleGroupWithUuid: aString
	^self roleGroups detect: [:each | each uuid = aString] ifNone: [nil]! !

!Party methodsFor: 'role groups' stamp: 'janko 8/6/2011 19:39'!
roleGroups
	(self otherAt: #roleGroups) isNil ifTrue: 
		[self otherAt: #roleGroups put: OrderedCollection new].
	^self otherAt: #roleGroups! !

!Party methodsFor: 'role groups' stamp: ' 10/1/08 16:40'!
roleGroupsIncludeRole: aRole
	^self roleGroups select: [:each | each includes: aRole]! !

!Party methodsFor: 'roles-basic'!
roleNamed: aString
	"find a role with that name"
	^self roles detect: [:each | each name = aString] ifNone: [nil]! !

!Party methodsFor: 'accessing'!
roleNames
	"names of roles this party plays"
	^self roles collect: [:each | each name].! !

!Party methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
roles
	roles isNil ifTrue: [self initRoles].
	^roles! !

!Party methodsFor: 'accessing'!
rolesText
	"names of roles this party plays, in one string separated with commas"
	| text |
	text := ''.
	1 to: self roleNames size do: [:inx |
		text := text, (self roleNames at: inx).
		inx = self roleNames size ifFalse: [text := text, ', '] ].
	^text! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
searchEmployeesWithSurname: aSurname name: aName
	| surname nme |
	surname := aSurname asLowercase, '*'. nme := aName asLowercase, '*'.
	^self allEmployees select: [:each | 
		(surname match: each surname asLowercase) and: [nme match: each name asLowercase] ]! !

!Party methodsFor: 'roles-specific' stamp: ' 10/1/08 16:40'!
searchEmployeesWithSurnameName: aString
	| string nm |
	string := aString asLowercase, '*'. 
	^self allEmployees select: [:each | 
		nm := each surnameName asLowercase.
		(string match: nm)].! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
street
	^self mainAddress street! !

!Party methodsFor: 'addresses' stamp: ' 10/1/08 16:40'!
street: aString
	self mainAddress street: aString! !

!Party methodsFor: 'changing' stamp: ' 10/1/08 16:40'!
updateFrom: aParty
	self name: aParty name.
	self description: aParty description.
	self city: aParty city.
	self street: aParty street.
	self postalCode: aParty postalCode.! !

!Party methodsFor: 'accessing' stamp: 'janko 8/6/2011 19:43'!
uuid
	"unique identifier "
	^self otherAt: #uuid ifAbsentPut: [(AIDASite random next * 1000000000) rounded printString]! !

!Party class methodsFor: 'instance creation' stamp: ' 10/1/08 16:40'!
newCustomerOf: aParty

	^super new
		becomeCustomerOf: aParty! !

!Party class methodsFor: 'instance creation' stamp: ' 10/1/08 16:40'!
newSupplierTo: aParty

	^super new
		becomeSupplierTo: aParty! !

!Party class methodsFor: 'odb specific' stamp: ' 10/1/08 16:40'!
replicationSpec
	"Gemstone"
	^super replicationSpec , 
		#( 	(id 	replicate)
			(name replicate)
			(description replicate)
			(addresses max 4)
			(roles max 2)
			(relatedPartyRoles max 2)
			(events forwarder)
			(relatedObjects max 1) )! !

!PartyCollection methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
add: aPartyOrRole
	"anOrganizationalUnit, aRole, aRoleGroup or aPerson"
	self parties add: aPartyOrRole! !

!PartyCollection methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
addAll: aPartyCollection
	aPartyCollection do: [:each | self add: each]! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
all
	^self parties copy! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
allJobRoles
	^self parties select: [:each | each isKindOf: JobRole].! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
allOrgUnits
	^self parties select: [:each | each isKindOf: OrganizationUnit].! !

!PartyCollection methodsFor: 'accessing-parent' stamp: ' 10/1/08 16:40'!
allParentJobRoles
	^self parent allOrgUnits
		inject: OrderedCollection new into: [:col :each | col addAll: each allJobRoles; yourself]! !

!PartyCollection methodsFor: 'accessing-parent' stamp: ' 10/1/08 16:40'!
allParentOrgUnits
	^self parent allOrgUnits! !

!PartyCollection methodsFor: 'accessing-parent' stamp: ' 10/1/08 16:40'!
allParentOrgUnitsRolesPersons
	"sorted in that order.."
	| all |
	all := (SortedCollection withAll: self allParentOrgUnits sortBlock: [:a :b | a name < b name]) 
		asOrderedCollection.
	all addAll: (SortedCollection withAll: self allParentRoleGroups sortBlock: [:a :b | a name < b name]).
	all addAll: (SortedCollection withAll: self allParentJobRoles sortBlock: [:a :b | a name < b name]).
	all addAll: (SortedCollection withAll: self allParentPersons 
		sortBlock: [:a :b | a surnameName < b surnameName]).
	^all! !

!PartyCollection methodsFor: 'accessing-parent' stamp: ' 10/1/08 16:40'!
allParentPersons
	^self parent allEmployees! !

!PartyCollection methodsFor: 'accessing-parent' stamp: ' 10/1/08 16:40'!
allParentRoleGroups
	^self parent allRoleGroups! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
allPersons
	"both individual, from job roles and from org.units"
	| persons |
	persons := self onlyPersons asSet.
	persons := self allOrgUnits inject: persons into: [:set :each | set addAll: each allMembers; yourself].
	persons addAll: self allPersonsFromJobRoles.
	persons addAll: self allPersonsFromRoleGroups.
	^persons asOrderedCollection! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
allPersonsFromJobRoles
	| jobRoles  |
	jobRoles := self allJobRoles asSet.
	^self allParentPersons select: [:each |
		each jobRole notNil and: [jobRoles includes: each jobRole parentRole] ].

"	^self allJobRoles inject: Set new into: [:set :each | set addAll: each allPersons; yourself]."! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
allPersonsFromOrgUnit: anOrgUnit
	| members |
	members := anOrgUnit allMembers asSet.
	^self allPersons select: [:each | members includes: each]! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
allPersonsFromRoleGroups
	| jobRoles |
	jobRoles := self allRoleGroups inject: Set new into: [:set :each | set addAll: each allRoles; yourself].
	^self allParentPersons select: [:each |
		each jobRole notNil and: [jobRoles includes: each jobRole parentRole] ]! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
allRoleGroups
	^self parties select: [:each | each isKindOf: RoleGroup].! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
allSorted
	"org.unitss first, then role groups, roles, persons"
	| all |
	all := (SortedCollection withAll: self allOrgUnits sortBlock: [:a :b | a name < b name]) 
		asOrderedCollection.
	all addAll: (SortedCollection withAll: self allRoleGroups sortBlock: [:a :b | a name < b name]).
	all addAll: (SortedCollection withAll: self allJobRoles sortBlock: [:a :b | a name < b name]).
	all addAll: (SortedCollection withAll: self onlyPersons 
		sortBlock: [:a :b | a surnameName < b surnameName]).
	^all! !

!PartyCollection methodsFor: 'accessing'!
allSortedText
	"org.unitss first, then role groups, roles, persons, as text"
	| sorted text |
	sorted := self allSorted asOrderedCollection.
	text := ''.
	sorted do: [:each |
		(each isKindOf: Person) ifTrue: [text := text, each surnameName].
		(each isKindOf: OrganizationUnit) ifTrue: [text := text, each name].
		(each isKindOf: RoleGroup) ifTrue: [text := text, each name].
		each = sorted last ifFalse: [text := text, ', '] ].
	^text! !

!PartyCollection methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
from: aPartyCollection
	self initParties.
	self addAll: aPartyCollection! !

!PartyCollection methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
includes: aPartyOrRole
	^self parties includes: aPartyOrRole! !

!PartyCollection methodsFor: 'initialize-release' stamp: ' 10/1/08 16:40'!
initParties
	parties := OrderedCollection new.! !

!PartyCollection methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
notEmpty
	^self parties notEmpty! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
onlyPersons
	"just individual persons"
	^self parties select: [:each | each isKindOf: Person]! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
parent
	^parent! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
parent: aCompany
	"a root company, containing those mix of parties"
	parent := aCompany! !

!PartyCollection methodsFor: 'accessing-parent' stamp: ' 10/1/08 16:40'!
parentPartyOrRoleNamed: aString
	(aString isNil or: [aString isEmpty]) ifTrue: [^nil].
	^self allParentOrgUnitsRolesPersons detect: [:each | each nameToDisplay = aString] ifNone: [nil].! !

!PartyCollection methodsFor: 'private' stamp: ' 10/1/08 16:40'!
parties
	parties isNil ifTrue: [self initParties].
	^parties! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
partyOrRoleNamed: aString
	^self parties detect: [:each | each nameToDisplay = aString] ifNone: [nil].! !

!PartyCollection methodsFor: 'adding-removing' stamp: ' 10/1/08 16:40'!
remove: aPartyOrRole
	"anOrganizationalUnit, aRole, aRoleGroup or aPerson"
	self parties remove: aPartyOrRole! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
size
	^self parties size! !

!PartyCollection methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
sort
	"permanently sort a parties collection"
	self from: self allSorted! !

!PartyCollection class methodsFor: 'instance creation' stamp: ' 10/1/08 16:40'!
newOn: aCompany
	^super new parent: aCompany! !

!PartyCollection class methodsFor: 'instance creation' stamp: ' 10/1/08 16:40'!
newOn: aCompany from: aPartyCollection
	^(self newOn: aCompany) from: aPartyCollection! !

!Person methodsFor: 'record flows' stamp: ' 10/1/08 16:40'!
activitiesNotified
	"all process activities on which this person is notified"
	| activities set |
	activities := self allRecordFlows collect: [:each | each activity].
	set := Set new: activities size. "remove duplicates, preserve order"
	^activities select: [:each || exist | exist := set includes: each. set add: each. exist not]! !

!Person methodsFor: 'responsibilities' stamp: ' 10/1/08 16:40'!
activitiesResponsible
	"all process activities where this person have some kind of responsibility"
	| activities set |
	activities := (self allResponsibilities select: [:each | each isTaskResponsibility])
		collect: [:each | each task activity].
	set := Set new: activities size. "remove duplicates, preserve order"
	^activities select: [:each || exist | exist := set includes: each. set add: each. exist not]! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
allDeputies
	"all deputies of that person"
	^(self relatedPartyRoles select: [:role | role isDeputyRole]) collect: [:each | each party]! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
allDeputyOf
	"all persons to whom that person is deputy"
	^(self roles select: [:role | role isDeputyRole]) collect: [:each | each relatedParty]! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
allOrgUnits
	"all org.units where person is member"
	^((self roles select: [:role | role isMemberRole]) collect: [:role | role relatedParty]) asSet.! !

!Person methodsFor: 'record flows' stamp: ' 10/1/08 16:40'!
allRecordFlows
	"all record flows, concerned to that person"
	| flows set |
	flows := OrderedCollection new.
	self repository root allProcesses do: [:process | 
		process allTasks do: [:task | flows addAll: task allRecordFlows] ].
	set := Set new. self jobRole isNil ifTrue: [^#()].
	set add: self jobRole parentRole.
	set addAll: (self repository company roleGroupsIncludeRole: self jobRole parentRole).
	^flows select: [:flow | set includes: flow destination]! !

!Person methodsFor: 'responsibilities' stamp: 'jm 4/22/2009 23:04'!
allResponsibilities
	"search for all responsibilities through document repository, specially processes"
	| resps set |
	resps := OrderedCollection new. self repository isNil ifTrue: [^resps].
	self repository root allProcesses do: [:process |
		process allTasks do: [:task | resps addAll: task responsible] ].
	set := Set new. self jobRole isNil ifTrue: [^#()].
	set add: self jobRole parentRole.
	set addAll: (self repository company roleGroupsIncludeRole: self jobRole parentRole).
	^resps select: [:resp | set includes: resp role]! !

!Person methodsFor: 'responsibilities' stamp: ' 10/1/08 16:40'!
allTaskResponsibilities
	^self allResponsibilities select: [:each | each isTaskResponsibility]! !

!Person methodsFor: 'accessing' stamp: 'mivsek 1/10/2008 16:46'!
asICalUser
	^ICUser new
		commonName: self nameSurname  asSloveneWithoutCircumflexes "Outlook!!" ;
		emailAddress: self email! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
asPerson
	^self! !

!Person methodsFor: 'accessing' stamp: 'janko 8/6/2011 19:42'!
asWebUser
	"parallel WebUser object"
	^self otherAt: #WebUser ifAbsent: [^nil]! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
becomeDeputyOf: aPerson
	| role |
	(self isDeputyOf: aPerson) ifTrue: [^false].
	role := DeputyRole new.
	role name: 'deputy role'.
	self newRole: role relatedTo: aPerson.! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
becomeEmployeeOf: aParty 
	"I become an employee of that party"
	| role |
	(self isEmployeeOf: aParty) ifTrue: [^false].
	role := EmployeeRole new.
	role name: 'employee role'.
	self newRole: role relatedTo: aParty.

	self noMoreFormerEmployeeOf: aParty "if it was former before"! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
becomeFormerEmployeeOf: aParty 
	"I become an employee of that party"
	| role |
	(self isFormerEmployeeOf: aParty) ifTrue: [^false].
	role := FormerEmployeeRole new.
	role name: 'former employee role'.
	self newRole: role relatedTo: aParty! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
becomeMemberOf: anOrgUnit 
	"I become a member  of that org.unit"
	| role |
	(self isMemberOf: anOrgUnit) ifTrue: [^false].
	role := MemberRole new.
	role name: 'member role'.
	self newRole: role relatedTo: anOrgUnit! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
company
	"in which he is employeed"
	| parties |
	parties :=  (self roles select: [:role | role isEmployeeRole]) 
		collect: [:each | each relatedParty].
	parties := parties addAll:
		((self relatedPartyRoles select: [:role | role isEmployeeRole]) 
			collect: [:each | each party]);
		yourself.
	^parties isEmpty ifTrue: [nil] ifFalse: [parties first]! !

!Person methodsFor: 'documents' stamp: ' 10/1/08 16:40'!
documentsToKnow
	"all documents with which this person should know about (be notified)"
	^self repository root allDocuments select: [:each | each isReleased and: [each shouldKnow: self]].! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
email
	^self asWebUser notNil 
		ifTrue: [self asWebUser email]
		ifFalse: [super email].! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
email: aString 
	self asWebUser notNil 
		ifTrue: [self asWebUser email: aString]
		ifFalse: [super email: aString].! !

!Person methodsFor: 'roles - testing' stamp: ' 10/1/08 16:40'!
haveDeputies
	^self relatedPartyRoles contains: [:role | role isDeputyRole].! !

!Person methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:42'!
integratedWithOffice
	"WebDAV integration on MS IE"
	^self otherAt: #integratedWithOffice ifAbsent: [false]! !

!Person methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:44'!
integratedWithOffice: aBoolean
	"WebDAV integration on MS IE"
	self otherAt: #integratedWithOffice put: aBoolean.! !

!Person methodsFor: 'roles - testing' stamp: ' 10/1/08 16:40'!
isDeputy
	^self roles contains: [:role | role isDeputyRole].! !

!Person methodsFor: 'roles - testing' stamp: ' 10/1/08 16:40'!
isDeputyOf: aPerson
	^self roles contains: [:role | role relatedParty == aPerson and: [role isDeputyRole] ].! !

!Person methodsFor: 'roles - testing' stamp: ' 10/1/08 16:40'!
isEmployeeOf: aParty
	| employee |
	employee := self roles contains: [:role | role relatedParty == aParty and: [role isEmployeeRole] ].
	employee ifTrue: [^true].
	"check also a complementary role"
	^self relatedPartyRoles contains: [:role | role party == aParty and: [role isEmployeeRole] ].! !

!Person methodsFor: 'roles - testing' stamp: ' 10/1/08 16:40'!
isFormerEmployeeOf: aParty
	| formerEmployee |
	formerEmployee := self roles contains: [:role | 
		role relatedParty == aParty and: [role isFormerEmployeeRole]].
	formerEmployee ifTrue: [^true].
	"check also a complementary role"
	^self relatedPartyRoles contains: [:role | role party == aParty and: [role isFormerEmployeeRole] ].! !

!Person methodsFor: 'roles - testing' stamp: ' 10/1/08 16:40'!
isMemberOf: anOrgUnit
	| isMember |
	isMember := self roles contains: [:role | role relatedParty == anOrgUnit and: [role isMemberRole] ].
	isMember ifTrue: [^true].
	"check also a complementary role"
	^self relatedPartyRoles contains: [:role | role party == anOrgUnit and: [role isMemberRole] ].! !

!Person methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
isPerson
	^true! !

!Person methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
isWebUser
	^false! !

!Person methodsFor: 'testing' stamp: ' 10/1/08 16:40'!
isWebUserGroup
	^false! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
jobParentRole
	self jobRole isNil ifTrue: [^nil].
	^self jobRole parentRole.! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
jobRole
	^self roles detect: [:role | role isJobRole] ifNone: [^nil].! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
jobRoleName
	^self jobRole notNil ifTrue: [self jobRole name] ifFalse: [''].! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
jobRoleNamed: aString
	"org.unit should have this job role already defined!!"
	| parentRole |
	self organizationUnit isNil ifTrue: [^nil].
	parentRole := self organizationUnit jobRoleNamed: aString. parentRole isNil ifTrue: [^nil].
	self jobRole notNil ifTrue: [self removeJobRole].
	self newRole: parentRole newChildRole relatedTo: self company! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
menuName
	"in dropdown menus"
	^self surnameName! !

!Person methodsFor: 'private' stamp: ' 10/1/08 16:40'!
migrateToUnicode
	"from iso8859-2"
	"Person allInstances do: [:each | each migrateToUnicode]"
	super migrateToUnicode.
	surname notNil ifTrue: [surname := surname ensureUnicodeSloveneChars].! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
nameSurname
	^self name, ' ', self surname! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
nameToDisplay
	"on web pages for instance"
	^self surnameName! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
noMoreDeputyOf: aPerson
	| role |
	role := self roles 
		detect: [:each | each relatedParty == aPerson and: [each isDeputyRole] ] ifNone: [nil].
	role notNil ifTrue: [self discontinueRole: role].
	role := aPerson relatedPartyRoles 
		detect: [:each | each relatedParty == self and: [each isDeputyRole] ] ifNone: [nil].
	role notNil ifTrue: [aPerson discontinueRole: role].! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
noMoreEmployeeOf: aParty 
	"no more an employee of related party"
	| role |
	role := self roles 
		detect: [:each | each relatedParty == aParty and: [each isEmployeeRole] ] ifNone: [nil].
	role notNil ifTrue: [self discontinueRole: role].
	role := aParty relatedPartyRoles 
		detect: [:each | each relatedParty == self and: [each isEmployeeRole] ] ifNone: [nil].
	role notNil ifTrue: [aParty discontinueRole: role].

	self becomeFormerEmployeeOf: aParty.! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
noMoreFormerEmployeeOf: aParty 
	| role |
	role := self roles 
		detect: [:each | each relatedParty == aParty and: [each isFormerEmployeeRole] ] ifNone: [nil].
	role notNil ifTrue: [self discontinueRole: role].
	role := aParty relatedPartyRoles 
		detect: [:each | each relatedParty == self and: [each isFormerEmployeeRole] ] ifNone: [nil].
	role notNil ifTrue: [aParty discontinueRole: role].! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
noMoreMemberOf: anOrgUnit 
	"no more a memebr of related party"
	(self isMemberOf: anOrgUnit) ifFalse: [^nil].
	self discontinueRole:
		(self roles detect: [:role | role relatedParty == anOrgUnit and: [role isMemberRole] ] ifNone: [^nil])! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
organizationUnit
	"in which he is a member"
	| parties |
	parties :=  (self roles select: [:role | role isMemberRole]) 
		collect: [:each | each relatedParty].
	parties := parties addAll:
		((self relatedPartyRoles select: [:role | role isMemberRole]) 
			collect: [:each | each party]);
		yourself.
	^parties isEmpty ifTrue: [nil] ifFalse: [parties first]! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
organizationUnit: anOrganizationUnit
	self allOrgUnits do: [:each | self noMoreMemberOf: each].
	anOrganizationUnit notNil ifTrue: [self becomeMemberOf: anOrganizationUnit]! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
organizationUnitName
	^self organizationUnit notNil ifTrue: [self organizationUnit name] ifFalse: ['']! !

!Person methodsFor: 'accessing' stamp: 'janko 3/16/2008 17:00'!
password
	self asWebUser notNil ifTrue: [^self asWebUser password].
	^nil! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
password: aString 
	self asWebUser notNil ifTrue: [^self asWebUser password: aString trimBlanks].! !

!Person methodsFor: 'accessing' stamp: 'np 10/20/2008 16:38'!
passwordText
	"password is encripted/invisible anway, so return just empty "
	^''! !

!Person methodsFor: 'accessing' stamp: 'np 10/20/2008 16:38'!
passwordText: aString
	aString = self passwordText "all *****, this means that password was not changed"
		ifTrue: [^nil]. 
	aString trimBlanks isEmpty ifTrue: [^nil].
	^self password: aString! !

!Person methodsFor: 'private' stamp: 'janko 3/19/2012 13:21'!
preferredUrl
	| nme |
	nme := self surnameName trimBlanks asSloveneWithoutCircumflexes.
	^'/oseba/', nme asHttpFriendly.

"Person allInstances do: [:each | 
	each repository notNil ifTrue: [each repository site urlResolver changeToPreferedURL: each] ]"! !

!Person methodsFor: 'private' stamp: ' 10/1/08 16:40'!
printString
	^'Person: ', self name, ' ', self surname! !

!Person methodsFor: 'record flows' stamp: ' 10/1/08 16:40'!
processesNotified
	"all processes where on which this person is notified"
	| processes set |
	processes := self allRecordFlows collect: [:each | each process].
	set := Set new: processes size. "remove duplicates, preserve order"
	^processes select: [:each || exist | exist := set includes: each. set add: each. exist not]! !

!Person methodsFor: 'responsibilities' stamp: ' 10/1/08 16:40'!
processesResponsible
	"all processes where this person have some kind of responsibility"
	| processes set |
	processes := self allResponsibilities collect: [:each | each process].
	set := Set new: processes size. "remove duplicates, preserve order"
	^processes select: [:each || exist | exist := set includes: each. set add: each. exist not]! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
removeJobRole
	self jobRole notNil ifTrue: [self discontinueRole: self jobRole].! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
repository
	self organizationUnit notNil ifTrue: [^self organizationUnit repository].
	^self company notNil ifTrue: [self company repository] ifFalse: [nil].! !

!Person methodsFor: 'roles - specific' stamp: ' 10/1/08 16:40'!
specialRoleCollection
	"a set of additional roles by person's org.unit and org.hierarch up to the top"
	^self organizationUnit notNil
		ifTrue: [self organizationUnit specialRoleCollection]
		ifFalse: [self company notNil
			ifTrue: [self company specialRoleCollection]
			ifFalse: [OrderedCollection new] ].! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
surname
	surname isNil ifTrue: [self surname: ''].
	^surname! !

!Person methodsFor: 'accessing' stamp: 'janko 3/16/2008 17:00'!
surname: aString
	surname := aString trimBlanks! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
surnameName
	^self surname, ' ', self name! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
surnameName2
	^self surnameName trimBlanks notEmpty 
		ifTrue: [self surnameName]
		ifFalse: ['--brez priimka in imena---']! !

!Person methodsFor: 'record flows' stamp: ' 10/1/08 16:40'!
tasksNotified
	"all process tasks  on which this person is notified"
	| tasks set |
	tasks := self allRecordFlows collect: [:each | each task].
	set := Set new: tasks size. "remove duplicates, preserve order"
	^tasks select: [:each || exist | exist := set includes: each. set add: each. exist not]! !

!Person methodsFor: 'responsibilities' stamp: ' 10/1/08 16:40'!
tasksResponsible
	"all process tasks where this person have some kind of responsibility"
	| tasks set |
	tasks := (self allResponsibilities select: [:each | each isTaskResponsibility]) 
		collect: [:each | each task].
	set := Set new: tasks size. "remove duplicates, preserve order"
	^tasks select: [:each || exist | exist := set includes: each. set add: each. exist not]! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
username
	self asWebUser notNil ifTrue: [^self asWebUser username].
	^nil! !

!Person methodsFor: 'accessing' stamp: ' 10/1/08 16:40'!
username: aString 
	self asWebUser notNil ifTrue: [^self asWebUser username: aString trimBlanks].! !

!Person methodsFor: 'accessing' stamp: 'janko 8/6/2011 19:38'!
webUser: aWebUser
	"a parallel WebUser for web server security etc."
	self otherAt: #WebUser put: aWebUser.
	(aWebUser otherAt: #Person) ~= self ifTrue: [aWebUser person: self].! !

!Person class methodsFor: 'instance creation'!
newWithRelatedWebUserOn: anAIDASite
	| instance |
	instance := super new.
	instance webUser: (anAIDASite webUserClass new person: instance; parent: anAIDASite securityManager).
	^instance! !

!PositionableStream methodsFor: '*Aida' stamp: 'JM 4/26/2007 14:28'!
upToSeparator
	"Answer a subcollection from position to the occurrence (if any, exclusive) of a separator.
	The stream is left positioned after the separator.
	If no separator is found answer everything."

	| newStream element |
	newStream := collection class new writeStream.
	[self atEnd]
		whileFalse:
			[element := self next.
			element isSeparator
				ifTrue: [^newStream contents].
			newStream nextPut: element.].
	^newStream contents
	
" 'abc def' readStream upToSeparator"
! !

!Role methodsFor: 'initialize-release' stamp: 'janko 8/8/2011 18:09'!
initOther
	other := Dictionary new.! !

!Role methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isCustomerRole
	^false! !

!Role methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isDeputyRole
	^false! !

!Role methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isEmployeeRole
	^false! !

!Role methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isFormerEmployeeRole
	^false! !

!Role methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isJobRole
	^false! !

!Role methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isMemberRole
	^false! !

!Role methodsFor: 'testing'!
isPerson
	^false! !

!Role methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isRole
	^true! !

!Role methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isRoleGroup
	^false! !

!Role methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isSupplierRole
	^false! !

!Role methodsFor: 'private' stamp: ' 10/1/08 16:41'!
migrateToUnicode
	"from iso8859-2"
	name notNil ifTrue: [name := name ensureUnicodeSloveneChars].! !

!Role methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
name
	^name! !

!Role methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
name: aString
	name := aString.! !

!Role methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
nameToDisplay
	^self name! !

!Role methodsFor: 'private' stamp: 'janko 8/8/2011 18:07'!
other
	^other! !

!Role methodsFor: 'private' stamp: 'janko 8/8/2011 18:07'!
otherAt: aSymbol
	"other values"
	^self otherAt: aSymbol ifAbsent: [nil]! !

!Role methodsFor: 'private' stamp: 'janko 8/8/2011 18:08'!
otherAt: aSymbol ifAbsent: aBlock
	"other values"
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!Role methodsFor: 'private' stamp: 'janko 8/8/2011 18:08'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!Role methodsFor: 'private' stamp: 'janko 8/8/2011 18:08'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!Role methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
party
	^party! !

!Role methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
party: aParty
	party := aParty.! !

!Role methodsFor: 'private' stamp: ' 10/1/08 16:41'!
printString
	^'aRole ', self name! !

!Role methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
relatedParty
	^relatedParty! !

!Role methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
relatedParty: aParty
	relatedParty := aParty.! !

!Role methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
uuid
	"some unique identifier. Hash for now, probably unique enough!! "
	^self hash printString! !

!RoleGroup methodsFor: 'adding-removing' stamp: ' 10/1/08 16:41'!
add: aRoleOrGroup
	(self subroles includes: aRoleOrGroup) ifFalse: [self subroles add: aRoleOrGroup]! !

!RoleGroup methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
allPersonsWithJobRoles
	"collect all persons holding job roles as part of that role group"
	^self allRoles inject: Set new into: [:set :role | set addAll: role allPersons; yourself].! !

!RoleGroup methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
allRoleGroups
	^self subroles select: [:each | each isRoleGroup]! !

!RoleGroup methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
allRoles
	^self subroles select: [:each | each isRole]! !

!RoleGroup methodsFor: 'adding-removing' stamp: ' 10/1/08 16:41'!
includes: aRoleOrGroup
	^self subroles includes: aRoleOrGroup! !

!RoleGroup methodsFor: 'private' stamp: ' 10/1/08 16:41'!
initSubroles
	subroles := OrderedCollection new.! !

!RoleGroup methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isPerson
	^false! !

!RoleGroup methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isRole
	^false! !

!RoleGroup methodsFor: 'testing' stamp: ' 10/1/08 16:41'!
isRoleGroup
	^true! !

!RoleGroup methodsFor: 'private' stamp: ' 10/1/08 16:41'!
migrateToUnicode
	"from iso8859-2"
	name notNil ifTrue: [name := name ensureUnicodeSloveneChars].! !

!RoleGroup methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
name
	^name! !

!RoleGroup methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
name: aString
	name := aString.! !

!RoleGroup methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
nameToDisplay
	^name! !

!RoleGroup methodsFor: 'private' stamp: ' 10/1/08 16:41'!
printString
	^'aRoleGroup ', self name! !

!RoleGroup methodsFor: 'adding-removing' stamp: ' 10/1/08 16:41'!
remove: aRoleOrGroup
	(self subroles includes: aRoleOrGroup) ifTrue: [self subroles remove: aRoleOrGroup]! !

!RoleGroup methodsFor: 'private' stamp: ' 10/1/08 16:41'!
subroles
	subroles isNil ifTrue: [self initSubroles].
	^subroles! !

!RoleGroup methodsFor: 'accessing' stamp: ' 10/1/08 16:41'!
uuid
	"some unique identifier. Hash for now, probably unique enough!! "
	^self hash printString! !

!ScaledDecimal methodsFor: '*Aida' stamp: 'janko 8/3/2011 15:27'!
asScaledDecimal: aScaleInteger
	^self class newFromNumber: self scale: aScaleInteger

! !

!ScaledDecimal methodsFor: '*Aida' stamp: 'janko 8/3/2011 20:57'!
printDotString
	"Janko Mivsek, 1997"
	"format and return the number with dots between thousandths:  '3.120.123' "
	"1234.12s4 printDotString"
	| denom n quo rem stream |
	stream := WriteStream on: String new.
	denom := 10 raisedTo: scale.
	n := numerator * denom + (denominator bitShift: -1) // denominator.
	numerator < 0 ifTrue:
		[stream nextPut: $-.  n := n negated].
	quo := n // denom. rem := n \\ denom.
	stream nextPutAll: quo printDotString.
	scale > 0 ifTrue:
		[stream nextPut: $, .
		scale timesRepeat:
			[rem := rem*10.
			stream nextPut: (Character digitValue: rem//denom).
			rem := rem \\ denom]].
	^stream contents.! !

!ScaledDecimal methodsFor: '*Aida' stamp: 'janko 8/3/2011 20:58'!
printDotStringNoZero
	"don't print anything if zero"
	^self ~= 0 ifTrue: [self printDotString] ifFalse: ['']! !

!SchedulerTest methodsFor: 'running' stamp: 'jm 4/26/2009 15:40'!
setUp
	scheduler := WebScheduler newOn: nil.
	scheduler start.! !

!SchedulerTest methodsFor: 'running' stamp: ' 21/4/07 22:08'!
tearDown
	scheduler stop.! !

!SchedulerTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 20:54'!
testAddingSingleEvent
"	scheduler at: SpTimestamp now callMethod: #transcript of: self. "! !

!SchedulerTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 20:54'!
testAddingSingleEvent2
	"look at Transcript!! "
	| time |
	time := SpTimestamp fromSeconds: (SpTimestamp now asSeconds + 1).
	scheduler at: time runBlock: [self transcript].
	(Delay forSeconds: 2) wait.! !

!SchedulerTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testMinutePeriodicEvent
	"it should write twice to transcript in 2 minutes!! "
	scheduler everyMinuteAt: 30 runBlock: [self transcript].
"	(Delay forSeconds: 120) wait "! !

!SchedulerTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 20:58'!
testMoreMinutePeriodicEvents
	"it should write to transcript in 2 minutes!! "
"	scheduler everyMinuteAt: 30 runBlock: [self transcript1].
	scheduler everyMinuteAt: 15 runBlock: [self transcript2].
	scheduler everyMinuteAt: 45 runBlock: [self transcript3].
	scheduler everyMinuteAt: 20 runBlock: [self transcript4].
""	(Delay forSeconds: 120) wait"! !

!SchedulerTest methodsFor: 'testing-queue order' stamp: 'mivsek 8/22/2007 20:57'!
testOrderOf2AscEvents
	scheduler stop. "just testing order in queue!!"
"	scheduler everyMinuteAt: 15 runBlock: [self transcript1].
	scheduler everyMinuteAt: 30 runBlock: [self transcript2].
	self assert: (scheduler queue at: 1) period value = 15.
	self assert: (scheduler queue at: 2) period value = 30.
"! !

!SchedulerTest methodsFor: 'testing-queue order' stamp: 'mivsek 8/22/2007 20:57'!
testOrderOf2DescEvents
	scheduler stop. "just testing order in queue!!"
"	scheduler everyMinuteAt: 30 runBlock: [self transcript1].
	scheduler everyMinuteAt: 15 runBlock: [self transcript2].
	self assert: (scheduler queue at: 1) period value = 15.
	self assert: (scheduler queue at: 2) period value = 30.
"! !

!SchedulerTest methodsFor: 'testing-queue order' stamp: 'mivsek 8/22/2007 20:57'!
testOrderOf3AscEvents
	scheduler stop. "just testing order in queue!!"
"	scheduler everyMinuteAt: 15 runBlock: [self transcript1].
	scheduler everyMinuteAt: 30 runBlock: [self transcript2].
	scheduler everyMinuteAt: 45 runBlock: [self transcript3].
	self assert: (scheduler queue at: 1) period value = 15.
	self assert: (scheduler queue at: 2) period value = 30.
	self assert: (scheduler queue at: 3) period value = 45.
"! !

!SchedulerTest methodsFor: 'testing-queue order' stamp: 'mivsek 8/22/2007 20:58'!
testOrderOf3DescEvents
	scheduler stop. "just testing order in queue!!"
"	scheduler everyMinuteAt: 45 runBlock: [self transcript1].
	scheduler everyMinuteAt: 30 runBlock: [self transcript2].
	scheduler everyMinuteAt: 15 runBlock: [self transcript3].
	self assert: (scheduler queue at: 1) period value = 15.
	self assert: (scheduler queue at: 2) period value = 30.
	self assert: (scheduler queue at: 3) period value = 45.
"! !

!SchedulerTest methodsFor: 'testing-queue order' stamp: 'mivsek 8/22/2007 20:58'!
testOrderOf3MixedEvents
	scheduler stop. "just testing order in queue!!"
"	scheduler everyMinuteAt: 15 runBlock: [self transcript1].
	scheduler everyMinuteAt: 45 runBlock: [self transcript2].
	scheduler everyMinuteAt: 30 runBlock: [self transcript3].
	self assert: (scheduler queue at: 1) period value = 15.
	self assert: (scheduler queue at: 2) period value = 30.
	self assert: (scheduler queue at: 3) period value = 45.
"! !

!SchedulerTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testSetup! !

!SchedulerTest methodsFor: 'private' stamp: ' 21/4/07 22:08'!
transcript
	Transcript cr; show: 'scheduled event'! !

!SchedulerTest methodsFor: 'private' stamp: ' 21/4/07 22:08'!
transcript1
	Transcript cr; show: 'scheduled event 1'! !

!SchedulerTest methodsFor: 'private' stamp: ' 21/4/07 22:08'!
transcript2
	Transcript cr; show: 'scheduled event 2'! !

!SchedulerTest methodsFor: 'private' stamp: ' 21/4/07 22:08'!
transcript3
	Transcript cr; show: 'scheduled event 3'! !

!SchedulerTest methodsFor: 'private' stamp: ' 21/4/07 22:08'!
transcript4
	Transcript cr; show: 'scheduled event 4'! !

!SchedulerTest methodsFor: 'private' stamp: ' 21/4/07 22:08'!
transcript5
	Transcript cr; show: 'scheduled event 5'! !

!SpDate methodsFor: '*Aida' stamp: 'JM 4/22/2007 19:01'!
+ aNumber 
	^self addDays: aNumber! !

!SpDate methodsFor: '*Aida' stamp: 'JM 4/22/2007 19:01'!
- aNumber 
	"subtract number of days from a date."
	^self subtractDays: aNumber! !

!SpDate methodsFor: '*Aida' stamp: 'np 10/22/2008 23:36'!
currentMonth
	^self currentYear and: [self monthIndex = SpDate today monthIndex]! !

!SpDate methodsFor: '*Aida' stamp: 'np 10/22/2008 23:37'!
currentYear
	^self year = SpDate today year! !

!SpDate methodsFor: '*Aida' stamp: 'np 10/22/2008 23:37'!
firstDayInMonth
	^SpDate newDay: 1 month: self monthIndex year: self year! !

!SpDate methodsFor: '*Aida' stamp: 'np 10/22/2008 23:38'!
firstDayInNextMonth
	^SpDate 
		newDay: 1 
		month: (self lastDayInMonth addDays: 1) monthIndex
		year: (self lastDayInMonth addDays: 1) year! !

!SpDate methodsFor: '*Aida' stamp: 'np 10/22/2008 23:38'!
firstDayInNextYear
	^SpDate 
		newDay: 1
		month: self firstDayInMonth monthIndex
		year: self firstDayInMonth year + 1! !

!SpDate methodsFor: '*Aida' stamp: 'np 10/22/2008 23:38'!
firstDayInPreviousMonth
	^SpDate 
		newDay: 1
		month: (self firstDayInMonth subtractDays: 1) monthIndex
		year: (self firstDayInMonth subtractDays: 1) year! !

!SpDate methodsFor: '*Aida' stamp: 'np 10/22/2008 23:38'!
firstDayInPreviousYear
	^SpDate 
		newDay: 1
		month: self firstDayInMonth monthIndex
		year: self firstDayInMonth year + 1! !

!SpDate methodsFor: '*Aida' stamp: 'np 10/22/2008 23:39'!
lastDayInMonth
	^SpDate newDay: self daysInMonth month: self monthIndex year: self year! !

!SpDate methodsFor: '*Aida' stamp: 'np 1/22/2008 12:20'!
monthAndDayString
	"with leading zeros, example: 05-16 for 16may"
	^(self monthIndex < 10 ifTrue: ['0'] ifFalse: ['']), self monthIndex printString, '-',
	 	(self underlyingDate dayOfMonth < 10 ifTrue: ['0'] ifFalse: ['']), self underlyingDate dayOfMonth printString

"SpDate today monthAndDayString"! !

!SpDate methodsFor: '*Aida' stamp: 'JM 4/22/2007 19:02'!
printISOString
	^self year printString, 
		(self monthIndex < 10 ifTrue: ['0'] ifFalse: ['']), self monthIndex printString,
		(self dayOfMonth < 10 ifTrue: ['0'] ifFalse: ['']), self dayOfMonth printString

"Date today printISOString   "! !

!SpDate methodsFor: '*Aida' stamp: 'JM 4/26/2007 19:56'!
shortPrintSloString
	^self underlyingDate dayOfMonth printString, '.', 
		self underlyingDate monthIndex printString, '.', self year printString.

"SpDate today shortPrintSloString"! !

!SpDate methodsFor: '*Aida' stamp: 'janko 9/30/2011 10:13'!
shorterPrintSloString
	"year in two digits only"
	| yeart |
	yeart := (self year \\ 100) printString. yeart size = 1 ifTrue: [yeart := '0', yeart].
	^self underlyingDate dayOfMonth printString, '.', self monthIndex printString, '.', yeart.

"Date today shorterPrintSloString"! !

!SpFilename methodsFor: '*Aida' stamp: 'np 3/18/2008 05:58'!
contentsAsMethod
	"return a body of method with a literal array with contents of that file"
	| input output |
	input := self readStream.
	input binary.
	output := WriteStream with: String new.
	output nextPutAll: '^#('.
	[ [input atEnd] whileFalse: [output nextPutAll: input next printString; nextPut: $ ].
	output nextPutAll: ')' ]
		ensure: [input close].
	^output contents

"(SpFilename named: 'source.st') contentsAsMethod "! !

!SpFilename methodsFor: '*Aida' stamp: 'janko 3/22/2008 17:17'!
contentsOfEntireFileBinary
	| stream |
	[stream := FileStream oldFileNamed: self filename.
	^stream binary contentsOfEntireFile]
		ensure: [stream close]
! !

!SpFilename methodsFor: '*Aida' stamp: 'np 6/11/2008 05:02'!
directoryContents
	| entries |
	entries := FileDirectory new directoryContentsFor: (self asAbsoluteFilename filename).
	^entries collect: [:each | each name]! !

!SpTimestamp methodsFor: '*Aida' stamp: 'jm 2/7/2011 13:04'!
>= anOSkTimeStamp 
	^self underlyingTimestamp >= anOSkTimeStamp underlyingTimestamp! !

!SpTimestamp methodsFor: '*Aida' stamp: 'jm 2/4/2011 21:26'!
printSloString
	^self asDate shortPrintSloString, ' ', self asTime printSloString
! !

!SpTimestamp methodsFor: '*Aida' stamp: 'JM 4/22/2007 15:33'!
sendOver: aStream 
	"from Wiki rendering"
	self printOn: aStream
"
	TimestampPrintPolicy 
		print: (TimeZone default convertToGMT: self asSeconds
				do: [:date :seconds | Timestamp fromDate: date andTime: (Time fromSeconds: seconds)])
		on: aStream
		using: 'ddd, dd mmm yyyy hh:mm:ss GMT'
"! !

!String methodsFor: '*Aida' stamp: 'np 3/25/2009 15:36'!
aidaIsAssociation
	"used for Aida/Web translation support, multilingual strings are namelly assocs: #fr->'Bonjour'"
	^false! !

!String methodsFor: '*Aida' stamp: 'JM 4/22/2007 18:05'!
asCollectionOfHtmlHeadings
	"find all headings H1-5 and return a collection of headings, complete with tags"
	| in tag collection line |
	in := self readStream. collection := OrderedCollection new.
	[in atEnd] whileFalse:
		[in upTo: $<. in atEnd ifFalse: [tag := in upTo: $>].
		(tag size >= 2 and: [tag first asLowercase = $h and: [(tag at: 2) isDigit]] ) ifTrue:
			[tag := String with: $h with: (tag at: 2). "cleaned, without any parms!!"
			line := '<', tag, '>', (in upToAll: '</', tag, '>'), '</', tag, '>'. 
			collection add: line] ].
	^collection

" '<h1>Heading1</h1><h2>Heading2</h2>' asCollectionOfHtmlHeadings"
" '<h1><b>Heading1</b></h1>' asCollectionOfHtmlHeadings"! !

!String methodsFor: '*Aida' stamp: 'janko 8/25/2012 15:06'!
asHttpFriendly
	"Usefull specially for Url composition (like in preferedUrl). Converts all non Url friendly 
	characters to '-' and skip last point if exists (not good for Urls in emails).
 	Caution, / is also converted!! Unicode is allowed "
	| nonallowed conv |
	nonallowed := #($ $+ $: $> $< $= $/ #\ $~ $( $) ).
	self isEmpty ifTrue: [^self].
	conv := self collect: 
		[:ch | (nonallowed includes: ch)
			ifTrue: [$-]
			ifFalse: [ch] ].
	^(conv last = $. )
		ifTrue: [conv copyFrom: 1 to: conv size-1] "skip last point"
		ifFalse: [conv]

" '1+1=(3/4).d.d.' asHttpFriendly "! !

!String methodsFor: '*Aida' stamp: 'janko 8/3/2011 19:10'!
asScaledDecimal: aScaleNumber
	"Janko Mivsek, Eranova d.o.o. dec97, feb07, may11"
	"convert a string to a scaled decimal number with specified scale. Precision is remained as specified
	in fraction part of a number. Decimal point character is automatically detected and can be . or , "
	| string clean pos sign dpCh number denomString |
	string := self trimBlanks. string isEmpty ifTrue: [^0 asScaledDecimal: aScaleNumber].
	sign := string detect: [:ch | ch = $- | ch isDigit] ifNone: [^0.0s]. 
	sign = $- ifTrue: [sign := -1] ifFalse: [sign := 1].
	dpCh := string reverse detect: [:ch | ch isDigit not] ifNone: [$.].
	clean := string select: [:ch | ch isDigit | (ch = dpCh)].  clean isEmpty ifTrue: [^0.0s].
	clean first = dpCh ifTrue: [clean := '0', clean].
	pos := clean indexOf: dpCh . pos = 0 ifTrue: [^(clean asInteger asScaledDecimal: aScaleNumber)*sign].
	denomString := clean copyFrom: pos+1 to: clean size.
	number := ScaledDecimal new
		setNumerator: ((clean copyUpTo: dpCh ), denomString) asInteger
		denominator:  (10 raisedTo: denomString size)
		scale: aScaleNumber.
	^number * sign

" '-2.445.444,988899987' asScaledDecimal: 3 " "comma as decimal point (european)"
" '-2,445,444.988899987' asScaledDecimal: 3 " "point as decimal point"! !

!String methodsFor: '*Aida' stamp: 'JM 4/22/2007 18:05'!
asSloveneWithoutCircumflexes
	"convert Unicode csz string with ^ (sumniki) to plain ascii csz"
	"'c^s^z^C^S^Z^' convertToSloveneChars asSloveneWithoutCircumflexes"
	^self collect: 
		[:ch | ch asInteger > 127 
			ifTrue:
				[ch = AIDASite charc ifTrue: [$c]
					ifFalse: [ ch  = AIDASite charC ifTrue: [$C]
					ifFalse: [ ch  = AIDASite chars ifTrue: [$s]
					ifFalse: [ ch  = AIDASite charS ifTrue: [$S]
					ifFalse: [ ch  = AIDASite charz ifTrue: [$z] 
					ifFalse: [ ch  = AIDASite charZ ifTrue: [$Z]
					ifFalse: [$- ] ]]]]]
				]
			ifFalse: [ch] ]! !

!String methodsFor: '*Aida' stamp: 'janko 3/16/2008 11:41'!
contentsAsMethod
	"return a body of method with a literal array with contents of that string"
	| input output |
	input := self readStream.
	output := WriteStream with: String new.
	output nextPutAll: '^#('.
	[input atEnd] whileFalse: [output nextPutAll: input next asInteger asString; nextPut: $ ].
	output nextPutAll: ')'.
	^output contents

" 'visual.cha'contentsAsMethod "! !

!String methodsFor: '*Aida' stamp: 'janko 8/25/2012 15:07'!
convertToSloveneChars
	"convert csz string with ^ as 'sumnik' to proper unicode string. 
	Only pure ASCII strings are converted!!"
	"'Mivs^ek' convertToSloveneChars"
	| in out ch |
"	self class == ByteString ifFalse: [^self]. " "what if there is a mixed string, some unicode already?"
	in := self readStream. out := WriteStream on: String new.
	[in atEnd] whileFalse: 
		[ch := in next.
		(in peek = $^ ) ifTrue: [(#($c $C $s $S $z $Z) includes: ch) ifTrue: 
			[in next. 
			ch = $c ifTrue: [ch := AIDASite charc]. ch = $C ifTrue: [ch := AIDASite charC].
			ch = $s ifTrue: [ch := AIDASite chars]. 	ch = $S ifTrue: [ch := AIDASite charS].
			ch = $z ifTrue: [ch := AIDASite charz]. ch = $Z ifTrue: [ch := AIDASite charZ] ] ].
		out nextPut: ch].
	^out contents! !

!String methodsFor: '*Aida' stamp: 'JM 4/22/2007 18:07'!
ensureUnicodeSloveneChars
	"if string has other that unicode slovene chars, try to correct them!!"
	"'Mivek' ensureUnicodeSloveneChars"
	| in out ch uniSet |
	in := self readStream. out := WriteStream on: String new. uniSet := AIDASite charCszSet. 
	[in atEnd] whileFalse: 
		[ch := in next.
		(ch asInteger < 128 or: [uniSet includes: ch])
			ifTrue: [out nextPut: ch]
			ifFalse: [out nextPut: 
				([(AIDASite convert: (String with: ch) fromCodepage: #'iso-8859-2') first]
					on: Error do: [:ex | ch]) ] ].
	^out contents! !

!String methodsFor: '*Aida' stamp: 'JM 4/22/2007 18:07'!
isValidEMailAddress
	(self includes: $@) ifFalse: [^false].
	^(self trimBlanks contains: [:char | 
		char isAlphaNumeric not and: [(#($. $- $_  $@) includes: char) not] ]) not

" 'janko.mivsek@eranova.si' isValidEMailAddress"! !

!String methodsFor: '*Aida' stamp: 'np 3/31/2008 17:25'!
trimBlanks
	^SpStringUtilities trimBlanksFrom: self! !

!String methodsFor: '*Aida' stamp: 'np 1/21/2008 17:38'!
withHeadingAnchors
	"add anchors before all H1-5 tags, each with sequence number of that tag, eg: <a name=h-15>"
	| in out tag number |
	in := self readStream. number := 1.
	out := WriteStream on: String new.
	[in atEnd] whileFalse:
		[out nextPutAll: (in upTo: $<).
		in atEnd ifFalse: [tag := in upTo: $>] ifTrue: [^out contents].
		(tag size = 2 and: [tag first asLowercase = $h and: [tag last isDigit]] ) ifTrue:
			[out nextPutAll: '<a name="h-', number printString, '"></a>'. 
			number := number +1].
		out nextPutAll: '<', tag, '>'].
	^out contents

"'<h1>Heading1</h1><h2>Heading2</h2>' withHeadingAnchors"! !

!String methodsFor: '*Aida' stamp: 'JM 4/22/2007 18:08'!
withHtmlBreaks
	"changes all cr with <br>"
	^self copyReplaceAll: (String with: Character cr) with: '<br>'

"('aaa', (String with: Character cr), 'bbb') withHtmlBreaks"! !

!String methodsFor: '*Aida' stamp: 'jm 11/10/2010 21:27'!
withoutHtmlTags
	"strip all tags and newlines, replace <br> and <p> with cr"
	| in out text tag |
	in := self readStream.
	out := WriteStream on: String new.
	[in atEnd] whileFalse:
		[text := ((in upTo: $<) copyWithout: Character cr).
		text := text copyReplaceAll: '&scaron;' with: (String with: AIDASite chars). "slovenian s^"
		text := text copyReplaceAll: '&Scaron;' with: (String with: AIDASite charS). "slovenian S^"
		text := text copyReplaceAll: '&nbsp;' with: ' '. "nonbreakable space"
		out nextPutAll: text.
		in atEnd ifFalse: [tag := in upTo: $>].
		(tag = 'br') | (tag = 'p') ifTrue: [out nextPut: Character cr ] ].
	^out contents

"'<span>by Michael A. <br>Prospero</span>' withoutHtmlTags"! !

!SwazooAida class methodsFor: 'start/stop' stamp: 'np 3/15/2009 15:56'!
demoStart             
	"will create (if not yet) and start a demo site on http://localhost:8888"
	SwazooServer aidaDemoStart! !

!SwazooAida class methodsFor: 'start/stop' stamp: 'np 3/15/2009 15:56'!
demoStop             
	"will stop a demo site on http://localhost:8888"
	SwazooServer aidaDemoStop! !

!SwazooAida class methodsFor: 'start/stop' stamp: ' 10/1/08 22:01'!
start    
	"will start all existing sites, both Aida ones and others on  Swazoo web server"
	SwazooServer start! !

!SwazooAida class methodsFor: 'start/stop' stamp: ' 10/1/08 22:01'!
startOn: portNum   
	"will start a site on that port on all IP interfaces, any host"
      "site will be created if doesn't exist yet"
	SwazooServer aidaStartOn: portNum! !

!SwazooAida class methodsFor: 'start/stop' stamp: 'np 3/15/2009 15:43'!
stop    
	"will stop all running sites, both Aida ones and other on Swazoo web server"
	SwazooServer stop! !

!SwazooIntegrationTest methodsFor: 'private' stamp: ' 21/4/07 22:08'!
localSendUrl: aString
	"sends request with that RELATIVE url to the site localy - it simulates a real network request. "
	| request httpServer |
	request := Swazoo.HTTPRequest request: aString from: self siteHost at: self siteIP.
	request uri port: self sitePort.
	httpServer := server servers asOrderedCollection first.
	^httpServer answerTo: request! !

!SwazooIntegrationTest methodsFor: 'private' stamp: ' 21/4/07 22:08'!
sendUrl: aString
	"sends a real network request with that RELATIVE url to the site with parameters from defaults. 
	Returns a Net.HttpResponse"
	| client request |
	client := Net.HttpClient new.
	request := Net.HttpRequest get: 'http://', self siteHost, ':', self sitePort printString, aString.
	^client executeRequest: request.! !

!SwazooIntegrationTest methodsFor: 'running' stamp: ' 21/4/07 22:08'!
setUp
	server := Swazoo.SwazooServer singleton.
	"server initialize." "DANGEROUS!! "  "to remove all stuff and stop it"
	"site := AIDASite newNamed: self siteName.
	site 
		host: self siteHost;
		ip: self siteIP;
		port: self sitePort;
		sslPort: self siteSSLPort. "! !

!SwazooIntegrationTest methodsFor: 'defaults' stamp: ' 21/4/07 22:08'!
siteHost
	^'localhost'! !

!SwazooIntegrationTest methodsFor: 'defaults' stamp: ' 21/4/07 22:08'!
siteIP
	^'localhost'! !

!SwazooIntegrationTest methodsFor: 'defaults' stamp: ' 21/4/07 22:08'!
siteName
	^'test'! !

!SwazooIntegrationTest methodsFor: 'defaults' stamp: ' 21/4/07 22:08'!
sitePort
	^8765! !

!SwazooIntegrationTest methodsFor: 'defaults' stamp: ' 21/4/07 22:08'!
siteRootUri
	^'/'! !

!SwazooIntegrationTest methodsFor: 'defaults' stamp: ' 21/4/07 22:08'!
siteSSLPort
	^8766! !

!SwazooIntegrationTest methodsFor: 'running' stamp: ' 21/4/07 22:08'!
tearDown
	"site := server siteNamed: self siteName.
	site stop.
	server removeSite: site.
	server := nil.
	site := nil."! !

!SwazooIntegrationTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testAccessingByName
"
	self assert: (Swazoo.SwazooServer siteNamed: self siteName) notNil.
	self assert: (Swazoo.SwazooServer siteHostnamed: self siteHost) notNil
"! !

!SwazooIntegrationTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testAdminPage
"
	| |
	server startSite: self siteName.
	self shouldnt: [self sendUrl: '/admin.html'] raise: Error.
	self shouldnt: [self sendUrl: '/admin.html?view=login'] raise: Error.
	server stopSite: self siteName.
"! !

!SwazooIntegrationTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testDummyRequest
"
	server startSite: self siteName.
	self should: [self sendUrl: '/dummycompletelydummy.html'] raise: Net.HttpObjectNotFound.
	server stopSite: self siteName.
"! !

!SwazooIntegrationTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testLocalAdminPage
"
	| response |
	server startSite: self siteName.
	response := self localSendUrl: '/admin.html'.
	self assert: response isRedirectLink.
	response := self localSendUrl: '/admin.html?view=login'.
	self assert: response isOk.
	server stopSite: self siteName.
"! !

!SwazooIntegrationTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testLocalDummyRequest
"
	| response |
	server startSite: self siteName.
	response := self localSendUrl: '/dummycompletelydummy.html'.
	self assert: response isNotFound.
	server stopSite: self siteName.
"! !

!SwazooIntegrationTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testSetUp
"
	self assert: (server sites size = 1).
	self assert: (site ip = self siteIP).
	self assert: (site host = self siteHost).
	self assert: (site port = self sitePort).
	self assert: site isServing not.
"! !

!SwazooIntegrationTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 21:00'!
testStarting
"	server startSite: self siteName.
	self assert: (server siteNamed: self siteName) isServing.
	self assert: (server servers asOrderedCollection first isServing).
	server stopSite: self siteName.
	self deny: (server siteNamed: self siteName) isServing.
"! !

!SwazooServer methodsFor: '*Aida'!
aidaDemoSite
	"return aidademo site. Create and make it default, if it not yet there"
	| siteName |
	siteName := 'aidademo'.
	(self siteNamed: siteName) isNil ifTrue:
		[AIDASite newNamed: siteName.
		AIDASite default: siteName.
		(AIDASite named: siteName) host: '*' ip: '*'  port: 8888].
	^self siteNamed: siteName! !

!SwazooServer methodsFor: '*Aida'!
aidaDemoStart
	self aidaDemoSite start.! !

!SwazooServer methodsFor: '*Aida'!
aidaDemoStop
	self aidaDemoSite stop.! !

!SwazooServer methodsFor: '*Aida'!
aidaSites
	^self sites select: [:each | each isKindOf: AIDASite]! !

!SwazooServer methodsFor: '*Aida' stamp: 'mivsek 1/10/2008 22:06'!
aidaStartOn: aPortNumber
	| site |
	site := self siteAnyHostAllInterfacesOnPort: aPortNumber.
	site isNil ifTrue: [site := self prepareAidaDemoSiteOnPort: aPortNumber].
	site start.
	^site! !

!SwazooServer methodsFor: '*Aida' stamp: 'mivsek 1/10/2008 22:07'!
prepareAidaDemoSiteOnPort: aNumber
	"this site will run on all IP interfaces on that port"
	| name site |
	name := 'aidaOn', aNumber printString.
	site := AIDASite newNamed: name. "which is now also added to SwazoServer"
	site host: '*' ip: '*' port: aNumber.
	^site! !

!Time methodsFor: '*Aida'!
printSecSloString
	^self hours printString, ':',
		(self minutes < 10 ifTrue: ['0'] ifFalse: ['']), self minutes printString, ':',
		(self seconds < 10 ifTrue: ['0'] ifFalse: ['']), self seconds printString

"Time now printSecSloString"! !

!Time methodsFor: '*Aida' stamp: 'np 1/22/2008 08:47'!
printSloString
	^"(self hours < 10 ifTrue: ['0'] ifFalse: [''])," self hours printString, ':',
		(self minutes < 10 ifTrue: ['0'] ifFalse: ['']), self minutes printString

"Time now printSloString"! !

!URLResolver methodsFor: 'request counting'!
addCountsFromDictionary: aCountDictionary

| object origCounter stopUrls |
	stopUrls := Col collect: [:assoc | assoc notNil ifTrue: [assoc key] ].
	aCountDictionary keysAndValuesDo: [:url :counter |
	(stopUrls includes: url asLowercase) ifFalse:
		[object := self objectOnUrl: url.
		object notNil ifTrue: 
			[origCounter := self counterFor: object.
			origCounter addCounter: counter ] ]
		ifTrue: ["self halt"] ]

"URLResolver default addCountsFromDictionary: Janko"
"
| boss |
boss := (BinaryObjectStorage onOld: '..\images\janko\LogDict.boss' asFilename readStream).
Janko := boss next.
boss close
"! !

!URLResolver methodsFor: 'adding-removing' stamp: 'janko 8/25/2012 19:37'!
addObject: anObject withUrl: aString
	"add an object if not already exist and add url to the collection of urls for that object.
	If aString url point to some other object already, then remove url from that other object"
	"warning, if web elements (such as web apps) will be registered"
"	self isWebElement: anObject." "do we still need this warning?"
	anObject isNil ifTrue: [^nil]. "do not add nil objects!!"
	self site critical: 
		[(self allWebPages at: anObject ifAbsentPut: [OrderedCollection new])
				add: aString asLowercase.
		(self allUrlLinks includesKey: aString asLowercase) ifTrue:
			[(self allWebPages at: (self allUrlLinks at: aString asLowercase)	
				ifAbsentPut: [OrderedCollection new])
					remove: aString asLowercase ifAbsent: [] ].
		self allUrlLinks at: aString asLowercase put: anObject ].
	^anObject! !

!URLResolver methodsFor: 'static pages' stamp: 'janko 3/19/2012 15:15'!
allHTMLPagesSize
	"sums sizes of all static pages"

	| fname sum |
	sum := 0.
	self allHtmlPageUrls do: [:url | 
		fname := self site homeDirectory, url.
		fname := fname copyReplaceAll: '/' with: '\'.
		fname asFilename exists 
			ifTrue: [sum := sum + fname asFilename fileSize] ].
	^sum

"URLResolver default allHTMLPagesSize"! !

!URLResolver methodsFor: 'static pages'!
allHtmlPageUrls
	"find all .htm and .html pages in directory hierarchy starting at aWebServer homeDirectory.
	return as collection of relative url links"

	^self allHtmlPageUrlsIn: self site homeDirectory.

"URLResolver default allHTMLPageUrls"! !

!URLResolver methodsFor: 'static pages'!
allHtmlPageUrlsIn: aDirectoryString
	"find all .htm and .html pages in directory hierarchy starting at a specified directory and all 	subdirectories.	Return as collection of relative url links"

	| collection dir |
	dir := aDirectoryString.
	dir last ~= $\ ifTrue: [dir := dir, '\'].
	dir asFilename exists ifFalse: [^#()].
	collection := OrderedCollection new.
	aDirectoryString asFilename directoryContents do: [:each | 
		(dir, each) asFilename isDirectory
			ifTrue: [collection addAll: (self allHtmlPageUrlsIn: (dir, each))]
			ifFalse: 
				[('.htm' match: each asFilename extension) ifTrue:
					[collection add: (self urlForFile: each asString directory: aDirectoryString)] ]
		].
	^collection.

"URLResolver default allHTMLPageUrlsIn: 'h:\wwwroot\planid' "! !

!URLResolver methodsFor: 'static pages'!
allHtmlPagesSize
	"sums sizes of all static pages"

	| fname sum |
	sum := 0.
	self allHtmlPageUrls do: [:url | 
		fname := self site homeDirectory, url.
		fname := fname copyReplaceAll: '/' with: '\'.
		fname asFilename exists 
			ifTrue: [sum := sum + fname asFilename fileSize] ].
	^sum

"URLResolver default allHTMLPagesSize"! !

!URLResolver methodsFor: 'request counting' stamp: ' 21/4/07 22:07'!
allPagesAndCounts

	"return total counts for all objects that have counters, most counted first"

	| collection |
	collection := OrderedCollection new.
	self counters keysAndValuesDo: [:object :counter |
		collection add: (Array
			with: object
			with: counter total)].
	^SortedCollection
		withAll: collection
		sortBlock: [:a :b | (a at: 2) > (b at: 2)]

"URLResolver default allPagesAndCounts"! !

!URLResolver methodsFor: 'private'!
allUrlLinks
	"return a dictionary with url as key and reference to an object with that url as value"
	^allURLLinks! !

!URLResolver methodsFor: 'request counting' stamp: 'np 10/17/2008 17:43'!
allUrlsAndCounters
	"return copies of all counters as dictionary with url as key"
	| dictionary |
	dictionary := Dictionary new.
	self counters keysAndValuesDo: [:object :counter |
		dictionary 
			at: (self halfUrlFor: object)
			put: counter aidaDeepCopy].
	^dictionary

"URLResolver default allUrlsAndCounters"
"
(BinaryObjectStorage onNew: 'counters.boss' asFilename writeStream)
	nextPut: URLResolver default allUrlsAndCounters;
	close
"! !

!URLResolver methodsFor: 'private' stamp: ' 21/4/07 22:07'!
allWebPages
	" return a dictionary with object reference as key and one on more urls for that object as value.
	first  is default one, when urls are dinamicaly generated"
	^allWebPages! !

!URLResolver methodsFor: 'private' stamp: 'janko 4/20/2012 17:17'!
autoUrlFor: anObject
	"use preferred url if possible. If that url already exist, add -a, -b, ... to url and repeat"
	| url extension lastPoint |
	url := anObject preferredUrl. url isNil ifTrue: [^self randomUrlFor: anObject].
	(url size >= 1 and: [url first = $/]) ifFalse: [self error: 'preferredUrl must start with / '].
	[(self objectOnUrl: url) notNil] whileTrue: "already exist"
		[lastPoint := url lastIndexOf: $. . lastPoint = 0 ifTrue: [lastPoint := url size+1].
		extension := url copyFrom: lastPoint to: url size.
		url := url copyReplaceAll: extension with: ''. 
		url isEmpty ifTrue:  [^self randomUrlFor: anObject].
		(url size > 1 and: [(url at: url size-1) = $-]) "already have an extension char!!"
			ifTrue: 
				[url last = $z ifTrue: [^self randomUrlFor: anObject]. "only to $z, then back to random!!"
				url := (url copyFrom: 1 to: url size-1), (String with: (url last asInteger + 1) asCharacter)]
			ifFalse: [url := url, '-a'].
		url := url, extension].
	^url

"URLResolver default halfUrlFor: (Document new id: 'SOP-0111-02').
URLResolver default autoUrlFor: (Document new id: 'SOP-0111-02')"! !

!URLResolver methodsFor: 'private-obsolete'!
changeToPreferedURL: aString
	"OBSOLETE!!"
	^self changeToPreferredUrl: aString! !

!URLResolver methodsFor: 'adding-removing'!
changeToPreferredUrl: anObject
 	"remove all existing urls and make this as only one"
	"BEWARE, all old urls will be erased, url references can be breaked!! "
	| url |
	url := anObject preferredUrl.
	url isNil ifTrue: [^nil].
	(url size > 1 and: [url first = $/]) ifFalse: [self error: 'preferredUrl must start with / '].
	self removeObject: anObject.
	self defaultUrl: url for: anObject.! !

!URLResolver methodsFor: 'adding-removing' stamp: ' 21/4/07 22:07'!
changeToURL: aString forObject: anObject
 	"remove all existing urls and make this as only one"
	"BEWARE, all ols urls will be erased, url references can be breaked!! "
	self removeObject: anObject.
	self defaultURL: aString forObject: anObject.! !

!URLResolver methodsFor: 'adding-removing'!
changeToUrl: aString for: anObject
 	"remove all existing urls and make this as only one"
	"BEWARE, all ols urls will be erased, url references can be breaked!! "
	self removeObject: anObject.
	self defaultUrl: aString for: anObject.! !

!URLResolver methodsFor: 'private'!
correctUrlEncoding
	"make sure all urls are decodedHTTP, without %20 etc"
	self allUrlLinks keys do: [:key | (key decodedHTTP ~= key) 
		ifTrue: [self allUrlLinks at: key decodedHTTP put: (self allUrlLinks at: key). 
			self allUrlLinks removeKey: key] ].
	self allWebPages values do: [:coll |
	coll copy do: [:each | (each decodedHTTP ~= each) 
		ifTrue: [coll at: (coll indexOf: each) put: each decodedHTTP] ] ].

"
self allURLLinks keys select: [:key | (key decodedHTTP ~= key)].
self allWebPages associations select: [:assoc |
	assoc value contains: [:each | (each decodedHTTP ~= each)] ].
"! !

!URLResolver methodsFor: 'request counting' stamp: ' 21/4/07 22:07'!
counterFor: anObject
	anObject isNil ifTrue: [^nil].
	(self counters includesKey: anObject)
		ifFalse: [self resetCounterFor: anObject].
	^self counters at: anObject! !

!URLResolver methodsFor: 'request counting'!
counterForUrl: anUrlString

	"return a counter for object with specified url. Nil if not exist"

	| object  |
	object := self objectOnUrl: anUrlString.
	object isNil ifTrue: [^nil].
	^self counterFor: object.

"URLResolver default counterForUrl: '/osn/g_l-vse.htm'"
"WebServer default totalCounter"
"WebServer default pagesCounter"! !

!URLResolver methodsFor: 'private' stamp: ' 21/4/07 22:07'!
counters

	"dictionary of web counters for every object, registered in URLResolver"

	counters isNil ifTrue: [self initCounters].
	^counters.! !

!URLResolver methodsFor: 'adding-removing'!
defaultToPreferredUrl: anObject
	"Default URL of that object is set to one suggested by its #prefferedUrl method."
	"Existing URLs are preserved, but just default URL used for automatic URL management"
	| url |
	url := anObject preferredUrl.
	url isNil ifTrue: [^nil].
	(url size > 1 and: [url first = $/]) ifFalse: [self error: 'preferredUrl must start with / '].
	self defaultUrl: url for: anObject.! !

!URLResolver methodsFor: 'private-obsolete'!
defaultURL: aString forObject: anObject
	"OBSOLETE!!"
	^self defaultUrl: aString for: anObject! !

!URLResolver methodsFor: 'adding-removing'!
defaultUrl: aString for: anObject
	"set url as default url for that object. This url is then used in dynamic url creation. If an object 
	does not already exist, then create a new entry first"
	| urls first defInx |
	self addObject: anObject withUrl: aString.  "just in case object is new one"
	"swap old default with new default url on a first place in collection"
	self site critical: 
		[urls := allWebPages at: anObject.
		first := urls first.
		defInx := urls indexOf: aString asLowercase.
		urls at: 1 put: (urls at: defInx).
		urls at: defInx put: first].! !

!URLResolver methodsFor: 'testing'!
existObject: anObject
	"true if this object is registered on son Url"
	^self allWebPages includesKey: anObject! !

!URLResolver methodsFor: 'private-obsolete'!
existURL: aString
	"OBSOLETE!!"
	^self existUrl: aString! !

!URLResolver methodsFor: 'testing'!
existUrl: aString
	"return true if URL has connection to some object"
	^self allUrlLinks includesKey: aString asLowercase! !

!URLResolver methodsFor: 'private'!
findHostPortOn: aSession
	"finds hostname and port for complete url. Returns association host->port"
	| host session|
	(self site host ~= '*') ifTrue:  "host ant port clearly defined in site's url identifier"
		[^self site host-> self site port]. 
	session := aSession notNil ifTrue: [aSession] ifFalse: [self firstSessionFromStack].
	session ifNil: 
		[session := self site sessionManager sessions values asOrderedCollection 
			detect: [:each | each lastRequest notNil] ifNone: [nil] ]. "good enough?" 
	session ifNil: [^'localhost'->self site port].
	host := (session lastRequest 
		headerAt: 'x-forwarded-host'   "find host from request"
		ifAbsent: [[session lastRequest host ]]) value. 
	^host->self site port! !

!URLResolver methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
fullUrlEncodedSpacesFor: anObject on: aSession
	"change spaces to %20"
	^(self fullUrlFor: anObject on: aSession) copyReplaceAll: ' ' with: '%20'! !

!URLResolver methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
fullUrlFor: anObject on: aSession
	"find or make a path for anObject and compose full url together with server address and 
	query string, eg: http://www.eranova.si/welcome.html?view=brief"
	^self 
		fullUrlFromPath: (self halfUrlFor: anObject)
		andParms: (aSession notNil ifTrue: [aSession parms] ifFalse: [#()])
		on: aSession! !

!URLResolver methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
fullUrlFromPath: aPathString andParms: aParmsDictionary on: aSession
	"compose full url: server address, document path and additional parameters in query string, 
	for instance: http://www.eranova.si/welcome.html?view=brief"
	| url |
	url := self urlFromHalfUrl: aPathString on: aSession.
	^self halfUrlFromPath: url andParms: aParmsDictionary on: aSession. "not very nice, i know ..."
	
"
| parms |
parms := Dictionary new.
parms at: 'view' put: 'brief'. parms at: 'id' put: '12345'. 
URLResolver default fullUrlFromPath: '/dzs/panorama.html' andParms: parms on: WebSession new
"! !

!URLResolver methodsFor: 'accessing'!
halfUrlFor: anObject
	"finds or composes an URL reference to that object . If the URL is new one, then it is written to both dictionaries for later lookup. If resolution is unsuccessfull then returns nil. If anObject dont have an url yet, url part for them is automatically generated, for example:  /objecto1638948.html"
	| newUrl urls |
	urls := (self allWebPages at: anObject ifAbsent: [
	      newUrl := ((anObject isKindOf: WebPage)  and: [anObject title notNil] )
			ifTrue: ['/', anObject title asLowercase,'.html']			
			ifFalse: [self autoUrlFor: anObject].
		self addObject: anObject withUrl: newUrl.
		OrderedCollection with: newUrl]).
	"just in case object has an empty collection of urls"
	(urls isNil or: [urls isEmpty]) ifTrue: 
		[self removeObject: anObject. ^self halfUrlFor: anObject].
	^urls at: 1.! !

!URLResolver methodsFor: 'accessing' stamp: 'janko 3/21/2008 16:51'!
halfUrlFromPath: aPathString andParms: aParmsDictionary on: aSession
	"compose half url: /document path and additional parameters in query string, for instance: 	/welcome.html?view=brief"
	| url parmsString newValue |
	url := aPathString.
	aParmsDictionary size > 0 ifTrue:
		[parmsString := ''.
		aParmsDictionary keysAndValuesDo: [:name :value |
			(value isKindOf: Set) ifTrue:[newValue := value asArray at: 1]ifFalse:[newValue := value].
			parmsString := parmsString, 
				(AIDASite convertToWebString: name asString), '=', 
				(AIDASite convertToWebString: newValue asString), '&'].  "value"
		url := url, '?', (parmsString copyFrom: 1 to: (parmsString size - 1))].
	^url

"
| parms |
parms := Dictionary new.
parms at: 'view' put: 'brief'. parms at: 'id' put: '12345'. 
URLResolver default halfUrlFromPath: '/dzs/panorama.html' andParms: parms on: WebSession new
"! !

!URLResolver methodsFor: 'request counting'!
incCounterFor: anObject
	"increment a web counter for that object. Only text/html object are counted
	Don't count temporary objects"
	(anObject aidaContentType = 'text/html') ifFalse: [^nil].
	self site critical: 
		[(self counters includesKey: anObject) ifFalse: [self resetCounterFor: anObject].
		(self counters at: anObject) incCounter.
		"self totalCounter incCounter   **aWebServer already counts!! "]! !

!URLResolver methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initCounters
	"init a counters dictionary and open a new counter for each already registered object"
	counters := Dictionary new. 
	self allWebPages keys do: [:object | self resetCounterFor: object].! !

!URLResolver methodsFor: 'initialize-release'!
initUrlLinks
	allURLLinks := Dictionary new.! !

!URLResolver methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initWebPages
	allWebPages := IdentityDictionary new.! !

!URLResolver methodsFor: 'initialize-release'!
initialize
	self initWebPages.
	self initUrlLinks.
	self initCounters.! !

!URLResolver methodsFor: 'private' stamp: ' 21/4/07 22:07'!
isWebElement: anObject


	" test if anObject is a web element, such as web app and write warning to the transcript"
	
	(anObject isKindOf: WebElement) ifTrue:
		[Transcript cr; show: '*** WARNING: URLResolver detected a ', 
		anObject class printString, '  will be registered ***'; cr.

		"to detect from where this request comes"
		"self halt"
		].! !

!URLResolver methodsFor: 'accessing'!
methodImageForUrl: aString 
	"maybe a method image can be done from current WebStyle?"
	|  name selector |
	('/img/*' match: aString) ifFalse: [^nil].
	name := (aString readStream upTo: $/ ; upTo: $/; upTo: $. ) asLowercase.
	selector := self site style class allSelectors 
		detect: [:each | each asString asLowercase = name] ifNone: [^nil].
	^WebMethodImage fromMethod: selector on: self site style contentType: 'image/gif' site: self site

"URLResolver default methodImageForURL: '/img/eranovaLogoGif.gif' "! !

!URLResolver methodsFor: 'accessing'!
objectOnDifferentPresentationUrl: aString
	"check if different representation (like .json or .xml) is requested and 
       returns its object by skipping the extension in URL"
	| url |
	url := aString asLowercase.
	url := ('*.json' match: url)
		ifTrue: [url copyReplaceAll: '.json' with: '']
		ifFalse: [	('*.xml' match: url)
			ifTrue: [url copyReplaceAll: '.xml' with: '']
			ifFalse: [url "later for more"] ].
	^self allUrlLinks at: url ifAbsent: [nil]! !

!URLResolver methodsFor: 'accessing'!
objectOnUrl: aString
	" finds a reference to an object, specified by that URL string. If not yet known, try to 
	find it as a html file. if not found, search method resources in current WebStyle too.."
	"If still not found, check if different representation (like .json or .xml) is requested"
	| object |
	^self allUrlLinks at: aString asLowercase ifAbsent: 
		["object := self fileProxyForURL: aString." "moved to router and staticServer"
		self site staticServer. "just to create it od not yet = lazy migration"
		object := self methodImageForUrl: aString.
		object notNil ifTrue: [^self addObject: object withUrl: aString].
		object := self objectOnDifferentPresentationUrl: aString. "like .json or .xml"
		^object]. "or nil"

"URLResolver default objectOnURL: '/osn/g_l-vse.htm' "! !

!URLResolver methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
objectsOfClass: aClass
	^self allWebPages keys select: [:object | object class = aClass ]

"URLResolver default objectsOfClass: WebMethodImage"! !

!URLResolver methodsFor: 'private-obsolete'!
ooRefFromURL: aString
	"OBSOLETE!!"
	^self objectOnUrl: aString! !

!URLResolver methodsFor: 'private' stamp: ' 21/4/07 22:07'!
randomGen
	randomGen isNil ifTrue: [self randomGen: Random new].
	^randomGen! !

!URLResolver methodsFor: 'private' stamp: ' 21/4/07 22:07'!
randomGen: anObject
	randomGen := anObject! !

!URLResolver methodsFor: 'private'!
randomUrlFor: anObject
	| number ext url |
	number := (self site class random next * 10000000) asInteger.
	ext := self site mimeMap extensionForType: anObject aidaContentType.
	ext isNil ifTrue: [ext := 'html'].
	url := '/object/o', number printString, '.', ext.
	^(self objectOnUrl: url) isNil  "avoid duplicates!!"
		ifTrue: [url]
		ifFalse: [self randomUrlFor: anObject]! !

!URLResolver methodsFor: 'static pages'!
refreshAllHtmlPages
	""

	| count |
	count := 1.
	self allWebPages keys do: [:object |
		(object isKindOf: FileProxy) ifTrue:	 
			[count \\ 10 = 0 ifTrue: [Transcript cr; show: count printString].
			object refreshContent.
			count := count + 1] ].

"URLResolver default refreshAllHTMLPages"! !

!URLResolver methodsFor: 'private'!
regenerateAllUrlLinks
	"from urls in allWebPages"
	"AIDASite default urlResolver regenerateAllUrlLinks"
	self allWebPages keysAndValuesDo: [:object :urls |
		urls do: [:url | self allUrlLinks at: url put: object] ].! !

!URLResolver methodsFor: 'static pages'!
registerAllHtmlPages
	"if not already, then register all static html pages in directory hierarchy starting
	at aWebServer homeDirectory. Opan also counters for them"

	| count proxy |
	count := 1.
	self allHtmlPageUrls do: [:url | 
		count \\ 10 = 0 ifTrue: [Transcript cr; show: count printString].
		proxy := self objectOnUrl: url.
		self counterFor: proxy.
		count := count + 1].

"URLResolver default registerAllHTMLPages"! !

!URLResolver methodsFor: 'indexing'!
reindexAllObjects
	"all text/html objects are reindexed"
	self allWebPages keysDo: [:object |
		(object aidaContentType = 'text/html') ifTrue:
			[self site index indexObject: object] ]

"URLResolver default reindexAllObjects"! !

!URLResolver methodsFor: 'indexing'!
reindexNonIndexedObjects
	"all text/html objects are reindexed"
	self allWebPages keysDo: [:object |
		(object aidaContentType = 'text/html') ifTrue:
			[(self site index indexedObjects includesKey: object) ifFalse:
				[self site index indexObject: object] ] ]

"URLResolver default reindexNonIndexedObjects"! !

!URLResolver methodsFor: 'static pages' stamp: ' 21/4/07 22:07'!
releaseAllHTMLPages

	self allWebPages keys do: [:obj |
		(obj isKindOf: FileProxy) ifTrue:
	 		[obj releaseContent] ]

"URLResolver default releaseAllHTMLPages"! !

!URLResolver methodsFor: 'static pages'!
releaseAllHtmlPages

	self allWebPages keys do: [:obj |
		(obj isKindOf: FileProxy) ifTrue:
	 		[obj releaseContent] ]

"URLResolver default releaseAllHTMLPages"! !

!URLResolver methodsFor: 'static pages'!
releaseAllImages
	self allWebPages keys do: [:obj |
		((obj isKindOf: FileProxy) and: ['*image*' match: obj aidaContentType])
			ifTrue: [obj releaseContent] ]

"URLResolver default releaseAllImages"! !

!URLResolver methodsFor: 'static pages' stamp: ' 21/4/07 22:07'!
releaseAllStaticPages

	self allWebPages keysDo: [:object | 
		(object isKindOf: FileProxy) ifTrue: [object releaseContent] ]

"URLResolver default releaseAllStaticPages"! !

!URLResolver methodsFor: 'request counting' stamp: ' 21/4/07 22:07'!
removeCounterFor: anObject


	(self counters includesKey: anObject)
		ifTrue: [self counters removeKey: anObject]! !

!URLResolver methodsFor: 'request counting'!
removeNonHtmlCounters
	self counters keys do: [:object |
		object aidaContentType ~= 'text/html' ifTrue:
			[self removeCounterFor: object] ]

"URLResolver default removeNonHTMLCounters"! !

!URLResolver methodsFor: 'adding-removing'!
removeObject: anObject
	"remove object and all its URLs. Returns true if object existed and false if not. 
	Remove also its web counter"
	| urls |
	self site critical:
		[urls := (self allWebPages at: anObject ifAbsent: [^nil]).
		self allWebPages removeKey: anObject.
		urls notNil ifTrue: [urls do: [: each | self allUrlLinks removeKey: each ifAbsent: [] ] ].
		self counters removeKey: anObject ifAbsent: [] ].
	^true! !

!URLResolver methodsFor: 'adding-removing'!
removeObjectWithUrl: aString

"remove object and all its URLs. Returns true if object existed and false if not"

	| object |
	object := allURLLinks at: aString asLowercase ifAbsent: [^false].
	^self removeObject: object.! !

!URLResolver methodsFor: 'adding-removing' stamp: 'janko 8/25/2012 18:40'!
removeObjectsOfClass: aClass
	"fast removal even if dictionaries are really big"
	| toRemove newWebPages newURLLinks newCounters |
	toRemove := (self objectsOfClass: aClass) asSet.
	newWebPages := Dictionary aidaWithAll:
		(self allWebPages associations reject: [:assoc | toRemove includes: assoc key]).
	newURLLinks := Dictionary aidaWithAll:
		(self allUrlLinks associations reject: [:assoc | toRemove includes: assoc value]).
	newCounters := Dictionary aidaWithAll:
		(self counters associations reject: [:assoc | toRemove includes: assoc key]).
	self site critical:
		[allWebPages := newWebPages.
		allURLLinks := newURLLinks.
		counters := newCounters]


"URLResolver default removeObjectsOfClass: WebUser"
"URLResolver default allWebPages size  38 45"! !

!URLResolver methodsFor: 'adding-removing' stamp: 'janko 12/6/2008 18:38'!
removeObjectsOfClassNamed: aString
	"good for removing Obsolete classes!!"
	self site critical:
		[self allWebPages keys do: [:object | 
			object class name= aString ifTrue: [self removeObject: object]] ].

"URLResolver default removeObjectsOfClassNamed: WebMethodImage"
"URLResolver default allWebPages size 10934"! !

!URLResolver methodsFor: 'adding-removing'!
removeObjectsOfObsoleteClass
	self site critical:
		[self allWebPages keys do: [:object | 
			object class isObsolete ifTrue: [self removeObject: object]] ].

"URLResolver default removeObjectsOfObsoleteClass"! !

!URLResolver methodsFor: 'adding-removing'!
removeUrl: aString
	"remove this URL and also object, if this url was the last one pointed to object Returns 
	true if url existed and false if not. Also remove web counter"
	| object |
	self site critical:
		[object := (self allUrlLinks at: aString asLowercase ifAbsent: [^nil]).
		(self allWebPages at: object) remove: aString asLowercase ifAbsent: [].
		(self allWebPages at: object) isEmpty ifTrue: [self allWebPages removeKey: object]. 
		self allUrlLinks removeKey: aString asLowercase.
		self counters removeKey: object ifAbsent: [] ].
	^true! !

!URLResolver methodsFor: 'request counting' stamp: ' 21/4/07 22:07'!
resetAllCounters

	self counters values do: [:each | each reset].

"URLResolver default resetAllCounters"! !

!URLResolver methodsFor: 'request counting' stamp: ' 21/4/07 22:07'!
resetCounterFor: anObject
	"reset counters for specified object. If not yet exist, initialize it first"
	anObject isNil ifTrue: [^nil].
	self site critical:
		[(self counters includesKey: anObject) ifFalse: 
			[self counters at: anObject put: WebCounter new].
		(self counters at: anObject) reset]! !

!URLResolver methodsFor: 'accessing'!
resourceFor: aRequest
	"returns a resource (domain object) to respond to that request"
	| url | 
	url := AIDASite convertFromWeb: aRequest uriString on: aRequest session.  "for international Urls"
	^self objectOnUrl: url! !

!URLResolver methodsFor: 'accessing'!
scanForUrlsFrom: aWebPage

"start looking for all WebLinks in pages starting from aWebPage and converting them to the URL links in instance variables allWebPages and allURLLinks."! !

!URLResolver methodsFor: 'private' stamp: ' 21/4/07 22:07'!
site
	"a parent site with this url resolver"
	^site! !

!URLResolver methodsFor: 'private' stamp: ' 21/4/07 22:07'!
site: anAIDASite
	site := anAIDASite.! !

!URLResolver methodsFor: 'static pages' stamp: ' 21/4/07 22:07'!
urlForFile: aFilenameString directory: aDirectoryString

	| path dir |
	dir := aDirectoryString.
	dir last ~= $\ ifTrue: [dir := dir, '\'].
	path := dir, aFilenameString.
	path := path copyReplaceAll: self site homeDirectory with: ''.
	^path copyReplaceAll: '\' with: '/'

"URLResolver default urlForFile: 'index.htm' directory: 'h:\wwwroot\planid\osn' "! !

!URLResolver methodsFor: 'accessing'!
urlFromHalfUrl: aString on: aSession
	| host port hostPort portString protocolString |
	hostPort := self findHostPortOn: aSession.
	host := hostPort key. port := hostPort value.
	portString := (aSession notNil and: [aSession isEncrypted]) 
		ifFalse: [(port = 80) ifTrue: [''] ifFalse: [':', port printString] ]
		ifTrue: [(self site sslPort = 443) ifTrue: [''] ifFalse: [':', self site sslPort printString] ].
	protocolString := (aSession notNil and: [aSession isEncrypted])  
		ifFalse: ['http://'] ifTrue: ['https://'].
	^protocolString, host asLowercase, portString, aString.! !

!URLResolver class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
default
	^AIDASite default urlResolver! !

!URLResolver class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newOn: anAIDASite
	^super new 
		initialize; 
		site: anAIDASite! !

!URLResolverTest methodsFor: 'running' stamp: 'mivsek 8/22/2007 21:08'!
setUp
"DANGEROUS!!
	server := Swazoo.SwazooServer singleton.
	server initialize.  ""to remove all stuff and stop it""
	site := AIDASite newNamed: 'test'.
"! !

!URLResolverTest methodsFor: 'running' stamp: 'mivsek 8/22/2007 21:09'!
tearDown
"	site := server siteNamed: 'test'.
	site stop.
	server removeSite: site.
	server := nil. site := nil.
"! !

!URLResolverTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testSetUp! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allVersionSpecs
	^self olderVersionSpecs, (Array with: self), self newerVersionSpecs! !

!VersionSpec methodsFor: 'private' stamp: ' 21/4/07 22:07'!
clearCurrent
	current := false! !

!VersionSpec methodsFor: 'private' stamp: ' 21/4/07 22:07'!
current
	"this version current one? Current version object have a direct url, without 'version=' in query part"
	^current! !

!VersionSpec methodsFor: 'private' stamp: ' 21/4/07 22:07'!
current: aBoolean
	current := aBoolean! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
currentVersionSpec
	"find a version spec of current object in a chain"
	self isCurrent ifTrue: [^self].
	^self olderVersionSpecs detect: [:each | each isCurrent] ifNone: 
		[^self newerVersionSpecs detect: [:each | each isCurrent] 
			ifNone: [self error: 'no current version!!'] ].! !

!VersionSpec methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isCurrent
	^self current! !

!VersionSpec methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isNewest
	^self next isNil! !

!VersionSpec methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isOldest
	^self parent isNil! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
newerVersionSpecs
	"return all version specs of that object, newer than this one"
	self isNewest ifTrue: [^#()].
	^OrderedCollection new 
		add: self next version; addAll: self next version newerVersionSpecs;
		yourself! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
next
	"next version of an object in version chain, if any"
	^next! !

!VersionSpec methodsFor: 'private' stamp: ' 21/4/07 22:07'!
next: anObject
	next := anObject! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
number
	"version number, integer by default, but it can be any string"
	^number! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
number: aString
	number := aString! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
object
	"object for which is this version spec"
	^object! !

!VersionSpec methodsFor: 'private' stamp: ' 21/4/07 22:07'!
object: anObject
	object := anObject! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
olderVersionSpecs
	"return all version specs of that object, older than this one"
	self isOldest ifTrue: [^#()].
	^OrderedCollection new 
		addAll: self parent version olderVersionSpecs; add: self parent version;
		yourself! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
otherVersionSpecs
	"older and newer versions, if any"
	^self olderVersionSpecs, self newerVersionSpecs! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
parent
	"older version of an object in version chain, if any. It is a parent of that object, 
	because it is derived from it"
	^parent! !

!VersionSpec methodsFor: 'private' stamp: ' 21/4/07 22:07'!
parent: anObject
	parent := anObject! !

!VersionSpec methodsFor: 'private' stamp: ' 21/4/07 22:07'!
printString
	^'aVersionSpec version: ', self number! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setCurrent
	self current: true.
	self otherVersionSpecs do: [:each | each clearCurrent].! !

!VersionSpec methodsFor: 'initalize-release' stamp: ' 21/4/07 22:07'!
setDefaultNumber
	self isOldest 
		ifTrue: [self number: '1'] 
		ifFalse: [self setIncrementedNumberFromParent]! !

!VersionSpec methodsFor: 'initalize-release' stamp: ' 21/4/07 22:07'!
setIncrementedNumberFromParent
	"for now, later it should increment last number in string"
	self number: (self parent version number asInteger + 1) printString! !

!VersionSpec methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
versionSpecWithNumber: aString
	"find spec  with that version number"
	self number = aString ifTrue: [^self].
	^self olderVersionSpecs detect: [:each | each number = aString] ifNone: 
		[^self newerVersionSpecs detect: [:each | each number = aString] ifNone: [nil] ].! !

!VersionSpec class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
firstFor: anObject
	"for a first version of an object"
	^super new
		object: anObject;
		setDefaultNumber;
		setCurrent! !

!VersionSpec class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
new
	^self shouldNotImplement! !

!VersionSpec class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newFromParent: anOldObject for: aNewObject
	| newSpec |
	newSpec := super new
		object: aNewObject;
		parent: anOldObject;
		setIncrementedNumberFromParent;
		clearCurrent.
	aNewObject version: newSpec.
	anOldObject version next: aNewObject.
	^newSpec! !

!VersionSpecTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testFirstCreation
	| spec |
	spec := VersionSpec firstFor: ''.
	self assert: spec number = '1'.
	self assert:  spec isCurrent.
	self assert:  spec isOldest.
	self assert:  spec isNewest.! !

!VersionSpecTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testSearchByNumber
	| o spec |
	o := VersionedObject new.
	spec := VersionSpec newFromParent: o for: VersionedObject new.
	self assert: ((spec versionSpecWithNumber: '2') number = '2').
	self assert: ((spec versionSpecWithNumber: '1') number = '1').
	self assert: (spec versionSpecWithNumber: '3') isNil.! !

!VersionSpecTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testSecondCreation
	| o spec |
	o := VersionedObject new.
	spec := VersionSpec newFromParent: o for: VersionedObject new.
	self assert: spec number = '2'.
	self deny:  spec isCurrent.
	self deny:  spec isOldest.
	self assert:  spec isNewest.
	self assert: spec parent == o.
	spec setCurrent.
	self assert:  spec isCurrent.
	self deny: spec parent version isCurrent.! !

!VersionSpecTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testSetCurrent
	| o spec |
	o := VersionedObject new.
	spec := VersionSpec newFromParent: o for: VersionedObject new.
	self assert:  o isCurrentVersion.
	self deny:  spec isCurrent.
	spec setCurrent.
	self assert:  spec isCurrent.
	self deny: o isCurrentVersion.! !

!VersionedExample methodsFor: 'accessing' stamp: ' 21/4/07 22:08'!
body
	^body! !

!VersionedExample methodsFor: 'accessing' stamp: ' 21/4/07 22:08'!
body: anObject
	body := anObject! !

!VersionedExample methodsFor: 'copying' stamp: ' 21/4/07 22:08'!
copyContentsTo: anObject
	anObject title: self title copy.
	anObject body: self body copy.! !

!VersionedExample methodsFor: 'printing' stamp: ' 21/4/07 22:08'!
printString
	^'aVersionedExample ', 
		(self title notNil ifTrue: [self title] ifFalse: ['']), ' ', 
		(self body notNil ifTrue: [self body] ifFalse: [''])! !

!VersionedExample methodsFor: 'accessing' stamp: ' 21/4/07 22:08'!
title
	^title! !

!VersionedExample methodsFor: 'accessing' stamp: ' 21/4/07 22:08'!
title: anObject
	title := anObject! !

!VersionedObject methodsFor: 'accessing-versions' stamp: ' 21/4/07 22:07'!
allVersions
	^self version allVersionSpecs collect: [:each | each object]! !

!VersionedObject methodsFor: 'copying' stamp: ' 21/4/07 22:07'!
asNewVersion
	"return a new version of that object with all its current contents"
	| new |
	new := self class new.
	new version: (VersionSpec newFromParent: self for: new).
	self copyContentsTo: new.
	^new! !

!VersionedObject methodsFor: 'copying' stamp: ' 21/4/07 22:07'!
copyContentsTo: anObject
	"override in subclases to copy contents to a new object"! !

!VersionedObject methodsFor: 'accessing-current' stamp: ' 21/4/07 22:07'!
currentVersion
	"find a current version of object in a version chain"
	^self version currentVersionSpec object! !

!VersionedObject methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initVersion
	self version: (VersionSpec firstFor: self)! !

!VersionedObject methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isCurrentVersion
	^self version isCurrent! !

!VersionedObject methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isNewestVersion
	^self version isNewest! !

!VersionedObject methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isOldestVersion
	^self version isOldest! !

!VersionedObject methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isOnlyVersion
	^self version isOldest & self version isNewest! !

!VersionedObject methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isVersionedObject
	^true! !

!VersionedObject methodsFor: 'accessing-versions' stamp: ' 21/4/07 22:07'!
newerVersions
	^self version newerVersionSpecs collect: [:each | each object]! !

!VersionedObject methodsFor: 'accessing-versions' stamp: ' 21/4/07 22:07'!
newestVersion
	self isNewestVersion ifTrue: [^self].
	^self newerVersions last! !

!VersionedObject methodsFor: 'accessing-versions' stamp: ' 21/4/07 22:07'!
nextVersion
	"next version of an object in version chain, if any"
	^self version next! !

!VersionedObject methodsFor: 'accessing-versions' stamp: ' 21/4/07 22:07'!
olderVersions
	^self version olderVersionSpecs collect: [:each | each object]! !

!VersionedObject methodsFor: 'accessing-versions' stamp: ' 21/4/07 22:07'!
oldestVersion
	self isOldestVersion ifTrue: [^self].
	^self olderVersions first! !

!VersionedObject methodsFor: 'accessing-versions' stamp: ' 21/4/07 22:07'!
parentVersion
	"older version of an object in version chain, if any. It is a parent of that object, 
	because it is derived from it"
	^self version parent! !

!VersionedObject methodsFor: 'private'!
removeOldVersions
	"remove all versions of this document, which are older than current version"
	| vobjects |
	vobjects := self currentVersion olderVersions.
	vobjects do: [:each | 
		each version parent: nil; next: nil.
		each version: nil]! !

!VersionedObject methodsFor: 'accessing-current' stamp: ' 21/4/07 22:07'!
setCurrentVersion
	"set this object as current version, which has always the same identity "
	| other |
	self isCurrentVersion ifTrue: [^nil].
	other := self currentVersion.
	self swapIdentityWith: other.
	^other version setCurrent "because other is now me!! "! !

!VersionedObject methodsFor: 'private' stamp: ' 21/4/07 22:07'!
swapIdentityWith: anObject
	"carefully adjust object references (object, parent, next) in version specs too!!"
	|  o1 o2 s1Spec s2Spec |
	o1 := self. o2 := anObject.  s1Spec := o1 version. s2Spec := o2 version.
	o1 become: o2.
	s1Spec object: o2. s2Spec object: o1.
	s1Spec isNewest ifFalse:
		[s1Spec next == o2 ifTrue: [s1Spec next: o1] ifFalse: [s1Spec next version parent: o2] ].
	s1Spec isOldest ifFalse:
		[s1Spec parent == o2 ifTrue: [s1Spec parent: o1] ifFalse: [s1Spec parent version next: o2]].
	s2Spec isNewest ifFalse:
		[s2Spec next == o1 ifTrue: [s2Spec next: o2] ifFalse: [s2Spec next version parent: o1] ].
	s2Spec isOldest ifFalse:
		[s2Spec parent == o1 ifTrue: [s2Spec parent: o2] ifFalse: [s2Spec parent version next: o1]].! !

!VersionedObject methodsFor: 'copying'!
undoNewVersion
	"remove new version, if not yet current. Return previous one"
	| previous |
	self isCurrentVersion ifTrue: [^self error: 'cannot remove current version'].
	self isNewestVersion ifFalse: [^self error: 'cannot remove version which is nost last/newest'].
	self isOnlyVersion ifTrue: [^self error: 'cannot remove the one and only version'].
	previous := self parentVersion.
	previous version next: nil.  "this will break a chain of versions to this one"
	^previous! !

!VersionedObject methodsFor: 'private' stamp: ' 21/4/07 22:07'!
version
	version isNil ifTrue: [self initVersion].
	^version! !

!VersionedObject methodsFor: 'private' stamp: ' 21/4/07 22:07'!
version: aVersionSpec
	version := aVersionSpec! !

!VersionedObject methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
versionNumber
	"version number, integer by default, but it can be any string"
	^self version number! !

!VersionedObject methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
versionNumber: aString
	"set version number other than default"
	^self version number: aString! !

!VersionedObject methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
versionWithNumber: aString
	"find version with that number"
	| spec |
	spec := self version versionSpecWithNumber: aString.
	^spec notNil ifTrue: [spec object] ifFalse: [nil]! !

!VersionedObjectTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testFirstCreation
	| o |
	o := VersionedObject new.
	self assert: o versionNumber = '1'.
	self assert:  o isCurrentVersion.
	self assert:  o isOldestVersion.
	self assert:  o isNewestVersion.
	self assert:  o parentVersion isNil.
	self assert:  o nextVersion isNil.! !

!VersionedObjectTest methodsFor: 'testing-identity swap' stamp: ' 21/4/07 22:08'!
testIdentityPreservation
	| o1 o2 c |
	o1 := VersionedExample new. o1 title: 'test'.
	o2 := o1 asNewVersion.  o2 title: 'sectest'.
	c := o1 currentVersion.
	self assert: c == o1.
	o2 setCurrentVersion.
	self assert: c == o1 currentVersion. "identity must be preserved!! "! !

!VersionedObjectTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testNewVersion
	| o o2 |
	o := VersionedObject new.
	o2 := o asNewVersion.
	self assert: o2 versionNumber = '2'.
	self deny:  o2 isCurrentVersion.
	self deny:  o2 isOldestVersion.
	self assert:  o2 isNewestVersion.
	self assert: o2 parentVersion == o.! !

!VersionedObjectTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testNewVersionOfExample
	| o o2 |
	o := VersionedExample new. o title: 'test'; body: 'this is test'.
	o2 := o asNewVersion.
	self assert: o2 title = o title.
	self assert: o2 body = o body.! !

!VersionedObjectTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testSearchByNumber
	| o1 o2 o3 |
	o1 := VersionedExample new. o1 title: 'first'. o2 := o1 asNewVersion. o2 title: 'second'. 
	o3 := o2 asNewVersion. o3 title: 'third'. 
	self assert: ((o2 versionWithNumber: '1') versionNumber = '1').
	self assert: ((o2 versionWithNumber: '2') versionNumber = '2').
	self assert: ((o2 versionWithNumber: '3') versionNumber = '3').
	self assert: ((o2 versionWithNumber: '4') isNil).! !

!VersionedObjectTest methodsFor: 'testing-identity swap' stamp: ' 21/4/07 22:08'!
testSetCurrent
	| o1 o2 |
	o1 := VersionedObject new. o2 := o1 asNewVersion.
	self assert:  o1 isCurrentVersion.
	self deny:  o2 isCurrentVersion.
	o2 setCurrentVersion.
	self assert:  o1 isCurrentVersion. "o1 and o2 identities are swapped!! "
	self deny:  o2 isCurrentVersion.! !

!VersionedObjectTest methodsFor: 'testing-identity swap' stamp: ' 21/4/07 22:08'!
testSwap3Objects
	| o1 o2 o3 |
	o1 := VersionedExample new. o1 title: 'first'. o2 := o1 asNewVersion. o2 title: 'second'. 
	o3 := o2 asNewVersion. o3 title: 'third'. o3 version setCurrent. "to debug more easily"
	self assert: o1 version next == o2. 
	self assert: o2 version parent == o1. self assert: o2 version next == o3.
	self assert: o3 version parent == o2.
	o1 setCurrentVersion.
	self assert: o3 version next == o2. "test chain integrity"
	self assert: o2 version parent == o3. self assert: o2 version next == o1.
	self assert: o1 version parent == o2.
	self assert: o1 title = 'third'. self assert: o2 title = 'second'. self assert: o3 title = 'first'.! !

!VersionedObjectTest methodsFor: 'testing-identity swap' stamp: ' 21/4/07 22:08'!
testSwap3Objects2
	| o1 o2 o3 |
	o1 := VersionedExample new. o1 title: 'first'. o2 := o1 asNewVersion. o2 title: 'second'. 
	o3 := o2 asNewVersion. o3 title: 'third'. 
	self assert: o1 version next == o2. 
	self assert: o2 version parent == o1. self assert: o2 version next == o3.
	self assert: o3 version parent == o2.
	o3 setCurrentVersion.
	self assert: o3 version next == o2. "test chain integrity"
	self assert: o2 version parent == o3. self assert: o2 version next == o1.
	self assert: o1 version parent == o2.
	self assert: o1 title = 'third'. self assert: o2 title = 'second'. self assert: o3 title = 'first'.! !

!VersionedObjectTest methodsFor: 'testing-identity swap' stamp: ' 21/4/07 22:08'!
testSwapIdentity
	| o1 o2 |
	o1 := VersionedExample new. o1 title: 'first'.
	o2 := o1 asNewVersion. o2 title: 'second'.
	self assert: o1 isCurrentVersion.
	self assert: o1 title = 'first'. self assert: o2 title = 'second'.
	o2 setCurrentVersion.
	self assert: o1 isCurrentVersion. "because of identity swap!! "
	self assert: o1 title = 'second'. self assert: o2 title = 'first'.! !

!VersionedObjectTest methodsFor: 'testing-identity swap' stamp: ' 21/4/07 22:08'!
testSwapIdentity2
	| o1 o2 s1 s2 |
	o1 := VersionedExample new. o1 title: 'first'.
	o2 := o1 asNewVersion. o2 title: 'second'.
	s1 := o1 version. s2 := o2 version.
	self assert: s1 object title = 'first'. self assert: s2 object title = 'second'.
	o2 setCurrentVersion.
	"version chain order must be preserved!!"
	self assert: s1 object title = 'first'. self assert: s2 object title = 'second'.! !

!VersionedObjectTest methodsFor: 'testing-identity swap' stamp: ' 21/4/07 22:08'!
testSwapIdentity3
	| o1 o2 |
	o1 := VersionedExample new. o1 title: 'first'.
	o2 := o1 asNewVersion. o2 title: 'second'. o2 version setCurrent. "to debug more easily"
	o1 setCurrentVersion. 
	self assert: o1 version object == o1. "check references to spec and back"
	self assert: o2 version object == o2.
	self assert: o1 version parent == o2. "test chain integrity"
	self assert: o2 version next == o1.! !

!VersionedObjectTest methodsFor: 'testing-identity swap' stamp: ' 21/4/07 22:08'!
testSwapIdentity4
	| o1 o2 |
	o1 := VersionedExample new. o1 title: 'first'.
	o2 := o1 asNewVersion. o2 title: 'second'. 
	o2 setCurrentVersion.  "to test other part of VersionedObject swapIdentity"
	self assert: o1 version object == o1. "check references to spec and back"
	self assert: o2 version object == o2.
	self assert: o1 version parent == o2. "test chain integrity"
	self assert: o2 version next == o1.! !

!VersionedObjectTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testVersionIncrement
	| o o2 |
	o := VersionedObject new. o versionNumber: '1234'.
	o2 := o asNewVersion.
	self assert: o2 versionNumber = '1235'.! !

!VersionedObjectTest methodsFor: 'testing-url links' stamp: ' 21/4/07 22:08'!
testWebLink
	| o1 o2 link |
	o1 := VersionedExample new. o1 title: 'first'.
	o2 := o1 asNewVersion. o2 title: 'second'.
	link := WebLink linkTo: o1.
	self assert: link ooReference == o1.
	self deny: (link parms includesKey: 'version').
	link := WebLink linkTo: o2.
	self assert: link ooReference == o1.  "o1 is current version!! "
	self assert: (link parms at: 'version') = '2'.! !

!ViewTabs methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
addView: aSymbol description: aString
	(self views contains: [:each | each key == aSymbol asSymbol]) 
		ifFalse: [self views add: (Association key: aSymbol asSymbol value: (Array with: aString with: #()))]! !

!ViewTabs methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
addView: aSymbol description: aString also: aSymbolArray
	"if view is in aSymbolArray, then it is also considered selected"
	(self views contains: [:each | each key == aSymbol asSymbol]) 
		ifFalse: [self views add: (Association key: aSymbol asSymbol 
			value: (Array with: aString with: aSymbolArray))]! !

!ViewTabs methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initViews
	views := OrderedCollection new.! !

!ViewTabs methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	super initialize.
	self initViews.
	^self! !

!ViewTabs methodsFor: 'private'!
prepareTabsList
	| app inx view linkTarget |
	app := self app.  inx := 1. 
      view := app view. view = #'' ifTrue: [view := #main].
	linkTarget := app isStandaloneApp ifTrue: [app class] ifFalse: [app observee].
	self views do: [:each | 
		view = each key | ((each value at: 2) includes: view)
			ifTrue: 
				[self addLinkTo: linkTarget text: (each value at: 1) view: each key.
				self selected: inx]
"		 	ifTrue: [self addTextBold: (each value at: 1). self selected: inx] "
			ifFalse: [self addLinkTo: linkTarget text: (each value at: 1) view: each key].
		inx := inx + 1]! !

!ViewTabs methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareTabsList.
	^super streamHtmlTo: aStream for: aRequest on: aSession! !

!ViewTabs methodsFor: 'private' stamp: ' 21/4/07 22:07'!
views
	^views! !

!ViewTabs class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebAnchor methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
name: aString
	"name of the anchor. Used for referencing in web links"
	self attributesAt: #name put: aString.! !

!WebAnchor methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
shouldIndent
	^true! !

!WebAnchor methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession. 
	aStream nextPutAll: self ident, '<a'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '>'.
	"print a text with attributes and composite elements"
	super streamHtmlTo: aStream for: aRequest on: aSession.
	aStream nextPutAll: '</a>', self  eol.! !

!WebAnchor class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
name: aString
	"make an anchor with specified name"
	^self new name: aString! !

!WebAnchor class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
name: aString text: anotherString
	"make an anchor with specified name and text"
	^self new name: aString; text: anotherString.! !

!WebAnchor class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
nr: aNumber
	"make a web anchor in format 'anchorx', for example 'anchor6'"
	^self new name: ('anchor', aNumber printString).! !

!WebAnchor class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
nr: aNumber text: aString
	"make an anchor with specified numberName ('anchor5') and text"
	^(self nr: aNumber) text: aString.! !

!WebApplication methodsFor: 'private-form posting'!
acceptInputsAndActionFrom: aRequest
	|  form |
	form := self formPostedFrom: aRequest.
	form acceptInputsFrom: aRequest.
	self callActionFrom: aRequest. "if any"! !

!WebApplication methodsFor: 'private-obsolete' stamp: ' 21/4/07 22:07'!
actionMainSearch
	self actionSearch! !

!WebApplication methodsFor: 'private-obsolete'!
actionSearch
	"a generic action when search button is pressed. It can be in almost every page."
	| indexApp |
	indexApp := self site index aidaWebAppFor: self session.
	indexApp searchString: self search. self search: ''.
	indexApp actionMain.
	self redirectTo: self site index view: #results! !

!WebApplication methodsFor: 'private-views'!
activateView: aSymbol
	self activeViews add: aSymbol! !

!WebApplication methodsFor: 'private-views'!
activeViews
	"views which have currently open pages on user's browser"
	^self otherAt: #activeViews ifAbsent: [self initActiveViews]! !

!WebApplication methodsFor: 'private-window delegation'!
add: aWebElement
	"add to a form of currently executing context"
	^self context form add: aWebElement! !

!WebApplication methodsFor: 'private-contexts'!
addContext: aContext
	self contexts at: aContext id put: aContext! !

!WebApplication methodsFor: 'private-composing'!
aidaIsRespondingStreamed
	^self context page aidaIsRespondingStreamed! !

!WebApplication methodsFor: 'private-obsolete'!
ajaxUpdate: anOldElement from: anElementToRecreate on: aRequest
	"prepare to update (recreate or refresh) that element by returning a recreated one"
	| new different |
	anOldElement isNil ifTrue:  [^WebElement new]. "only arguments/command was sent. Process it before!! "
	anElementToRecreate isNil ifTrue: [^WebElement new]. "can happen after window/context closing"
	anElementToRecreate creationMethod isNil ifTrue: [^anOldElement]. "in form elements it will return new value!!"
	aRequest context afterCloseUpdate:  anElementToRecreate afterCloseUpdate "element to update, if any".
	different := (anOldElement == anElementToRecreate) not.  "content will be from element different that old one"
	different not ifTrue:     "only when content will be from the old element. "
		[aRequest context announceReplacementWith: anOldElement]. "for reset see WebElement class>>new"
	new := anOldElement isWebWidget
		ifTrue: [self ajaxUpdateWidget: anOldElement from: anElementToRecreate on: aRequest]
		ifFalse: [(anElementToRecreate creationObject notNil 
				and: [anElementToRecreate creationObject isWebWidget]) 
			ifTrue: [self ajaxUpdateWidgetElement: anOldElement from: anElementToRecreate on: aRequest] 
			ifFalse: [self ajaxUpdateAppElement: anOldElement from: anElementToRecreate on: aRequest] ].
	aRequest context cancelReplacement. "if any"
	^new! !

!WebApplication methodsFor: 'private-obsolete'!
ajaxUpdateAppElement: anOldElement from: anElementToRecreate on: aRequest
	"prepare to update (recreate or refresh) some element in current App by returning a recreated one"
	| argument new |
	argument := aRequest postDataStringAt: 'parm'.   "element creation method with an argument (parm) "
	('view*' match: anElementToRecreate creationMethod asString) ifTrue: 
		[^self error: 'Cannot Ajax update views!! View in question: #', anElementToRecreate method].
	new := (self class canUnderstand: anElementToRecreate creationMethod) 
		ifTrue: [(anElementToRecreate creationMethod asString last = $: )
			ifTrue: [self perform: anElementToRecreate creationMethod with: argument ] "object method: parm"
			ifFalse: [argument notNil  "try to call the method with that argument"
				ifTrue: [self perform: (anElementToRecreate creationMethod, ':') asSymbol with: argument]
				ifFalse: [self perform: anElementToRecreate creationMethod] ] ]
		ifFalse: [self error: 'App does not  understand this update method!!' " WebElement new method: nil"].
	^new! !

!WebApplication methodsFor: 'private-obsolete'!
ajaxUpdateWidget: anOldElement from: anElementToRecreate "widget" on: aRequest
	"prepare to update (recreate or refresh) that widget by returning a recreated one"
	| argument creationObject superform new |
	argument := aRequest postDataStringAt: 'parm'.   "element creation method with an argument (parm) "
	creationObject := anElementToRecreate creationObject.
	superform := anElementToRecreate form superform.
	superform removeSubform: anElementToRecreate form.
	aRequest context cancelReplacement. "widget is rebuilt, not replaced with new instance!!"
	new := (creationObject class canUnderstand: anElementToRecreate creationMethod) 
		ifTrue: [(anElementToRecreate creationMethod asString last = $: )
			ifTrue: [creationObject perform: anElementToRecreate creationMethod with: argument ] 
			ifFalse: [argument notNil  "try to call the method with that argument"
				ifTrue: [creationObject perform: (anElementToRecreate creationMethod, ':') asSymbol with: argument]
				ifFalse: [creationObject perform: anElementToRecreate creationMethod] ] ]
		ifFalse: [self error: 'App does not  understand this update method!!' " WebElement new method: nil"].
	superform addSubform: new form.
	^new! !

!WebApplication methodsFor: 'private-obsolete'!
ajaxUpdateWidgetElement: anOldElement from: anElementToRecreate "widget" on: aRequest
	"prepare to update (recreate or refresh) some element in that widget by returning a recreated one"
	| argument creationObject new |
	argument := aRequest postDataStringAt: 'parm'.   "element creation method with an argument (parm) "
	creationObject := anElementToRecreate creationObject.
	new := (creationObject class canUnderstand: anElementToRecreate creationMethod) 
		ifTrue: [(anElementToRecreate creationMethod asString last = $: )
			ifTrue: [creationObject perform: anElementToRecreate creationMethod with: argument ] 
			ifFalse: [argument notNil  "try to call the method with that argument"
				ifTrue: [creationObject perform: (anElementToRecreate creationMethod, ':') asSymbol with: argument]
				ifFalse: [creationObject perform: anElementToRecreate creationMethod] ] ]
		ifFalse: [self error: 'Widget does not  understand this update method!!' " WebElement new method: nil"].
	^new! !

!WebApplication methodsFor: 'private' stamp: 'jm 8/25/2009 20:53'!
announceAction: anActionSymbol onView: aSymbol
	"Squeak specific"
	"When Squeak will have Announcements by default ..."
"	self announce: 
		(AppActionTrigered for: self observee on: self session view: aSymbol action: anActionSymbol)
"! !

!WebApplication methodsFor: 'private' stamp: 'jm 8/25/2009 20:52'!
announceView: aSymbol
	"Squeak specific"
	"When Squeak will have Announcements by default ..."
"	self  announce: 
		(AppViewShowed for: self observee on: self session view: aSymbol)
"! !

!WebApplication methodsFor: 'accessing'!
app
	^self! !

!WebApplication methodsFor: 'private-obsolete'!
ask: aWebElement
	"ask for something, like delete confirmation dialog. Stop execution here until the result is returned. Return 
	that result. See WebDemoApp control flow for examples"
	self show: aWebElement.
	^self context answer! !

!WebApplication methodsFor: 'private-form posting'!
callActionFrom: aRequest
	"Calls an action method if any"
	| form |
	form := aRequest context form.
	aRequest isAjaxPostWithSingleInput ifFalse:     "ajax posts of single form elements doesn't trigger actions!!"
		[self callActionMethodForButton: (form buttonFrom: aRequest) on: aRequest context].
	(aRequest session shouldRedirect not and: [aRequest isAjaxRequest not]) ifTrue:
		[self redirectToView: aRequest view]   " after post always redirect to avoid aidaCtx in Urls!! "! !

!WebApplication methodsFor: 'private-form posting'!
callActionMethodForButton: aButton on: aContext
	"name of button pressed is in argument"
	| methd |
	methd := self class actionMethodForView: aContext view button: aButton. 
	methd notNil 
		ifTrue: [self perform: methd asSymbol]
		ifFalse: [self reportMissingActionMethodIfNeeded].
	self announceAction: aButton action onView: aContext view! !

!WebApplication methodsFor: 'private-window delegation'!
cell
	"delegate to the form of currently executing context"
	^self context form cell! !

!WebApplication methodsFor: 'private-versions' stamp: 'janko 7/18/2008 22:22'!
changeObserveeToVersionFor: aRequest
	| object |
	object := self observee versionWithNumber: (self versionFromRequest: aRequest).
	object notNil ifTrue: [self observee: object]! !

!WebApplication methodsFor: 'private-multilingual' stamp: 'janko 11/12/2008 20:08'!
checkObserveeLanguageFor: aRequest
	"change observee to point to domain object in right language if necessary 
	(from session language or explicit language request in query part of Url)"
	| language new |
	(self isLanguageRequest: aRequest) "language= in query part of url"
		ifTrue: [self session language: (aRequest queryAt: 'language') asSymbol].
	language := self session language.
	new := self observee forLanguage: language.
	new notNil ifTrue: [self observee: new]! !

!WebApplication methodsFor: 'private-versions' stamp: 'janko 7/18/2008 22:25'!
checkObserveeVersionFor: aRequest
	"change observee to point to correct version if necessary"
	(self isVersionRequest: aRequest) ifTrue: [^self changeObserveeToVersionFor: aRequest].
	self observee isCurrentVersion ifFalse: [self observee: self observee currentVersion].! !

!WebApplication methodsFor: 'private-window delegation'!
clear
	"delegate to the form of currently executing context"
	super clear. "overall app stuff"
	^self context form clear "view specific stuff"! !

!WebApplication methodsFor: 'clipboard' stamp: ' 21/4/07 22:07'!
clipboard
	^self session clipboard! !

!WebApplication methodsFor: 'private-composing'!
composeWebPageFor: aRequest 
	| ctx |
	ctx := self findCreateOrSerializeContextFor: aRequest. "for posts and ajax just find, never create. 
														Req's context is also set"
	ctx  isNil ifTrue: 
		[^WebPage new addText: 'request for unknown or nonexistent context!!'; yourself].
	(aRequest isPost and: [aRequest isAjaxRequest not]) "be sure to call that before any post data is accessed!! "
		ifTrue: [ctx form registerStreamedFieldsInto: aRequest]. 
	(aRequest isPost and: [self site contextProcesses])
		ifTrue: [ctx startProcess]. "if not already. Always for posts and Ajax"
	ctx isExecutingInOwnProcess 
		ifTrue: 
			[ctx executeRequest: aRequest. "in ctx's process, will actually call our #printWebPageStepTwoFor:"
			ctx first mainSemaphore wait. "until context's process signal end of executing"
			ctx first initMainSemaphore.
			aRequest context isFirst ifTrue: [ctx stopProcess].
			^aRequest context result] "resulted page of context execution"
		ifFalse: [^self composeWebPageStepTwoFor: aRequest].! !

!WebApplication methodsFor: 'private-composing'!
composeWebPageStepTwoFor: aRequest 
	| toLogin |
	self observee isMultilingual 
		ifTrue: [self checkObserveeLanguageFor: aRequest ].  "and change observee if needed"
	self isObserveeVersioned 
		ifTrue: [self checkObserveeVersionFor: aRequest ]. "and change observee if needed"
	toLogin := false. "self isEncryptionSatisfied ifTrue: [toLogin := true]."
	(aRequest  isPost and: [aRequest  isAjaxRequest not]) ifTrue: 
		[(self updateAllowed: aRequest context view) 
			ifTrue: [self acceptInputsAndActionFrom: aRequest] ifFalse: [toLogin := true] ].
	toLogin ifTrue:
		[(self observee == self site admin and: [self session newView = 'login']) 
			ifFalse: [self redirectTo: self site admin view: #login].
		^WebPage new].
	self session lastApp: self. "!!!!!!"
 	aRequest isAjaxRequest ifTrue: [^self respondToAjaxRequest: aRequest].
	self session shouldRedirect ifTrue: [^WebPage new].
	self setProcessFromTaskId. "for BPM engine, if present"
	^self composeWebView: aRequest context view for: aRequest.! !

!WebApplication methodsFor: 'private-composing'!
composeWebView: aViewSymbol for: aRequest
 	"build a web page for that view"
	| method page form |
	aRequest context page clear; clearAttributesExceptId; setRandomId;
		initPageHeaderLinks; initPageScripts; checkBrowserSupport.
	aRequest context form initFields.
	method := self class viewMethodForView: aViewSymbol. 
	method isNil ifTrue: [^WebElement new addTextH3: 'ERROR: view named ', aViewSymbol printString, ' does not exist'; yourself].
	^(self viewAllowed: aViewSymbol)
		ifTrue: [page := self perform: method. "like #viewMain etc. "
			page isWebApplication ifTrue: 
				[form := aRequest context form.
				self session inTranslationMode ifTrue: [form prepareForTranslation]. "in-line edit"
				aRequest context window registerFormElements]. "must be after above transl.preparation!!"
			self storeThisUrl.
			self announceView: aViewSymbol.
			self activateView: aViewSymbol. "page is now shown/active on user browser"
			page]
		ifFalse: [self redirectTo: self site admin view: #login.
			WebPage new].! !

!WebApplication methodsFor: 'accessing' stamp: 'jm 11/18/2010 14:46'!
context
	"a context of currently executing web request"
	"use sparingly, slow!! "
	| ctx |
	ctx := self firstContextFromStack.
	^ctx notNil 
		ifTrue: [ctx]
		ifFalse: [self contexts values    "for tests to work, otherwise this is invalid!! "
			detect: [:each | each isFirst and: [each view = #main] ] 
			ifNone: [nil]]! !

!WebApplication methodsFor: 'private-contexts'!
contextForView: aSymbol
	^self contexts values 
		detect: [:ctx | ctx isFirst and: [ctx view = aSymbol] ] 
		ifNone: [nil]! !

!WebApplication methodsFor: 'private-contexts'!
contexts
	"a dictionary of context by context id (a unique number)"
	contexts isNil ifTrue: [self initContexts].
	^contexts! !

!WebApplication methodsFor: 'clipboard' stamp: ' 21/4/07 22:07'!
copyToClipboard
	"copy an url and title of current view of observee object to web clipboard"
	| object |
	object := self observee isVersionedObject
		ifTrue: [self observee currentVersion] "so that link will be aways same regardles of version!!"
		ifFalse: [self observee].
	title := (object class canUnderstand: #id) ifTrue: [object id, ' '] ifFalse: [''].
	title := (object class canUnderstand: #title) ifTrue: [title, object title] ifFalse: [nil].
	title isNil ifTrue: 
		[title := (object class canUnderstand: #indexTitle) ifTrue: [object indexTitle] ].
	title isNil ifTrue: [title := self title].
	self clipboard 
		title: title;
		url: (self site urlResolver halfUrlFor: object);
		object: object! !

!WebApplication methodsFor: 'private-views'!
deactivateView: aSymbol
	self activeViews remove: aSymbol ifAbsent: [].
	self session realtimeHandler cleanup "to remove realtime connections on just closed page"! !

!WebApplication methodsFor: 'accessing'!
defaultView
	" #main "
	^self class defaultView! !

!WebApplication methodsFor: 'private-contexts'!
ensureContextForView: aViewSymbol for: aRequest
	aRequest context isNil ifTrue:
		[aRequest context: (self contextForView: aViewSymbol). "try to find it first among existing for that view"
		aRequest context isNil ifTrue: [| ctx |
			ctx := (WebContextFirst newOn: self) view: aViewSymbol.
			aRequest context: ctx.
			self addContext: ctx] ]! !

!WebApplication methodsFor: 'error reporting' stamp: 'janko 9/30/2011 11:38'!
errorReport
	"element with report of errors, if any"
	| e |
	e := WebElement newId: #error.  "see WebStyle css42ErrorReport for style definition!! "
	self showError notNil ifTrue: 
		[(e addText: self showError) style: '{color: red}'].
	self showError: nil.
	^e! !

!WebApplication methodsFor: 'private-contexts'!
findContextFor: aRequest
	"POSTs and Ajax requests must always have context ids!!. Also set the current context"
	| id |
	id := aRequest contextId.
	(id isNil or: [(self contexts includesKey: id) not]) ifTrue: [^nil].
	^self contexts at: id! !

!WebApplication methodsFor: 'private-contexts'!
findContextSameViewFor: aRequest
	"if a context for the requested view already exist, use it"
	| requestedView |
	requestedView := aRequest view. 
	requestedView isNil ifTrue: [requestedView := #main].
	^self contextForView: requestedView! !

!WebApplication methodsFor: 'private-contexts'!
findCreateOrSerializeContextFor: aRequest
	"and set the current context and view"
	"for posts and ajax request the context id must always be present in request!!"
	"Serialize execution if some other request is already executing"
	| ctx |
	ctx := self findContextFor: aRequest.
	(ctx isNil and: [aRequest isPost or: [aRequest isAjaxRequest]]) ifTrue: [^nil]. "this should not happen!!"
	ctx isNil ifTrue: [ctx := self findContextSameViewFor: aRequest]. "temporary"
	ctx isNil ifTrue: 
		[ctx := (WebContextFirst newOn: self) view: aRequest view.
		self addContext: ctx].
	ctx isBusy ifTrue: [ctx serialize: aRequest].  "context is busy, serialize execution"
	ctx event: aRequest.
	aRequest context: ctx.
	^ctx! !

!WebApplication methodsFor: 'private-form posting'!
formPostedFrom: aRequest
	"get a form from which input is posted by this request"
	| elementToUpdate |
	aRequest isAjaxRequest ifFalse: [^aRequest context form].
	aRequest isAjaxPostWithSingleInput ifTrue: 
		[^(aRequest context form fieldNamed: aRequest ajaxSingleInputName) form].
	elementToUpdate := aRequest context elementId: aRequest ajaxElementId.
	elementToUpdate isNil ifTrue: [^aRequest context form]. "always?"
	elementToUpdate isStubElement ifTrue: [^aRequest context form]. 
	^elementToUpdate creationObject isWebWidget
			ifTrue: [elementToUpdate creationObject form]
			ifFalse: [aRequest context form]. "form of currently shown window/page"! !

!WebApplication methodsFor: 'private-composing'!
helpLink
	"link to help page for current view and App. If not exist, then nothing, exept for 
	admin - link to creation of new help page"
	| link viewName |
	self class == WebHelpPageApp ifTrue: [^WebElement new].
	viewName := self inDefaultView ifTrue: ['main'] ifFalse: [self view asString].
	link := WebLink newClass: #helpLink.
	(self site help existApp: self view: viewName)
		ifTrue: [link text: ('<b>', self style helpText, '</b>') 
			linkTo: (self site help forApp: self view: viewName)]
		ifFalse: [self user hasAdminRights
			ifTrue: [link text: '<b>', self style addHelpText, '</b>' linkTo: self site help; view: 'newPage'; 
				parameter: 'app' value: self class name asString;
				parameter: 'hview' value: viewName]
			ifFalse: [^WebElement new] ].
	^link! !

!WebApplication methodsFor: 'accessing'!
inDefaultView
	"#main or not defined"
	^(self view = self defaultView) | (self view = #'')! !

!WebApplication methodsFor: 'accessing-modes' stamp: ' 21/4/07 22:07'!
inEditMode
	^self mode = #edit! !

!WebApplication methodsFor: 'error reporting'!
inError
	^self showError notNil and: [self showError notEmpty]! !

!WebApplication methodsFor: 'accessing-modes' stamp: ' 21/4/07 22:07'!
inViewMode
	^self mode = #view! !

!WebApplication methodsFor: 'private-obsolete' stamp: ' 21/4/07 22:07'!
indexObservee
	"index or reindex observee of that app"
	^self site index indexObject: self observee! !

!WebApplication methodsFor: 'initialize-release'!
initActiveViews
	^self otherAt: #activeViews put: Set new! !

!WebApplication methodsFor: 'private-security'!
initAdminAccess
	"admin group has rights to all views and updates in all Apps!! "
	self site securityManager initAdminAccess.! !

!WebApplication methodsFor: 'initialize-release'!
initContexts
	contexts := Dictionary new.! !

!WebApplication methodsFor: 'initialize-release'!
initOther
	other := Dictionary new.! !

!WebApplication methodsFor: 'initialize-release'!
initialize
	"override in subclasses if needed"! !

!WebApplication methodsFor: 'testing'!
isActive
	"not yet cleaned up"
	^self session notNil! !

!WebApplication methodsFor: 'private-views'!
isActiveView: aSymbol
	^self activeViews includes: aSymbol! !

!WebApplication methodsFor: 'private-bpm' stamp: ' 21/4/07 22:07'!
isControledByBPMProcess
	"by a BPM process instance, which control a workflow of this app too"
	^self process notNil! !

!WebApplication methodsFor: 'private-security'!
isEncryptionSatisfied
	^(self mustBeEncrypted: self session newView) and: [self session lastRequest isEncrypted not]! !

!WebApplication methodsFor: 'private-multilingual' stamp: 'janko 7/18/2008 22:26'!
isLanguageRequest: aRequest
	^(aRequest queryAt: 'language') notNil! !

!WebApplication methodsFor: 'private-versions' stamp: ' 21/4/07 22:07'!
isObserveeVersioned
	^self observee isVersionedObject! !

!WebApplication methodsFor: 'testing'!
isStandaloneApp
	"it is not a representation of some domain object in MVC fashion"
	^self otherAt: #StandaloneApp ifAbsent: [false]! !

!WebApplication methodsFor: 'private-versions' stamp: 'janko 7/18/2008 22:26'!
isVersionRequest: aRequest
	^(self versionFromRequest: aRequest) notNil! !

!WebApplication methodsFor: 'testing'!
isWebApplication
	^true! !

!WebApplication methodsFor: 'testing'!
isWebWidget
	^false! !

!WebApplication methodsFor: 'accessing-modes' stamp: ' 21/4/07 22:07'!
mode
	| mode |
	mode := self otherAt: #Mode.
	^mode isNil 
		ifTrue: [self setViewMode. self mode] 
		ifFalse: [mode]! !

!WebApplication methodsFor: 'private' stamp: ' 21/4/07 22:07'!
mode: aSymbol
	"portlet modes #view #edit "
	self otherAt: #Mode put: aSymbol! !

!WebApplication methodsFor: 'private-security'!
mustBeEncrypted: aViewSymbol
	"check  if this view must be sent encrypted"
	| right |
"	(self observee = self site admin) & (aViewSymbol = #login) ifTrue: [^true]." "!!!!!!"
	 right := self site securityManager 
		isUser: self user
		allowedTo: (self class encryptSymbolFor: aViewSymbol)
		on: self class name.
	^right! !

!WebApplication methodsFor: 'private-window delegation'!
newCell
	"delegate to the form of currently executing context"
	^self context form newCell! !

!WebApplication methodsFor: 'private-window delegation'!
newRow
	"delegate to the form of currently executing context"
	^self context form newRow! !

!WebApplication methodsFor: 'private-window delegation'!
newTable
	"delegate to the form of currently executing context"
	^self context form newTable! !

!WebApplication methodsFor: 'redirection' stamp: ' 21/4/07 22:07'!
newView: aSymbol
	"in action methods, to direct to a specified view after button pressed"
	self session newView: aSymbol! !

!WebApplication methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
observee
	"return reference to an object, for which this app acts as an observer - to make an user interface
	of them"
	^observee! !

!WebApplication methodsFor: 'private' stamp: ' 21/4/07 22:07'!
observee: anObject
	"set the reference to an object, for which this app acts as an observer - to make an user interface
	of them"
	observee := anObject! !

!WebApplication methodsFor: 'private-other'!
other
	^other! !

!WebApplication methodsFor: 'private-other'!
otherAt: aSymbol
	^self otherAt: aSymbol ifAbsent: [nil]! !

!WebApplication methodsFor: 'private-other'!
otherAt: aSymbol ifAbsent: aBlock
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!WebApplication methodsFor: 'private-other'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!WebApplication methodsFor: 'private-other'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!WebApplication methodsFor: 'accessing'!
page
	"a webpage on which currently built view is shown"
	^self context page! !

!WebApplication methodsFor: 'private'!
pageContentWidth
	"obsolete, rather use direct: self  style... !! "
	^self style pageContentWidth! !

!WebApplication methodsFor: 'clipboard' stamp: ' 21/4/07 22:07'!
pasteFromClipboard
	"get a DocLink with title and url. Nil if clipboard empty"
	self clipboard isEmpty ifTrue: [^nil].
	^self clipboard asDocLink! !

!WebApplication methodsFor: 'accessing-other' stamp: ' 21/4/07 22:07'!
process
	"a BPM.Process instance, on which this app is activated by some task"
	^self otherAt: #Process! !

!WebApplication methodsFor: 'accessing-other' stamp: ' 21/4/07 22:07'!
process: aBPMProcess
	self other at: #Process put: aBPMProcess! !

!WebApplication methodsFor: 'redirection'!
redirectTo: anObjectOrUrlString
	"redirect browser to a default view for specified object or url link"
	anObjectOrUrlString isNil ifTrue: [^self error: 'redirection target is nil!!'].
	self session redirectLink: (WebLink text:'' linkTo: anObjectOrUrlString).! !

!WebApplication methodsFor: 'redirection' stamp: 'jm 6/27/2009 20:43'!
redirectTo: anObjectOrUrlString view: aSymbol
	"redirect browser to a specified view for specified object or url link"
	anObjectOrUrlString isNil ifTrue: [^self error: 'redirection target is nil!!'].
	self session redirectLink: (WebLink text:'' linkTo: anObjectOrUrlString view: aSymbol).! !

!WebApplication methodsFor: 'redirection' stamp: 'jm 6/27/2009 20:43'!
redirectTo: anObjectOrUrlString view: aSymbol parameter: aParmString value: aValueString
	"redirect browser to a specified view for specified object or url link"
	anObjectOrUrlString isNil ifTrue: [^self error: 'redirection target is nil!!'].
	self session redirectLink: ((WebLink text:'' linkTo: anObjectOrUrlString view: aSymbol)
		 parameter: aParmString value: aValueString).! !

!WebApplication methodsFor: 'redirection'!
redirectToView: aSymbol
	"redirect browser to a different view for same observee"
	| target |
	target := self observee notNil 
		ifTrue: [self observee] 
		ifFalse: [self class].  "standalone App without link to domain model. Class!! "
	self session redirectLink: (WebLink text:'' linkTo: target view: aSymbol).! !

!WebApplication methodsFor: 'private-contexts'!
removeContext: aContext
	self contexts removeKey: aContext id ifAbsent: []! !

!WebApplication methodsFor: 'private'!
removeYourself
	"called during session application state cleanup"
	self session isNil ifTrue: [^nil].
	self observee notNil ifTrue:
		[self session removeApp: self for: self observee type: #web].
	self session: nil.
	self observee: nil.! !

!WebApplication methodsFor: 'private-form posting'!
reportMissingActionMethodIfNeeded
	self error: 'Action method missing or with wrong name. Name must be composed as ''action''+viewname+action(optional), like #actionMainSave, if you put button with action: #save in viewMain'! !

!WebApplication methodsFor: 'private-obsolete'!
respondToAjaxAutocomplete: aRequest
	|  form fieldName fieldValue field choices e |
	form := self formPostedFrom: aRequest.
	fieldName := aRequest ajaxSingleInputName.
	fieldValue := (aRequest "context request" postDataAt: fieldName) value.
	fieldValue := AIDASite convert: fieldValue fromCodepage: #utf8.
	field := form fields at: fieldName. 
	choices := field getChoicesForEntry: fieldValue.
	e := WebList newUnordered.
	choices do: [:each || string |
		string := each convertToSloveneChars.
		e add: (WebRawText text: (AIDASite convert: string toCodepage: #utf8))].
	^e! !

!WebApplication methodsFor: 'private-obsolete'!
respondToAjaxCloseWindow: aRequest
	"OBSOLETE"
	| ctx |
	ctx := aRequest context.
	ctx result: WebElement basicNew.
	ctx parent result: ctx result. "just in case"
	ctx first mainSemaphore signal. " to ensure continuing main thread"
	ctx parent isFirst ifTrue: [ctx parent stopProcess].  "we don't need it anymore"
	ctx close. "finaly the time to safely close our context"! !

!WebApplication methodsFor: 'private-obsolete'!
respondToAjaxInPlaceEditing: aRequest
	"field is immediatelly posted/saved!! "
	| fieldValue field response |
	field := aRequest context elementId: aRequest ajaxElementId.
	field isFormated & aRequest isAjaxWikiFormatedRequest not  ifFalse:
		[fieldValue := (aRequest postDataAt: 'value') value.
		fieldValue := AIDASite convert: fieldValue fromCodepage: #utf8.
		field value: fieldValue.
		field save].
	response := field value.
	aRequest isAjaxWikiFormatedRequest ifTrue: [response := response asWikiHtml].
	response := AIDASite convert: response toCodepage: #utf8.
	^WebElement new add: (WebRawText text: response); yourself! !

!WebApplication methodsFor: 'private-obsolete'!
respondToAjaxRequest: aRequest
	| oldElement elementToRecreate e result ctx |
	oldElement := aRequest context elementId: aRequest ajaxElementId. "should be here, its context stil alive"
	elementToRecreate := aRequest context elementId: aRequest ajaxElementToRecreateId.
	aRequest isAjaxInPlaceEditingRequest ifTrue: [^self respondToAjaxInPlaceEditing: aRequest].
	aRequest isAjaxAutocompleteRequest ifTrue: [^self respondToAjaxAutocomplete: aRequest].
	aRequest isAjaxPostWithInput ifTrue: [self acceptInputsAndActionFrom: aRequest].
	aRequest isAjaxCloseWindowRequest ifTrue: [self respondToAjaxCloseWindow: aRequest]. "then continue here!!"
	aRequest isAjaxPopupWindowRequest 
		ifTrue: 
			[ctx := aRequest context createNewContext. "is also added to context chain and also to this app"
			ctx event: aRequest.
			aRequest context: ctx. "switch to a new context during th rest of execution"
			e := self ajaxUpdate: oldElement from: elementToRecreate on: aRequest. 
			e := self wrap: e intoPopupWindow: ctx window] "e is now window with wrapped element"
		ifFalse: 
			[e := self ajaxUpdate: oldElement from: elementToRecreate on: aRequest]. 
	e registerFormElements.
	e prepareToHtmlStreamingOn: self session. "to prepare again"
	result := e copy.
	result nilAttributes. "to be just plain element, no div,  to send inner html of original element only"
	aRequest context result: result.
	^result! !

!WebApplication methodsFor: 'private-ajax'!
respondToEvent: aWebEvent
	"this method is here just to have an App in the stack, because 'climbing of the stack' methods"
	| ctx e |
	aWebEvent element isWindowPopupRequested
		ifTrue: 
			[ctx := aWebEvent context createNewContext. "is also added to context chain and also to this app"
			aWebEvent context: ctx. "switch to a new context during the rest of execution"
			ctx event: aWebEvent.
			e := aWebEvent element handleEvent: aWebEvent. 
			e creationContext: ctx.  "change the default to the popup one"
			e := self wrap: e intoPopupWindow: ctx window. "e is now window with wrapped element"
			self session queueUpdateElement: e]
		ifFalse: 
			[aWebEvent element handleEvent: aWebEvent]! !

!WebApplication methodsFor: 'private-window delegation'!
row
	"delegate to the form of currently executing context"
	^self context form row! !

!WebApplication methodsFor: 'accessing-other' stamp: ' 21/4/07 22:07'!
search
	^self otherAt: #Search! !

!WebApplication methodsFor: 'accessing-other' stamp: ' 21/4/07 22:07'!
search: aString
	"search input field"
	self otherAt: #Search put: aString! !

!WebApplication methodsFor: 'accessing'!
session
	"on which this App represent the observed domain object"
	^session! !

!WebApplication methodsFor: 'private'!
session: aWebSession
	"on which this App represent the observed domain object"
	session := aWebSession! !

!WebApplication methodsFor: 'accessing-modes' stamp: ' 21/4/07 22:07'!
setEditMode
	self mode: #edit! !

!WebApplication methodsFor: 'private-bpm' stamp: ' 21/4/07 22:07'!
setProcessFromTaskId
	"set a reference to a BPM process instance, which control a workflow of this app too"
	| uuid workitem |
	uuid := self session lastRequest queryAt: 'taskId' ifAbsent: [^nil].
	workitem := self site repository bpm worklist itemWithTaskUuid: uuid for: self user.
	workitem isNil ifTrue: [^nil].
	self process: workitem task process.
	workitem subscribeToApp: self.! !

!WebApplication methodsFor: 'private'!
setStandaloneApp
	"it is not a representation of some domain object in MVC fashion"
	self otherAt: #StandaloneApp put: true! !

!WebApplication methodsFor: 'accessing-modes' stamp: ' 21/4/07 22:07'!
setViewMode
	self mode: #view! !

!WebApplication methodsFor: 'private-obsolete'!
show: aWebElement
	"show something like info dialog. Stop execution here until the dialog is closed. 
	See WebDemoApp control flow for examples"
	| ourCtx popupCtx |
	ourCtx := self context.
	popupCtx := ourCtx request context createNewContext. "is also added to context chain and also to this app"
	popupCtx request: ourCtx request.
	ourCtx request context: popupCtx. "switch to a new context during the rest of execution"
	popupCtx result:
		(self wrap: aWebElement intoPopupWindow: popupCtx window). "e is now window with wrapped element"
	popupCtx result changeContextFrom: ourCtx to: popupCtx. "scan for all references to contexts and change them"
	aWebElement registerFormElementsTo: popupCtx form.  "probably already, but just to be sure"
	ourCtx first mainSemaphore signal. "to return that popup"
	ourCtx wait.
	"now the execution of our process is interrupted until the popup window and therefore its context is closed"! !

!WebApplication methodsFor: 'error reporting'!
showError
	^self otherAt: #Error! !

!WebApplication methodsFor: 'error reporting'!
showError: aString
	"error message to be written on web page. "
	self otherAt: #Error put: aString! !

!WebApplication methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
site
	"reference to a site on which this app shows some object. "
	^self session site! !

!WebApplication methodsFor: 'private-composing'!
storeThisUrl
	"to a User. It is helpull for return after logon, for instance"
	self user lastAppUrl: self session lastRequest uriString! !

!WebApplication methodsFor: 'private-composing'!
streamHtmlTo: aStream for: aRequest on: aSession
	"For apps we print a window of currently executing context"
	^aRequest context page streamHtmlTo: aStream for: aRequest on: aSession.! !

!WebApplication methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
style
	^self site style! !

!WebApplication methodsFor: 'private-window delegation'!
table
	"delegate to the form of currently executing context"
	^self context form table! !

!WebApplication methodsFor: 'private-window delegation'!
title
	"delegate to the window of currently executing context"
	^self context page title! !

!WebApplication methodsFor: 'private-window delegation'!
title: aStringOrMultilangAssociation
	"delegate to the window of currently executing context"
	^self context page title: aStringOrMultilangAssociation! !

!WebApplication methodsFor: 'private-security'!
updateAllowed: aViewSymbol
	"check if update is allowed to this observee object with specified view"
	"update for admin login page is always allowed"
	"reregister rights for admin if denial is encountered "
	| right |
	(self observee = self site admin) & (aViewSymbol = #login) ifTrue: [^true].
	 right := self site securityManager 
		isUser: self user allowedTo: (self class updateRightSymbolFor:aViewSymbol)
		on: self class name.
	(right not and: [self session adminAllowed]) ifTrue: 
		[self initAdminAccess. 
		^self updateAllowed: aViewSymbol].
	^right! !

!WebApplication methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
user
	"reference to a user of current session "
	^self session user! !

!WebApplication methodsFor: 'private-versions' stamp: 'np 10/20/2008 16:39'!
versionFromRequest: aRequest
	"for Ajax requests too!!"
	| version |
	version := aRequest queryAt: 'version'.
	version isNil ifTrue:
		[aRequest isAjaxRequest ifFalse: [^nil].
		version := aRequest isPost
			ifTrue: [(aRequest postDataAt: 'version') value]
			ifFalse: [aRequest queryAt: 'version'] ].
	^version! !

!WebApplication methodsFor: 'accessing'!
view
	"view of currently executing web context"
	"use sparingly, slow!! "
	^self context view! !

!WebApplication methodsFor: 'private-security'!
viewAllowed: aViewSymbol
	"check if page view is allowed to this observee object with specified view"
	"admin logon page always allowed"
	"reregister rights for admin if denial is encountered "
	| right |
	(self observee = self site admin) & (aViewSymbol = #login) ifTrue: [^true].
	 right := self site securityManager 
		isUser: self user allowedTo: (self class viewRightSymbolFor: aViewSymbol)
		on: self class name.
	(right not and: [self session adminAllowed]) ifTrue: 
		[self initAdminAccess. ^true].
	^right! !

!WebApplication methodsFor: 'private-obsolete'!
visitsCount
	"returns number of visits of this page"
     ^(self site urlResolver counterFor: self observee)
		total! !

!WebApplication methodsFor: 'accessing'!
window
	"window in of currently executing web context"
	"use sparingly, slow!! "
	^self context window! !

!WebApplication methodsFor: 'private-ajax'!
wrap: anElement intoPopupWindow: aWebWindow
	"put the element into a WebWindow and prepare it for popup"
	| ctx o l |
	ctx := aWebWindow context.
	aWebWindow addText: '<style>', aWebWindow popupStyle, '</style>'.
	o := WebElement newId: 'overlay', ctx level printString.
	l := (WebElement newId: 'lightbox', ctx level printString) style: 'display: none;'.
	l add: anElement.
	aWebWindow add: o; add: l.
	aWebWindow scriptAfter: 'updateLightboxLevel(', ctx level printString,')'. "from WebStyle>>js30Lightbox"
	aWebWindow elementToReplace: ctx parent window popupStub.
	aWebWindow afterCloseUpdate: anElement afterCloseUpdate. "if any"
	^aWebWindow! !

!WebApplication class methodsFor: 'view, action methods'!
actionMethodForView: aViewSymbol
	"obsolete, only for WebSecurityManagerApp !!"
	| method viewSymbol |
	viewSymbol := aViewSymbol isEmpty 
		ifTrue: [self defaultView] ifFalse: [aViewSymbol asSymbol].
	method := self composedActionMethodNameForView: viewSymbol.
	(self canUnderstand: method) ifFalse: [^nil].
	^method! !

!WebApplication class methodsFor: 'view, action methods'!
actionMethodForView: aViewSymbol button: aButton
	"if no method for that button name, return nil"
	| method viewSymbol |
	viewSymbol := aViewSymbol asString isEmpty 
		ifTrue: [self defaultView] ifFalse: [aViewSymbol asSymbol].
	method := self composedActionMethodNameForView: viewSymbol action: aButton action.
	(self canUnderstand: method) ifTrue: [^method].
	'search' = aButton action ifTrue: [^#actionSearch].
	^nil
"
	method := self composedActionMethodNameForView: viewSymbol.
	(self canUnderstand: method) ifTrue: [^method].
	^nil
"! !

!WebApplication class methodsFor: 'private'!
allComposedViewMethods
	| methods |
	methods := self selectors asSet select: [:each | 'view*' match:each asString].
	methods := methods reject: [:each | 
		#(view viewAllowed: viewMethodForView: ) includes: each].
	^self superclass isWebApplication 
		ifTrue: [methods addAll: self superclass allComposedViewMethods; yourself]
		ifFalse: [methods]

"WebDemoApp new class allComposedViewMethods"! !

!WebApplication class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
allComposedViews
	"remove 'view' and lowercase start of remining part of method to get a view name from method"
	^self allComposedViewMethods collect: [:each | 
		((String with: (each at: 5) asLowercase), 
			(each copyReplaceFrom: 1 to: 5 with: String new)) asSymbol].

"WebDemoApp new class allComposedViews"! !

!WebApplication class methodsFor: 'accessing' stamp: 'JM 4/26/2007 17:06'!
allViews
	^self allComposedViews! !

!WebApplication class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allWebAppClasses
	"return an ordered collection with a WebApplication class all their subclasses ordered
	by levels of inheritance and by class name on the same level"
	| classes |
	classes := OrderedCollection new.
	self allWebAppClassesTo: classes.
	^classes

"WebApplication allWebAppClasses"! !

!WebApplication class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
allWebAppClassesTo: aCollection 
	"return an ordered collection with a WebApplication class all their subclasses ordered
	by levels of inheritance and by class name on the same level"
	| subcls |
	aCollection add: self.
	subcls := SortedCollection withAll: self subclasses
				sortBlock: [:a :b | a name < b name].
	subcls do: [:subclass | subclass allWebAppClassesTo: aCollection]! !

!WebApplication class methodsFor: 'security' stamp: ' 21/4/07 22:07'!
allowAllUpdatesFor: aWebUserOrGroup on: anAIDASite
	"set access rigths to allow all updates on that web app for specified user or group 
	on specified server"
	self allWebAppClasses do: [:appClass |
		appClass allViews do: [:appView |
			anAIDASite securityManager
				setAccessRights: (appClass updateRightSymbolFor: appView)
				for: aWebUserOrGroup
				on: appClass name] ].

"
WebSecurityManagerApp allowAllUpdatesFor: 
	(WebSecurityManager default adminUser)
		on: AIDASite default
"! !

!WebApplication class methodsFor: 'security' stamp: ' 21/4/07 22:07'!
allowAllViewsFor: aWebUserOrGroup on: anAIDASite
	"set access rigths to allow all views on all web apps for specified user or group on specified site"
	self allWebAppClasses do: [:appClass |
		appClass allViews do: [:appView |
			anAIDASite securityManager
				setAccessRights: (appClass viewRightSymbolFor: appView)
				for: aWebUserOrGroup
				on: appClass name] ].
"
WebApplication allowAllViewsFor: 
	(WebSecurityManager default adminUser)
	on: AIDASite default
"! !

!WebApplication class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
appClassLevel
	"return the level of inheritance of a class, relative to a WebApplication class"
	| level cls |
	level := 1.
	cls := self.
	[cls == WebApplication] whileFalse: 
			[level := level + 1.
			cls := cls superclass].
	^level! !

!WebApplication class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
capitalizeName: aString
	"make first char uppercase"
	aString isEmpty ifTrue: [^''].
	^(String with: aString first asUppercase), (aString copyFrom: 2 to: aString size)

"WebApplication capitalizeName: 'main' "! !

!WebApplication class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
composedActionMethodNameForView: aViewName
	^('action', (self capitalizeName: aViewName asString)) asSymbol

"WebApplication composedActionMethodNameForView: 'main'"! !

!WebApplication class methodsFor: 'private'!
composedActionMethodNameForView: aViewName action: aSymbol
	| mtname |
	mtname := (self composedActionMethodNameForView: aViewName) asString.
	aSymbol notNil ifTrue:
		[mtname := mtname, (self capitalizeName: aSymbol asString)].
	^mtname asSymbol

"WebApplication composedActionMethodNameForView: 'main' action: 'addFolder'"! !

!WebApplication class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
composedMethodNameForView: aViewName
	^('view', (self capitalizeName: aViewName asString)) asSymbol

"WebApplication new class composedMethodNameForView: 'main'"! !

!WebApplication class methodsFor: 'accessing'!
defaultView
	^#main! !

!WebApplication class methodsFor: 'security'!
encryptSymbolFor: aViewSymbol
	"if view does not exist, then use a default (first) view. Be sure to use a
	sublclass of WebApplication when calling that method to find the right default view"
	| view allViews|
	allViews := self allViews.
	allViews isEmpty ifTrue: [^nil].
	view := (allViews includes: aViewSymbol)
		ifTrue: [aViewSymbol]
		ifFalse: [self defaultView].
	view := (String with: view asString first asUppercase), 
		(view asString copyFrom: 2 to: view asString size).
	^('encrypt', view asString) asSymbol! !

!WebApplication class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
isWebApplication
	^true! !

!WebApplication class methodsFor: 'instance creation'!
newFor: anObject on: aSession
	"guess a class from anObject class name (class name + 'App') and create instance of it"
	| instance |
	instance := self newFromNameFor: anObject on: aSession.
	instance isNil ifTrue: [^nil].
	^instance session: aSession! !

!WebApplication class methodsFor: 'private' stamp: 'jm 8/21/2009 18:15'!
newFromNameFor: anObject on: aSession
	"Try to create of AnObjectApp instance if that class exist."
	"Squeak specific!!"
	| className class |
	className := (anObject class name asString, 'App') asSymbol.
	class := [Smalltalk at: className] on: Error do: [:ex | ^nil].  "Squeak specific!!"
	(class allSuperclasses includes: WebApplication) ifFalse: [^nil].
	^class basicNew 
		observee: anObject; 
		session: aSession; 
		initialize.
! !

!WebApplication class methodsFor: 'security'!
updateRightSymbolFor: aViewSymbol
	"return a right symbol, used for setting/testing rights to update a page with specified view.
	A symbol is composed as follows: '#upd',<aViewSymbol> for expample for view #brief
	result is #updbrief"
	"if view does not exist, then use a default (first) view. Be sure to use a
	sublclass of WebApplication when calling that method to find the right defult view"
	| view allViews|
	allViews := self allViews.
	allViews isEmpty ifTrue: [^nil].
	view := (allViews includes: aViewSymbol)
		ifTrue: [aViewSymbol]
		ifFalse: [self defaultView].
	view := (String with: view asString first asUppercase), 
		(view asString copyFrom: 2 to: view asString size).
	^('upd', view) asSymbol! !

!WebApplication class methodsFor: 'view, action methods'!
viewMethodForView: aViewSymbol
	| method viewSymbol |
	viewSymbol := aViewSymbol isEmpty 
		ifTrue: [self defaultView] ifFalse: [aViewSymbol].
	method := self composedMethodNameForView: viewSymbol.
	(self canUnderstand: method) ifFalse: [^nil].
	^method

"WebDemoApp new class viewMethodForView: #imageGallery"! !

!WebApplication class methodsFor: 'security'!
viewRightSymbolFor: aViewSymbol
	"return a right symbol, used for setting/testing rights to view a page with specified view.
	a symbol is composed as follows: '#view',<aViewSymbol> for expample for view #brief
	result is #viewbrief"
	"if view does not exist, then use a default (first) view. Be sure to use a
	sublclass of WebApplication when calling that method to find the right defult view"
	| view allViews|
	allViews := self allViews. allViews isEmpty ifTrue: [^nil].
	view := (allViews includes: aViewSymbol)
		ifTrue: [aViewSymbol]
		ifFalse: [self defaultView].
	view := (String with: view asString first asUppercase), 
		(view asString copyFrom: 2 to: view asString size).
	^('view', view) asSymbol! !

!WebApplicationTest methodsFor: 'running' stamp: ' 21/4/07 22:08'!
setRequest
	request := HTTPGet new.
	request parseURI: 'http://www.eranova.si/demo.html'.
	session lastRequest: request! !

!WebApplicationTest methodsFor: 'running' stamp: 'mivsek 8/22/2007 21:12'!
setUp
"TOO DANGEROUS!!!!!!
	server := Swazoo.SwazooServer singleton.
	server initialize.  ""to remove all stuff and stop it""
	site := AIDASite newNamed: 'test'.
	session := WebSession newOn: site sessionManager.
	app := site admin webAppFor: session.
	self setRequest.
"! !

!WebApplicationTest methodsFor: 'running' stamp: 'mivsek 8/22/2007 21:12'!
tearDown
"	site := server siteNamed: 'test'.
	site stop.
	server removeSite: site.
	server := nil. site := nil. session := nil. app := nil.
"! !

!WebApplicationTest methodsFor: 'testing-versions' stamp: 'mivsek 8/22/2007 21:13'!
testChangeObserveeVersion
"	| o1 |
	o1 := VersionedExample new. o1 asNewVersion.
	app := o1 webAppFor: session.
	self assert: app observee versionNumber = '1'.
	request uri queries: (request uri queries, '&version=2').
	app checkObserveeVersion.
	self assert: app observee versionNumber = '2'.
	self deny: app observee isCurrentVersion
"! !

!WebApplicationTest methodsFor: 'testing-versions' stamp: 'mivsek 8/22/2007 21:13'!
testChangeObserveeVersionBack
"	| o1 |
	o1 := VersionedExample new. o1 asNewVersion.  app := o1 webAppFor: session.
	request uri queries: (request uri queries, '&version=2').
	app checkObserveeVersion.
	self assert: app observee versionNumber = '2'.
	self setRequest. ""to be without version again""
	app checkObserveeVersion.
	self assert: app observee versionNumber = '1'.
	self assert: app observee isCurrentVersion
"! !

!WebApplicationTest methodsFor: 'testing-versions' stamp: 'mivsek 8/22/2007 21:13'!
testCurrentVersionChange
"	| o1 o2 |
	o1 := VersionedExample new. o2 := o1 asNewVersion.
	app := o1 webAppFor: session.
	self assert: app observee isCurrentVersion.
	self assert: app observee versionNumber = '1'.
	o2 setCurrentVersion.
	self assert: app observee isCurrentVersion. ""because of identity change!! ""
	self assert: app observee versionNumber = '2'.
"! !

!WebApplicationTest methodsFor: 'testing' stamp: ' 21/4/07 22:08'!
testSecurity! !

!WebApplicationTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 21:13'!
testSetUp
"	self assert: app notNil.
	self assert: app observee == site admin.
	self assert: app session == session.
	self assert: (session webAppFor: site admin) == app
"! !

!WebApplicationTest methodsFor: 'testing-versions' stamp: 'mivsek 8/22/2007 21:14'!
testVersionRequest
"	| o1 |
	o1 := VersionedExample new. 
	app := o1 webAppFor: session.
	self deny: app isVersionRequest.
	self assert: app versionFromRequest isNil.
	request uri queries: (request uri queries, '&version=2').
	self assert: app isVersionRequest.
	self assert: app versionFromRequest = '2'.
"! !

!WebApplicationTest methodsFor: 'testing-versions' stamp: 'mivsek 8/22/2007 21:14'!
testVersionedObject
"	| o1 o2 |
	o1 := VersionedExample new. o2 := o1 asNewVersion.
	app := o1 webAppFor: session.
	self assert: app observee isVersionedObject.
	self assert: app observee isCurrentVersion.
"! !

!WebAudio methodsFor: 'attributes'!
autoplay
	"audio will start playing as soon as it is ready"
	self attributes at: #autoplay put: true! !

!WebAudio methodsFor: 'attributes'!
controls: aString
	"Specifies that audio controls should be displayed (such as a play/pause button etc)."
	self attributes at: #controls put: aString! !

!WebAudio methodsFor: 'attributes'!
loop
	"audio will start over again, every time it is finished"
	self attributes at: #loop put: true! !

!WebAudio methodsFor: 'attributes'!
preload: aSymbol
	"Specifies if and how the author thinks the audio should be loaded when the page loads"
	" #auto #metadata or #none "
	self attributes at: #preload put: aSymbol asString! !

!WebAudio methodsFor: 'attributes'!
src: anUrlString
	"Specifies the URL of the video file"
	" #auto #metadata or #none "
	self attributes at: #src put: anUrlString! !

!WebAudio methodsFor: 'private'!
tag
	^#audio! !

!WebAudio methodsFor: 'attributes'!
text: aString
	"will be shown if browser does not support audio"
	self addText: aString! !

!WebAutocomplete2Field methodsFor: 'private'!
acceptInputFromValue: aValueString
	| vlue choices |
	vlue :=  AIDASite convertFromWeb: aValueString on: self session. "ensure unicode!!"
	vlue := (WebFormElement autoConvertString:  vlue toObject: self value).
	self choicesObject notNil & self choiceAspect notNil ifTrue: "save real object, not only text!! "
		[choices := self choicesObject perform: self choicesAspect.
		vlue := choices detect: [:each | (each perform: self choiceAspect) = vlue] ifNone: [nil] ].
	self value: vlue.! !

!WebAutocomplete2Field methodsFor: 'private-streaming'!
addSetupScript
	"jQuery specific"
self scriptAfter: '
$("#', self id, '").autocomplete({
	source : function (request, callback) {
		$.ajax ({
			url : "/aidasession/element-', self id asString, '-ctx', self context id printString, '",
			data : { term : request.term },
			complete : function (xhr, result) {
				if (result !!= "success") return;
				callback (JSON.parse(xhr.responseText));
			}
		});
	}
})
.data( "autocomplete" )._renderItem = function( ul, item ) {
	return $( "<li></li>" )
		.data( "item.autocomplete", item )
		.append( "<a>" + item.label + "</a>" )
		.appendTo( ul );
};
'.! !

!WebAutocomplete2Field methodsFor: 'events-ajax'!
afterPostAndUpdate: aWebElement
	"after the selection the field is immediatelly Ajax posted and the specified element is updated"
	self elementToUpdate: aWebElement! !

!WebAutocomplete2Field methodsFor: 'private-streaming'!
aidaPresenterFor: aRequest on: aSession
	"Ajax call via session from jQuery Autocomplete to return matched choices"
	| presenter criteria |
	presenter := WebJSONPresenter new.
	criteria := aRequest queryAt: 'term'. "characters entered so far in Autocomplete field"
	presenter presenterBlock: 
		[self choicesAsJsonForEntry: criteria ].
	^presenter! !

!WebAutocomplete2Field methodsFor: 'accessing'!
choiceAspect
	"this method is called on each choice to display choice's text"
	^choiceAspect! !

!WebAutocomplete2Field methodsFor: 'accessing'!
choiceAspect: aSymbol
	choiceAspect := aSymbol! !

!WebAutocomplete2Field methodsFor: 'private'!
choicesAsJsonForEntry: aString
	| choices |
	choices := self getChoicesForEntry: aString.
	choices := choices collect: [:each | 
		(Dictionary new
			at: #label put: (self empasizeStarting: aString in: each);
			at: #value put: each;
			yourself) ].
	^WebJSON stringify: choices.! !

!WebAutocomplete2Field methodsFor: 'private'!
choicesAspect
	^choicesAspect! !

!WebAutocomplete2Field methodsFor: 'private'!
choicesAspect: aSymbol
	choicesAspect := aSymbol! !

!WebAutocomplete2Field methodsFor: 'private'!
choicesAspect: aSymbol for: anObject
	"this method is called with our field as argument on that object. It must return a collection of strings"
	"example: myObject searchFor: aString (choicesAspect is #searchFor: )"
	self choicesAspect: aSymbol.
	self choicesObject: anObject! !

!WebAutocomplete2Field methodsFor: 'private'!
choicesObject
	^choicesObject! !

!WebAutocomplete2Field methodsFor: 'private'!
choicesObject: anObject
	choicesObject := anObject! !

!WebAutocomplete2Field methodsFor: 'accessing'!
elementToUpdate
	^elementToUpdate! !

!WebAutocomplete2Field methodsFor: 'accessing'!
elementToUpdate: aWebElement
	elementToUpdate := aWebElement! !

!WebAutocomplete2Field methodsFor: 'private'!
empasizeStarting: aCriteria in: aString
	"put in bold starting part of text to emphasize the criteria part. Ignore case"
	| in out |
	aCriteria trimBlanks isEmpty ifTrue: [^aString].
	(aCriteria trimBlanks, '*' match: aString) ifFalse: [^aString].
	in := aString readStream.
	out := WriteStream on: String new.
	out nextPutAll: '<b>'.
	aCriteria trimBlanks size timesRepeat: [out nextPut: in next].
	out nextPutAll: '</b>'.
	[in atEnd] whileFalse: [out nextPut: in next].
	^out contents! !

!WebAutocomplete2Field methodsFor: 'private'!
getChoicesForEntry: aString
	"return list of choices, selected already entered characters in  aString. "
	"always return text strings, not choice objects!!"
	| choices matchString |
	self choiceAspect isNil "one possiblity, direct question to choicesObject"
		ifTrue: [^self choicesObject perform: self choicesAspect with: aString].
	"other possibility, we select internaly from all choices"
	choices := self choicesObject perform: self choicesAspect.
	matchString := aString, '*'.
	choices := choices select: [:each | matchString match: (each perform: self choiceAspect)].
	^choices collect: [:each | each perform: self choiceAspect].! !

!WebAutocomplete2Field methodsFor: 'initialize-release'!
initialize
	"jQuery specific"
	super initialize.
	JQueryLibrary ensureUI.! !

!WebAutocomplete2Field methodsFor: 'testing'!
isAutocompleteField
	^true! !

!WebAutocomplete2Field methodsFor: 'private-streaming'!
prepareAttributesToStreamOn: aSession
	"if choiceAspect is set, use it!! "
	super prepareAttributesToStreamOn: aSession.
	self choiceAspect isNil ifTrue: [^super prepareAttributesToStreamOn: aSession].
	self value isNil ifTrue: [^nil].
	(self value class canUnderstand: self choiceAspect) ifFalse: [^nil].
	self attributesAt: #value put: 
		(WebFormElement autoConvertAndEncodeValue: (self value perform: self choiceAspect))! !

!WebAutocomplete2Field methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	self ensureId. 
	self addSetupScript.
	super streamHtmlTo: aStream for: aRequest on: aSession.! !

!WebAutocomplete2Field class methodsFor: 'instance creation'!
aspect: aSymbol for: anObject choicesAspect: aChoicesSymbol for: aChoicesObject
	"choicesAspect method is called with our field as argument on aChoicesObject. 
	It must return a collection of strings"
	"example: myObject searchFor: aString (choicesAspect is #searchFor: )"
	^self new 
		aspect: aSymbol for: anObject;
		choicesAspect: aChoicesSymbol for: aChoicesObject! !

!WebAutocomplete2Field class methodsFor: 'instance creation'!
aspect: aSymbol for: anObject choicesAspect: aChoicesSymbol for: aChoicesObject choiceAspect: aTextSymbol
	"choicesAspect method is called with our field as argument on aChoicesObject. 
	It returs a collection of objects, an choice's text 
	is retrieved with a call of choiceAspect method on each"
	^self new 
		aspect: aSymbol for: anObject;
		choicesAspect: aChoicesSymbol for: aChoicesObject;
		choiceAspect: aTextSymbol! !

!WebAutocompleteField methodsFor: 'private'!
acceptInputFromValue: aValueString
	| vlue choices |
	vlue :=  AIDASite convertFromWeb: aValueString on: self session. "ensure unicode!!"
	vlue := (WebFormElement autoConvertString:  vlue toObject: self value).
	self choicesObject notNil & self choiceAspect notNil ifTrue: "save real object, not only text!! "
		[choices := self choicesObject perform: self choicesAspect.
		vlue := choices detect: [:each | (each perform: self choiceAspect) = vlue] ifNone: [nil] ].
	self value: vlue.! !

!WebAutocompleteField methodsFor: 'private-streaming'!
addSetupScriptOn: aStream choicesElement: aChoicesElement
	"Scriptaculous specific"
	| contextParm url afterUpdateElement updateUrl parms |
	contextParm := WebContext contextIdName "aidaCtx", '=', self app context id printString.
	url := self ajaxCallUrlExtended, '&ajaxAutocompleteField&', contextParm.
	afterUpdateElement := self elementToUpdate isNil 
		ifTrue: [''] 
		ifFalse:
			[self elementToUpdate ensureId. 
			updateUrl := self ajaxCallUrl. 
			parms := self ajaxCallUrlParametersFor: self elementToUpdate context: self app context. "is this needed"
 			parms := parms, '&ajaxElementToRecreateId=', self elementToUpdate id asString.
			'afterUpdateElement: function(element, selectedElement){var field = Form.Element.serialize(''',
			self id asString, '''); var name = $(''',
			self id asString, ''').name; new Ajax.Updater(''', self elementToUpdate id asString, ''', ''', updateUrl, 
			''', {method: ''post'', postBody: field + ''', ('&', parms), 
			'&ajaxSingleField='' + name, evalScripts: true})} '].

	aStream nextPutAll: '<script type="text/javascript">new Ajax.Autocompleter(''', 
		self id asString, ''', ''', aChoicesElement id asString, ''', ''', url, 
		''', {', afterUpdateElement, '});</script>', self eol.! !

!WebAutocompleteField methodsFor: 'events-ajax'!
afterPostAndUpdate: aWebElement
	"after the selection the field is immediatelly Ajax posted and the specified element is updated"
	self elementToUpdate: aWebElement! !

!WebAutocompleteField methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
choiceAspect
	"this method is called on each choice to display choice's text"
	^choiceAspect! !

!WebAutocompleteField methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
choiceAspect: aSymbol
	choiceAspect := aSymbol! !

!WebAutocompleteField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
choicesAspect
	^choicesAspect! !

!WebAutocompleteField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
choicesAspect: aSymbol
	choicesAspect := aSymbol! !

!WebAutocompleteField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
choicesAspect: aSymbol for: anObject
	"this method is called with our field as argument on that object. It must return a collection of strings"
	"example: myObject searchFor: aString (choicesAspect is #searchFor: )"
	self choicesAspect: aSymbol.
	self choicesObject: anObject! !

!WebAutocompleteField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
choicesObject
	^choicesObject! !

!WebAutocompleteField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
choicesObject: anObject
	choicesObject := anObject! !

!WebAutocompleteField methodsFor: 'accessing'!
elementToUpdate
	^elementToUpdate! !

!WebAutocompleteField methodsFor: 'accessing'!
elementToUpdate: aWebElement
	elementToUpdate := aWebElement! !

!WebAutocompleteField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
getChoicesForEntry: aString
	"return list of choices, selected already entered characters in  aString. "
	"always return text strings, not choice objects!!"
	| choices matchString |
	self choiceAspect isNil "one possiblity, direct question to choicesObject"
		ifTrue: [^self choicesObject perform: self choicesAspect with: aString].
	"other possibility, we select internaly from all choices"
	choices := self choicesObject perform: self choicesAspect.
	matchString := aString, '*'.
	choices := choices select: [:each | matchString match: (each perform: self choiceAspect)].
	^choices collect: [:each | each perform: self choiceAspect].! !

!WebAutocompleteField methodsFor: 'initialize-release'!
initialize
	"Scriptaculous specific"
	super initialize.
	ScriptaculousLibrary ensureScriptaculous.! !

!WebAutocompleteField methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isAutocompleteField
	^true! !

!WebAutocompleteField methodsFor: 'private-streaming' stamp: 'janko 9/19/2011 14:31'!
prepareAttributesToPrintOn: aSession
	"if choiceAspect is set, use it!! "
	super prepareAttributesToPrintOn: aSession.
	self choiceAspect isNil ifTrue: [^super prepareAttributesToPrintOn: aSession].
	self value isNil ifTrue: [^nil].
	(self value class canUnderstand: self choiceAspect) ifFalse: [^nil].
	self attributesAt: #value put: 
		(WebFormElement autoConvertAndEncodeValue: (self value perform: self choiceAspect))! !

!WebAutocompleteField methodsFor: 'private-streaming'!
prepareAttributesToStreamOn: aSession
	"if choiceAspect is set, use it!! "
	super prepareAttributesToStreamOn: aSession.
	self choiceAspect isNil ifTrue: [^super prepareAttributesToStreamOn: aSession].
	self value isNil ifTrue: [^nil].
	(self value class canUnderstand: self choiceAspect) ifFalse: [^nil].
	self attributesAt: #value put: 
		(WebFormElement autoConvertAndEncodeValue: (self value perform: self choiceAspect))! !

!WebAutocompleteField methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	| choicesElement |
	choicesElement := (WebElement newClass: #'auto_complete') parent: self.
	self ensureId. choicesElement ensureId.
	super streamHtmlTo: aStream for: aRequest on: aSession.
	choicesElement streamHtmlTo: aStream for: aRequest on: aSession.
	self addSetupScriptOn: aStream choicesElement: choicesElement.! !

!WebAutocompleteField class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject choicesAspect: aChoicesSymbol for: aChoicesObject
	"choicesAspect method is called with our field as argument on aChoicesObject. 
	It must return a collection of strings"
	"example: myObject searchFor: aString (choicesAspect is #searchFor: )"
	^self new 
		aspect: aSymbol for: anObject;
		choicesAspect: aChoicesSymbol for: aChoicesObject! !

!WebAutocompleteField class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject choicesAspect: aChoicesSymbol for: aChoicesObject choiceAspect: aTextSymbol
	"choicesAspect method is called with our field as argument on aChoicesObject. 
	It returs a collection of objects, an choice's text 
	is retrieved with a call of choiceAspect method on each"
	^self new 
		aspect: aSymbol for: anObject;
		choicesAspect: aChoicesSymbol for: aChoicesObject;
		choiceAspect: aTextSymbol! !

!WebButton methodsFor: 'private'!
acceptInputFromValue: aString! !

!WebButton methodsFor: 'accessing'!
action
	^self otherAt: #Action  ifAbsent: [nil]! !

!WebButton methodsFor: 'accessing'!
action: aSymbol
	aSymbol isSymbol ifFalse: [self error: 'button action must be a symbol'].
	self otherAt: #Action  put: aSymbol! !

!WebButton methodsFor: 'private-ajax'!
ajaxSubmit
	"submit a form by Ajax instead of normal post. Page is NOT reloaded!! " 
	self isAjaxSubmit ifTrue: [^nil].
	self onClick:  "actually submit"
		(self scriptForSubmitOnEvent: #submit context: self context).
	(self eventHandlerFor: #submit)
		addAcceptSubmittedForm.
	self onClick: 'return false'. "to break normal form submitting and full page reload"	
	self setAjaxSubmit.! !

!WebButton methodsFor: 'accessing'!
disableUntilValid
	"until form is valid and with all required fields, button will be disabled, then it will Ajax enable"
"	self otherAt: #disableUntilValid put: true. "
	self disabled.
	self wrap. "wrap in <span> to become updatable"
	self form onFormChangeDo: [:field |
		self form isComplete 
			ifTrue:  "all requered fields and valid"
				[self enabled. 
				self focus.
				self update]
			ifFalse: "disable again if form became invalid after vas already valid"
				[self disabled. 
				self update] ]! !

!WebButton methodsFor: 'private-ajax'!
ensureOnClickReturnFalseAtEnd
	"for onClick script, ensure that 'return false' (if any) will be the last sentence in the script"
	| coll new |
	coll := self attributesAt: #onClick. coll isNil ifTrue: [^nil].
	(coll isKindOf: OrderedCollection) ifFalse: [^nil].
	(coll contains: [:each | '*return false*' match: each]) ifFalse: [^nil].
	new := coll reject: [:each | '*return false*' match: each].  "also to avoid duplicates"
	new := new add: 'return false'; yourself.
	self attributesAt: #onClick put: new.! !

!WebButton methodsFor: 'accessing'!
image
	^image! !

!WebButton methodsFor: 'accessing'!
image: aWebImage
	"if button is an image"
	image := aWebImage! !

!WebButton methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	self type: 'submit'.! !

!WebButton methodsFor: 'testing'!
isAjaxSubmit
	"this button will submit a form with Ajax request and a page will not be reloaded"
	^(self otherAt: #AjaxSubmit) = true! !

!WebButton methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isButton
	^true! !

!WebButton methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isEmpty
	^true! !

!WebButton methodsFor: 'private'!
isValid
	"nothing to validate on a button"
	^true! !

!WebButton methodsFor: 'events-ajax'!
noSubmit
	"do not submit a form when this button is pressed"! !

!WebButton methodsFor: 'private-ajax'!
onSubmitAnswer
	"Answer when button is clicked and form submitted.Answer to the currenty executing context"
	"Part of tree-like control flow, see WebDemoApp for example "
	^self otherAt: #OnSubmitAnswer ifAbsent: [nil]! !

!WebButton methodsFor: 'events-ajax'!
onSubmitAnswer: anObject
	"answer anObject as result when button is clicked and form submitted.Answer to the currenty executing context."
	"Answer is copied to parent context when widget and therefore context is closed"
	"Part of tree-like control flow, see WebDemoApp for example "
	self ajaxSubmit.
	(self eventHandlerFor: #submit) 
		addAnswer: anObject.! !

!WebButton methodsFor: 'events-ajax'!
onSubmitClose
	"Ajax submit then current window (if popup) is closed, its context also"
	self ajaxSubmit.
	(self eventHandlerFor: #submit) 
		addCloseWindow.! !

!WebButton methodsFor: 'events-ajax'!
onSubmitDo: aBlock
	"execute that block when this button is pressed and after form is Ajax posted"
	self ajaxSubmit.
	(self eventHandlerFor: #submit) 
		addActionBlock: aBlock.! !

!WebButton methodsFor: 'events-ajax'!
onSubmitUpdate: aWebElement
	"Ajax submit the update that element"
	^self onSubmitUpdate: aWebElement with: nil! !

!WebButton methodsFor: 'events-ajax'!
onSubmitUpdate: aWebElement with: anArgObject
	"Ajax submit the update that element"
	aWebElement isNil ifTrue: [self error: 'no element to update!!'].
	aWebElement ensureId. 
	self ajaxSubmit. "which will stop normal submit and page reload"
	(self eventHandlerFor: #submit) 
		addUpdate: aWebElement with: anArgObject.! !

!WebButton methodsFor: 'private'!
prepareAttributesToStreamOn: aSession
	"prepare multilingual button text, if needed"
	super prepareAttributesToStreamOn: aSession.
	((self attributes includesKey: #value) 
		and: [(self attributes at: #value) aidaIsAssociation]) ifTrue:
			[self attributes 
				at: #value 
				put: (self textFromMultilang: (self attributes at: #value) on: aSession)
		]! !

!WebButton methodsFor: 'private'!
prepareImageAttributeOn: aSession
	self attributesAt: #src put:  (self image urlOnSession: aSession)! !

!WebButton methodsFor: 'model adapting'!
save
	"nothing to save for button"! !

!WebButton methodsFor: 'private-ajax'!
scriptForEvent: anEventSymbol context: aWebContext
	^'aidaEvent(''', anEventSymbol asString, ''',''', 
		(self ensureId; id) asString, ''',''', 
		aWebContext id asString, ''')'! !

!WebButton methodsFor: 'private-ajax'!
scriptForSubmitOnEvent: anEventSymbol context: aWebContext
	"send serialized form values as value"
	^'aidaEvent(''', anEventSymbol asString, ''',''', 
		(self ensureId; id) asString, ''',''', 
		aWebContext id asString, ''',',
		'aidaSerializeForm(''', self form id asString, '''))'! !

!WebButton methodsFor: 'private-ajax'!
setAjaxSubmit
	"this button will submit a form with Ajax request and a page will not be reloaded"
	^self otherAt: #AjaxSubmit put: true! !

!WebButton methodsFor: 'testing'!
shouldAjaxSubmit
	"in popup window and widgets always Ajax submit!! "
	| form |
	form := self form.
	form parent isPureWidget ifTrue: [^true].
	form parent isWebPage "and not a popup window" 
		ifTrue: [^false]. "can submit normally"
	^true! !

!WebButton methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebButton methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	(self isAjaxSubmit not "yet" and: [self shouldAjaxSubmit]) 
		ifTrue: [self ajaxSubmit].
	self ensureOnClickReturnFalseAtEnd. "for ajaxSubmit"
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	self image notNil ifTrue: [self prepareImageAttributeOn: aSession].
	self prepareToHtmlStreamingOn: aSession.
	aStream nextPutAll: self ident, '<input'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: self tagClosing.
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebButton methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
text
	^self attributesAt: #value! !

!WebButton methodsFor: 'accessing' stamp: 'janko 9/12/2011 20:39'!
text: aStringOrAssociation
	"set the text to be shown in a button, It is actually a value attribute in input tag"
	| txt |
	"slovene csz are converted if char ^ is after such a char"
	txt := (aStringOrAssociation aidaIsAssociation not and: [aStringOrAssociation includes: $^ ]) 
		ifTrue: [aStringOrAssociation convertToSloveneChars] 
		ifFalse: [aStringOrAssociation].
	self attributesAt: #value put: txt. "txt can be a multilingual association"
	self addText: txt! !

!WebButton class methodsFor: 'instance creation'!
image: aWebImage
	^self new 
		type: #image; 
		image: aWebImage! !

!WebButton class methodsFor: 'instance creation'!
image: aWebImage action: aSymbol
	^self new 
		type: #image; 
		image: aWebImage;
		action: aSymbol! !

!WebButton class methodsFor: 'instance creation'!
text: aString
	^self new
		type: #submit;
		text: aString! !

!WebButton class methodsFor: 'instance creation'!
text: aString action: aSymbol
	^self new 
		type: #submit;
		text: aString;
		action: aSymbol! !

!WebCache methodsFor: 'private-cache' stamp: 'np 3/16/2009 12:33'!
addObject: anObject view: aViewSymbol content: aByteStringOrArray timeout: aSeconds
	| views |
	views := self objects at: anObject ifAbsentPut: [Dictionary new].
	views at: aViewSymbol put: 
		(WebCacheEntry new content: aByteStringOrArray; timeout: aSeconds)! !

!WebCache methodsFor: 'settings' stamp: 'np 3/16/2009 12:34'!
cacheTimeout
	"in seconds, how long cache entry lives until is invalidated"
	"default is one day"
	^self settingsAt: #CacheDuration ifAbsentPut: [24*3600]! !

!WebCache methodsFor: 'settings' stamp: 'np 3/16/2009 12:34'!
cacheTimeout: aSeconds
	"in seconds, how long cache entry lives until is invalidated"
	^self settingsAt: #CacheDuration put: aSeconds! !

!WebCache methodsFor: 'private-cache' stamp: 'np 3/16/2009 12:34'!
entryForObject: anObject view: aViewSymbol
	^(self objects at: anObject ifAbsent: [^nil])
		at: aViewSymbol ifAbsent: [nil]! !

!WebCache methodsFor: 'initialize-release' stamp: 'np 3/16/2009 12:34'!
initObjects
	objects := Dictionary new! !

!WebCache methodsFor: 'initialize-release' stamp: 'np 3/16/2009 12:34'!
initOther
	other := Dictionary new! !

!WebCache methodsFor: 'initialize-release' stamp: 'np 3/16/2009 12:34'!
initSettings
	settings := Dictionary new! !

!WebCache methodsFor: 'caching' stamp: 'np 3/16/2009 12:35'!
invalidateObject: anObject
	"if exist then cache entries for that object are not valid anymore and shall be refreshed"
	self removeObject: anObject! !

!WebCache methodsFor: 'caching' stamp: 'np 3/16/2009 12:35'!
isCached: anObject to: aRequest on: aWebSession
	| entry |
	entry := ((self objects at: anObject ifAbsent: [^false])
		at: aRequest view ifAbsent: [^false]).
	entry isTimedOut 
		ifTrue: [self removeObject: anObject view: aRequest view. ^false].
	^true! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:35'!
objects
	"a dictionary of cache entries per domain object per view"
	objects isNil ifTrue: [self initObjects].
	^objects! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:35'!
other
	^other! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:36'!
otherAt: aSymbol
	"other values"
	^self otherAt: aSymbol ifAbsent: [nil]! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:36'!
otherAt: aSymbol ifAbsent: aBlock
	"other values"
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:36'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:36'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!WebCache methodsFor: 'accessing' stamp: 'np 3/16/2009 12:36'!
parent
	^parent! !

!WebCache methodsFor: 'accessing' stamp: 'np 3/16/2009 12:36'!
parent: anObject
	parent := anObject! !

!WebCache methodsFor: 'caching' stamp: 'np 3/16/2009 13:00'!
purgeCache
	"invalidate all timed-out cache entries"
	"run it from time to time, like every day from SwazooServer>>watchogOther"
	self objects associations do: [:assoc |
		assoc value associations do: [:vassoc | vassoc value isTimedOut 
			ifTrue: [self removeObject: assoc key view: vassoc key] ] ]! !

!WebCache methodsFor: 'private-cache' stamp: 'np 3/16/2009 12:36'!
removeObject: anObject
	self objects removeKey: anObject ifAbsent: [nil]! !

!WebCache methodsFor: 'private-cache' stamp: 'np 3/16/2009 12:36'!
removeObject: anObject view: aViewSymbol
	| views |
	views := self objects at: anObject ifAbsent: [^nil].
	views removeKey: aViewSymbol ifAbsent: [^nil].
	views isEmpty ifTrue: [self removeObject: anObject].! !

!WebCache methodsFor: 'caching' stamp: 'np 3/16/2009 12:37'!
respond: anObject to: aRequest on: aWebSession
	| response |
	response := HTTPResponse ok.
	aRequest task response: response.
	self site addResponseHeadersTo: response forPage: nil on: aWebSession.
	response entity: (self entryForObject: anObject view: aRequest view) content. 
	self site log: ' cached done'.
	^response! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:37'!
settings
	settings isNil ifTrue: [self initSettings].
	^settings! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:37'!
settingsAt: aSymbol
	^self settingsAt: aSymbol ifAbsent: [nil]! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:37'!
settingsAt: aSymbol ifAbsent: aBlock
	^self settings at: aSymbol ifAbsent: aBlock! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:37'!
settingsAt: aSymbol ifAbsentPut: aValue
	^self settings at: aSymbol ifAbsentPut: aValue! !

!WebCache methodsFor: 'private' stamp: 'np 3/16/2009 12:37'!
settingsAt: aSymbol put: aValue
	^self settings at: aSymbol put: aValue! !

!WebCache methodsFor: 'caching' stamp: 'np 3/16/2009 12:37'!
shouldCache: anObject to: aRequest on: aWebSession
	^anObject aidaCacheView: aRequest view on: aWebSession! !

!WebCache methodsFor: 'accessing' stamp: 'np 3/16/2009 12:37'!
site	
	^self parent! !

!WebCache methodsFor: 'caching' stamp: 'np 3/16/2009 12:38'!
store: aByteStringOrArray for: anObject to: aRequest on: aWebSession
	| timeout |
	timeout := anObject aidaCacheTimeout notNil
		ifTrue: [anObject aidaCacheTimeout notNil] "per domain object cache timeout"
		ifFalse: [self cacheTimeout]. 		"global cache timeout"
	self addObject: anObject view: aRequest view 
		content: aByteStringOrArray timeout: timeout! !

!WebCache class methodsFor: 'instance creation' stamp: 'np 3/16/2009 12:33'!
newOn: anAIDASite
	^super new
		parent: anAIDASite! !

!WebCacheEntry methodsFor: 'accessing' stamp: 'np 3/16/2009 12:38'!
content
	"cached content"
	^content! !

!WebCacheEntry methodsFor: 'accessing' stamp: 'np 3/16/2009 12:39'!
content: aByteStringOrArray
	"cached content"
	content := aByteStringOrArray! !

!WebCacheEntry methodsFor: 'accessing' stamp: 'np 3/16/2009 12:39'!
created
	"when the cahce entry was created"
	^SpTimestamp fromSeconds: self createdAsSeconds! !

!WebCacheEntry methodsFor: 'private' stamp: 'np 3/16/2009 12:39'!
createdAsSeconds
	"when the cahce entry was created"
	^created! !

!WebCacheEntry methodsFor: 'testing' stamp: 'np 3/16/2009 12:39'!
isTimedOut
	^(SpTimestamp now asSeconds - self createdAsSeconds) > self timeout! !

!WebCacheEntry methodsFor: 'private' stamp: 'np 3/16/2009 12:39'!
setCreated
	created := SpTimestamp now asSeconds! !

!WebCacheEntry methodsFor: 'accessing' stamp: 'np 3/16/2009 12:39'!
timeout
	"how many seconds this cached content is valid"
	^timeout! !

!WebCacheEntry methodsFor: 'accessing' stamp: 'np 3/16/2009 12:39'!
timeout: aSeconds
	"how many seconds this cached content is valid"
	timeout := aSeconds! !

!WebCacheEntry class methodsFor: 'instance creation' stamp: 'np 3/16/2009 12:40'!
new
	^super new setCreated! !

!WebCanvas methodsFor: 'attributes'!
height: anInteger
	self attributesAt: #height put: anInteger printString! !

!WebCanvas methodsFor: 'attributes'!
size: aPoint
	"set the size of a canvas in format width@height"
	self width: aPoint x.
	self height: aPoint y.! !

!WebCanvas methodsFor: 'private'!
tag
	^#canvas! !

!WebCanvas methodsFor: 'attributes'!
width: anInteger
	self attributesAt: #width put: anInteger printString! !

!WebCaptcha methodsFor: 'accessing'!
aidaContentType
	^'image/png'.! !

!WebCaptcha methodsFor: 'private' stamp: 'janko 4/25/2012 10:58'!
aidaIsRespondingStreamed
	^false! !

!WebCaptcha methodsFor: 'private-streaming'!
aidaPresenterFor: aRequest on: aSession 
	^self! !

!WebCaptcha methodsFor: 'defaults' stamp: 'janko 3/22/2008 01:16'!
backgroundImageFilename
	^'captcha-background.png'! !

!WebCaptcha methodsFor: 'private-streaming'!
contentsOfCaptcha
	^self filename contentsOfEntireFileBinary asString! !

!WebCaptcha methodsFor: 'defaults' stamp: 'janko 3/22/2008 15:11'!
fontName
	^'Andy'! !

!WebCaptcha methodsFor: 'defaults' stamp: 'janko 3/22/2008 23:23'!
imageSize
	^150@30	! !

!WebCaptcha methodsFor: 'private' stamp: 'janko 3/22/2008 16:26'!
isExpired
	"it exists more than few hours"
	^(SpTimestamp now asSeconds - self preparedTimestamp asSeconds) > (10*3600)! !

!WebCaptcha methodsFor: 'converting' stamp: 'janko 7/18/2008 17:52'!
prepareCaptchaImage
	| textFName captchaFName |
	textFName := 'captchatext', self random, '.png'. captchaFName := 'captcha', self random, '.png'.
	OSProcess waitForCommand: 
		'convert -size 150x30 xc:transparent -font ', self fontName, ' -pointsize 25 -draw "text 40,23 ''', 
		self text, ''' " ', textFName.
	OSProcess waitForCommand: 'composite -gravity center ', 
		textFName, ' ', self backgroundImageFilename, ' ',  captchaFName.
	(SpFilename named: textFName) delete.
	self filename: captchaFName.
	self setPreparedTimestamp.! !

!WebCaptcha methodsFor: 'private' stamp: 'janko 3/22/2008 16:07'!
preparedTimestamp
	^self timestamps at: #prepared ifAbsent: [nil]! !

!WebCaptcha methodsFor: 'converting' stamp: 'janko 7/18/2008 17:53'!
random
	random isNil ifTrue: 
		[random := (AIDASite random next * 1000) truncated printString].
	^random
! !

!WebCaptcha methodsFor: 'accessing' stamp: 'janko 3/22/2008 18:35'!
randomCharacter
	"from 25 lowercase, 25 upercase, 10 numbers"
	| rnum |
	rnum := (Random new next * 60) truncated.
	rnum <= 25 ifTrue: [^($a asInteger + rnum) asCharacter].
	rnum <= 50 ifTrue: [^($A asInteger + rnum-25) asCharacter].
	^($0 asInteger + rnum-50) asCharacter
! !

!WebCaptcha methodsFor: 'accessing' stamp: 'janko 3/22/2008 18:40'!
randomCharacterOnGen: aRandom
	"from 25 lowercase, 25 upercase, 10 numbers"
	| rnum |
	rnum := (aRandom next * 60) truncated.
	rnum <= 25 ifTrue: [^($a asInteger + rnum) asCharacter].
	rnum <= 50 ifTrue: [^($A asInteger + rnum-25) asCharacter].
	^($0 asInteger + rnum-50) asCharacter
! !

!WebCaptcha methodsFor: 'private' stamp: 'janko 3/22/2008 16:08'!
setPreparedTimestamp
	^self timestamps at: #prepared put: SpTimestamp now.! !

!WebCaptcha methodsFor: 'accessing' stamp: 'janko 3/22/2008 18:42'!
setRandomText
	"5 characters or numbers"
	| rnd rgen |
	rnd := ByteString new: 5. rgen := Random new.
	1 to: 5 do: [:inx | rnd at: inx put: (self randomCharacterOnGen: rgen)].
	self text: rnd.
! !

!WebCaptcha methodsFor: 'private' stamp: 'janko 3/22/2008 15:59'!
size
	^self filename fileSize! !

!WebCaptcha methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession 
	self prepareCaptchaImage.
	aStream nextPutAll: self contentsOfCaptcha.
	self filename delete.
	self class
		addToCache: self ;
		releaseExpiredCaptchas! !

!WebCaptcha methodsFor: 'accessing' stamp: 'janko 3/22/2008 18:27'!
text
	"string to be converted into captcha image"
	text isNil ifTrue: [^''].
	^text! !

!WebCaptcha methodsFor: 'accessing' stamp: 'janko 3/22/2008 18:27'!
text: aString
	"string to be converted into captcha image"
	text := aString! !

!WebCaptcha class methodsFor: 'private-cache' stamp: 'janko 3/22/2008 16:29'!
addToCache: aCaptcha
	self cache add: aCaptcha! !

!WebCaptcha class methodsFor: 'private-cache' stamp: 'janko 3/22/2008 16:28'!
cache
	Cache isNil ifTrue: [self initCache].
	^Cache! !

!WebCaptcha class methodsFor: 'private-cache' stamp: 'janko 3/22/2008 16:28'!
initCache
	Cache := Set new.! !

!WebCaptcha class methodsFor: 'instance creation' stamp: 'janko 3/22/2008 18:38'!
new
	"prepare a CAPTCHA with random string"
	| session |
	session := self firstSessionFromStack. "on which we are building this captcha"
	^super new 
		site: (session notNil ifTrue: [session site] ifFalse: [nil]);
		setRandomText! !

!WebCaptcha class methodsFor: 'instance creation' stamp: 'janko 3/22/2008 18:39'!
newFor: aString
	"prepare a CAPTCHA image for that string"
	^self new 
		text: aString! !

!WebCaptcha class methodsFor: 'private-cache' stamp: 'janko 3/22/2008 16:30'!
releaseExpiredCaptchas
	self cache do: [:each | 
		each isExpired ifTrue: [each removeYourself "from url resolver"]]! !

!WebChat methodsFor: 'adding-removing'!
addLine: aString
	self lines add: aString.
	self removeOlderLines.
	self announceChange! !

!WebChat methodsFor: 'changes'!
announceChange
	self announcers associations do: [:assoc |
		assoc key "app" isActive 
			ifTrue: [assoc value value]
			ifFalse: [self announcers removeKey: assoc key] ] "self cleanup of released application state"! !

!WebChat methodsFor: 'private'!
announcers
	"actually blocks to be executed when change occurs. A weak dictionary with an App as key, so that sesion app 
	state cleanup also removes the block from here"
	announcers isNil ifTrue: [self initAnnouncers].
	^announcers! !

!WebChat methodsFor: 'initialize-release'!
initAnnouncers
	announcers := "Weak"Dictionary new.! !

!WebChat methodsFor: 'initialize-release'!
initLines
	lines := OrderedCollection new.! !

!WebChat methodsFor: 'accessing'!
last4Lines
	"empty lines in front, if less than 4 lines exist"
	| last |
	last := OrderedCollection new.
	((4 - self lines size) max: 0) timesRepeat: [last add: ''].
	((self lines size - 4) max: 1) to: self lines size do: [:inx | last add: (self lines at: inx)].
	^last! !

!WebChat methodsFor: 'private'!
lines
	lines isNil ifTrue: [self initLines].
	^lines! !

!WebChat methodsFor: 'private'!
removeOlderLines
	(self lines size - 4) timesRepeat: [self lines removeFirst]! !

!WebChat methodsFor: 'changes'!
whenChangedDo: aBlock on: aWebApplication
	"register a block to be executed when new chat line was entered"
	self announcers at: aWebApplication put: aBlock! !

!WebChat class methodsFor: 'accessing'!
singleton
	Singleton isNil ifTrue: [Singleton := self new].
	^Singleton! !

!WebChatApp methodsFor: 'views'!
chatElement
	| e le |
	e := WebElement newDiv.
	e addTextH1: 'Multi-user Chat'.
	le := self linesElement.
	e add: le;  addBreak.
	(e addInputFieldAspect: #line for: self) focus.
	(e addButtonText: 'Send')
		onSubmitDo:   "Ajax submit then execute this block"
			[self observee addLine: self line. self line: ''.
			e update].  "update lines and input field"
	self observee whenChangedDo: [le update] on: self.
	^e! !

!WebChatApp methodsFor: 'accessing'!
line
	line isNil ifTrue: [^''].
	^line! !

!WebChatApp methodsFor: 'accessing'!
line: aString
	line := aString! !

!WebChatApp methodsFor: 'views'!
linesElement
	| e  |
	e:= WebElement newDiv.
	self observee last4Lines do: [:line |
		e addNbSp: 4; addText: line.
		e addBreak].
	^e! !

!WebChatApp methodsFor: 'views'!
viewMain
	self add: self chatElement! !

!WebCheckBox methodsFor: 'private-events'!
acceptInputFromValue: aBooleanOrString
	"true/false comes from WebEvent, 'on' or '' from form post"
	(aBooleanOrString = true or: [aBooleanOrString = 'on'])
		ifTrue: [self checkValue]
		ifFalse: [self uncheckValue]! !

!WebCheckBox methodsFor: 'private-events'!
addObjectToSelected
	(self selected includes: self object) ifFalse: 
		[self selected add: self object.
		self adaptor setChanged]! !

!WebCheckBox methodsFor: 'private-events'!
checkValue
	self aspect notNil ifTrue: [self setAspectTrue].
	self selected notNil ifTrue: [self addObjectToSelected]! !

!WebCheckBox methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checked
	^checked! !

!WebCheckBox methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checked: aBoolean
	checked := aBoolean! !

!WebCheckBox methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	super initialize.
	self type: 'checkbox'.
	self checked: false.! !

!WebCheckBox methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isCheckBox
	^true! !

!WebCheckBox methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isChecked
	| value |
	self aspect notNil ifTrue:
		[value := self object perform: self aspect.
		^value == true].  "so that false will be returned even if value is not so"
	self selected notNil ifTrue: [^self selected includes: self object]. 
	^self checked! !

!WebCheckBox methodsFor: 'private' stamp: ' 21/4/07 22:07'!
joinToForm: aWebForm
	aWebForm fields keysAndValuesDo: [:fname :element | 
		element == self ifTrue: [self name: fname]. ^self]! !

!WebCheckBox methodsFor: 'private'!
object: anObject from: aCollection
	"if checked, this object will be put in collection. If object is initially in collection, 
	checkbox will be checked"
	"Usefull for easy selection among many objects"
	self adaptor: (AidaModelAdaptor new subject: anObject).
	self selected: aCollection.! !

!WebCheckBox methodsFor: 'private-events'!
removeObjectFromSelected
	(self selected includes: self object) ifTrue: 
		[self selected remove: self object.
		self adaptor setChanged]! !

!WebCheckBox methodsFor: 'private-events'!
scriptForEvent: anEventSymbol context: aWebContext
	"send if chekbox checked or not after event"
	^'aidaEvent(''', anEventSymbol asString, ''',''', 
		(self ensureId; id) asString, ''',''', 
		aWebContext id asString, ''',',
		'this.checked);'! !

!WebCheckBox methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
selected
	^selected! !

!WebCheckBox methodsFor: 'private' stamp: ' 21/4/07 22:07'!
selected: aCollection
	"checked objects"
	selected := aCollection! !

!WebCheckBox methodsFor: 'private-events'!
setAspectFalse
	self adaptor value: false! !

!WebCheckBox methodsFor: 'private-events'!
setAspectTrue
	self adaptor value: true! !

!WebCheckBox methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setChecked
	self checked: true! !

!WebCheckBox methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setUnchecked
	self checked: false! !

!WebCheckBox methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebCheckBox methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession.
	aStream nextPutAll: self ident, '<input'.
	self streamAttributesTo: aStream for: aSession.
	self isChecked ifTrue: [aStream nextPutAll: ' checked'].
	aStream nextPutAll: self tagClosing.! !

!WebCheckBox methodsFor: 'private-events'!
uncheckValue
	self aspect notNil ifTrue: [self setAspectFalse].
	self selected notNil ifTrue: [self removeObjectFromSelected]! !

!WebCheckBox methodsFor: 'private' stamp: ' 21/4/07 22:07'!
value
	^self attributesAt: 'value'! !

!WebCheckBox methodsFor: 'private' stamp: ' 21/4/07 22:07'!
value: aString
	"set the value name  of the  check box"
	^self attributesAt: 'value' put: aString! !

!WebCheckBox class methodsFor: 'obsolete'!
aspect: aSymbol for: anObject
	"obsolete!!"
	^self newAspect: aSymbol for: anObject! !

!WebCheckBox class methodsFor: 'instance creation'!
newAspect: aSymbol for: anObject
	"this method will be called and true/false will be set/clear on an object"
	^self new aspect: aSymbol for: anObject! !

!WebCheckBox class methodsFor: 'instance creation'!
newForObject: anObject from: aCollection
	"if checked, this object will be put in collection. If object is initially in collection, 
	checkbox will be checked"
	"Usefull for easy selection among many objects"
	^self new object: anObject from: aCollection! !

!WebClipboard methodsFor: 'converting' stamp: ' 21/4/07 22:07'!
asDocLink
	"return clipboard contents as a new DocLink"
	^DocLink new
		title: self title;
		url: self url;
		object: self object! !

!WebClipboard methodsFor: 'converting' stamp: ' 21/4/07 22:07'!
copyFromDocLink: aDocLink
	self title: aDocLink title.
	self url: aDocLink url.
	self object: aDocLink object! !

!WebClipboard methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isEmpty
	^(self url isNil or: [self url isEmpty]) and: [self object isNil].! !

!WebClipboard methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
object
	^object! !

!WebClipboard methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
object: anObject
	object := anObject! !

!WebClipboard methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
title
	^title! !

!WebClipboard methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
title: anObject
	title := anObject! !

!WebClipboard methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
url
	^url! !

!WebClipboard methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
url: anObject
	url := anObject! !

!WebCommand methodsFor: 'accessing'!
app
	^self element notNil
		ifTrue: [self element app]	"on which app this element was built"
		ifFalse: [nil]! !

!WebCommand methodsFor: 'converting'!
asJSON
	| dict |
	dict := Dictionary new. "will become a JS object on client side"
	self command notNil ifTrue: [dict at: 'command' put: self command asString].
	self context notNil ifTrue: [dict at: 'context' put: self context].
	self element notNil ifTrue: [dict at: 'id' put: self element id].
	self value notNil ifTrue: [dict at: 'value' put: self value].
	self other notNil ifTrue:
		[self at: 'other' put: self other]. "should be with string/number/boolean/nil values ony"
	^WebJSON stringify: dict! !

!WebCommand methodsFor: 'accessing'!
command
	" #update, ..."
	^command! !

!WebCommand methodsFor: 'private'!
command: aSymbol
	command := aSymbol! !

!WebCommand methodsFor: 'accessing'!
context
	^context! !

!WebCommand methodsFor: 'accessing'!
context: aContextIdString
	context := aContextIdString! !

!WebCommand methodsFor: 'accessing'!
element
	"web element for which is that command (like update this element)"
	^element! !

!WebCommand methodsFor: 'accessing'!
element: aWebElement
	element := aWebElement! !

!WebCommand methodsFor: 'initialize-release'!
initOther
	other := Dictionary new.! !

!WebCommand methodsFor: 'testing'!
isUpdate
	"command to update some element?"
	^self command = #update! !

!WebCommand methodsFor: 'private-other'!
other
	^other! !

!WebCommand methodsFor: 'private-other'!
otherAt: aSymbol
	^self otherAt: aSymbol ifAbsent: [nil]! !

!WebCommand methodsFor: 'private-other'!
otherAt: aSymbol ifAbsent: aBlock
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!WebCommand methodsFor: 'private-other'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!WebCommand methodsFor: 'private-other'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!WebCommand methodsFor: 'private'!
printString
	^'aWebCommand 
	command: ', self command printString, '
	context: ', self context printString, '
	app: ', (self app notNil ifTrue: [self app class name] ifFalse: ['unknown']), '
	view: ', self view printString, '
	element: ', (self element notNil 
		ifTrue: [self element class name, ' ', self element id printString] ifFalse: ['nil']), '
	value: ', (self value notNil ifTrue: [self value size printString, ' bytes'] ifFalse: ['nil'])! !

!WebCommand methodsFor: 'accessing'!
value
	^value! !

!WebCommand methodsFor: 'accessing'!
value: aString
	value := aString! !

!WebCommand methodsFor: 'accessing'!
view
	"on which app view this element was created"
	self element isNil ifTrue: [^nil].
	^self element creationContext notNil
		ifTrue: [self element creationContext view]
		ifFalse: [self element app view]! !

!WebCommand class methodsFor: 'instance creation'!
newLoadUrl: aString
	"command to load in current browser window some other page or reload current one"
	^self new 
		command: #load;
		value: aString! !

!WebCommand class methodsFor: 'instance creation'!
newUpdate: aWebElement with: aString
	"command to update some element on webpage"
	^self new 
		command: #update;
		element: aWebElement;
		value: aString! !

!WebComment methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	text := ''.! !

!WebComment methodsFor: 'private' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebComment methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	aStream nextPutAll: self ident, '<!!-- '.
	aStream nextPutAll: self text.
	aStream nextPutAll: ' -->', self eol.! !

!WebComment methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
text
	^text! !

!WebComment methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
text: aString
	text := aString.! !

!WebComment class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebComment class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
text: aString
	^self new text: aString

"WebText text: 'test'"! !

!WebContext methodsFor: 'accessing'!
activeContext
	"active is always the last context in the chain"
	^self isLast
		ifTrue: [self]
		ifFalse: [self child activeContext]! !

!WebContext methodsFor: 'accessing-other'!
afterCloseUpdate
	"used for temporary reference to the element to update after some popup will be closed. 
	See WebElement onClickPopup:thenClose, and WebElement>>addClosingLinkText: "
	^self otherAt: #AfterCloseUpdate ifAbsent: [nil]! !

!WebContext methodsFor: 'accessing-other'!
afterCloseUpdate: anElement
	"used for temporary reference to the element to update after some popup will be closed. 
	See WebElement onClickPopup:thenClose, and WebElement>>addClosingLinkText: "
	^self otherAt: #AfterCloseUpdate put: anElement! !

!WebContext methodsFor: 'private-ids'!
announceReplacementWith: anOldElement
	"next creation of WebElement (see class #new) will replace its id by that from anOldElement"
	"for robustness we store also the process it announced that!! "
	self replacementAnnouncements at: Processor activeProcess put: anOldElement! !

!WebContext methodsFor: 'accessing'!
answer
	"answer by the widget called in #onSubmitAnswer: or similar methods"
	^answer! !

!WebContext methodsFor: 'private'!
answer: anObject
	"answer by the widget called in #ask: or similar methods"
	answer := anObject! !

!WebContext methodsFor: 'accessing'!
app
	"the instance of WebApplication on which this context is executing"
	^self parent app! !

!WebContext methodsFor: 'private-ids'!
cancelReplacement
	"cancel next #registerId to replace the next element with old one in ids"
	self replacementAnnouncements removeKey: Processor activeProcess ifAbsent: []! !

!WebContext methodsFor: 'private-process'!
checkProcessState
	"this is temporary, it must be improved!! "
	"called from #executeRequest: to check if process is in a state to be closed and initialized instead"
	self isInterrupted ifTrue: 
		[self isLast not ifTrue: [self child close].
		self stopProcess; startProcess].! !

!WebContext methodsFor: 'accessing'!
child
	"another context in the chain, if any"
	^child! !

!WebContext methodsFor: 'private'!
child: aContext
	"add another context in the chain"
	(child notNil and: [aContext notNil]) ifTrue: [child close]. "and remove from app contexts etc."
	child := aContext.
	aContext notNil ifTrue: [aContext parent: self]! !

!WebContext methodsFor: 'executing'!
close
	"close process if any and pass control to parent context, which will continue executing itrs process if any" 
	"It also removes itself from context chain"
	self app removeContext: self.
	self isFirst not ifTrue: 
		[self parent child: nil.
		self event notNil ifTrue: 	  " parent context will now continue executing our req (and its old req if different)"
			[self event context: self parent.    "just to be sure" 
			self parent event notNil ifTrue: [self parent event context: self parent]]. 
		self parent isInterrupted 
			ifTrue: [self parent signal] ]. "to continue executing there"
	self event: nil; answer: nil.
	self stopProcess. "can accidentally terminate process on which we are right now executing?"
	self setClosed.! !

!WebContext methodsFor: 'executing'!
createNewContext
	"create and add as a child to receiver, also to the app"
	| ctx |
	ctx := WebContext newOn: self.
	self child: ctx.
	self app addContext: ctx.
	^ctx! !

!WebContext methodsFor: 'private-ids'!
currentReplacement
	"an old element to be replaced with a new one"
	^self replacementAnnouncements at:  Processor activeProcess ifAbsent: [nil]! !

!WebContext methodsFor: 'private-ids'!
elementId: aSymbol
	"search in a whole context chain, not only in current context!! "
	^self ids at: aSymbol ifAbsent: 
		[self isFirst not
			ifTrue: [self parent elementId: aSymbol]
			ifFalse: [nil]].! !

!WebContext methodsFor: 'accessing'!
event
	"current, later last event (a WebEvent or HTTPRequest) executed on that context"
	^event! !

!WebContext methodsFor: 'accessing'!
event: aWebEventOrRequest
	"current, later last event (a WebEvent or HTTPRequest) executed on that context"
	^event := aWebEventOrRequest! !

!WebContext methodsFor: 'executing'!
executeRequest: aRequest
	self checkProcessState. "and init processes if deadlocked or something. TEMPORARY!! "
	aRequest context: self. self event: aRequest. "to be sure!!"
	self signal "to wakeup the process which will execute it, see #processLoop"! !

!WebContext methodsFor: 'private-ids'!
existsId: aSymbol
	"check in a whole context chain, not only in current context!! "
	^(self elementId: aSymbol) notNil! !

!WebContext methodsFor: 'executing'!
finalizeExecutionOf: aRequest
	"do all necessary cleanup after request was composed and HTML streamed to response"
	self event: nil.   
	aRequest context: nil.	
	self answer: nil; result: nil.! !

!WebContext methodsFor: 'accessing'!
first
	"first context up in the chain"
	^self parent first! !

!WebContext methodsFor: 'accessing'!
form
	"a web form with input fields of this context"
	^self window form! !

!WebContext methodsFor: 'accessing'!
id
	"unique identifier of the context inside the app instance"
	id isNil ifTrue: [self setId].
	^id! !

!WebContext methodsFor: 'private-ids'!
ids
	"dictionary of elements which have id defined, for fast access to them from AJAX requests"
	ids isNil ifTrue: [self initIds].
	^ids! !

!WebContext methodsFor: 'private'!
idt
	"id text, with f at start if first/top context. For debugging"
	^(self isFirst ifTrue: ['f'] ifFalse: ['']), self id printString! !

!WebContext methodsFor: 'initialize-release'!
initIds
	ids := Dictionary new.! !

!WebContext methodsFor: 'initialize-release'!
initOther
	other := Dictionary new.! !

!WebContext methodsFor: 'initialize-release'!
initRegisteredSet
	^self ids at: #setOfRegisteredElements put: Set new.! !

!WebContext methodsFor: 'initialize-release'!
initReplacementAnnouncements
	^self ids at: #replacementAnnouncements put: Dictionary new.! !

!WebContext methodsFor: 'initialize-release'!
initSemaphore
	self semaphore: Semaphore new.! !

!WebContext methodsFor: 'initialize-release'!
initWindow
	self window: (WebWindow new parent: self)! !

!WebContext methodsFor: 'testing'!
isBusy
	^self isExecuting | self isInterrupted! !

!WebContext methodsFor: 'testing-states'!
isClosed
	"a context is already closed"
	^self state = #closed! !

!WebContext methodsFor: 'testing-states'!
isExecuting
	"a context's process is executing the request"
	^self state = #executing! !

!WebContext methodsFor: 'testing'!
isExecutingInOwnProcess
	"context's process will execute the request only if needed, that is, if we have two (or more)
	contexts because first is waiting for second to return some value (like in confirmation dialog)"
	^self process notNil! !

!WebContext methodsFor: 'testing'!
isFirst
	"is this first/upper context in the chain?"
	^false! !

!WebContext methodsFor: 'testing-states'!
isIdle
	"a context's process is in idle state, waiting to get a signal to execute next request"
	^self state = #idle! !

!WebContext methodsFor: 'testing-states'!
isInterrupted
	"a context's process is in an interrupted state, waiting for subcontext to finish and close"
	^self state = #interrupted! !

!WebContext methodsFor: 'testing'!
isLast
	"is this last/lower context in the chain?"
	^self child isNil! !

!WebContext methodsFor: 'testing-states'!
isNoProcess
	"a context doesn't haveits own process to execute a request"
	^self state = #noprocess! !

!WebContext methodsFor: 'private-ids'!
isRegistered: anElement
	^self registeredSet includes: anElement! !

!WebContext methodsFor: 'testing'!
isWebElement
	"because some elements (like WebWindow, WebPage)  have a context as the parent"
	^false! !

!WebContext methodsFor: 'accessing'!
level
	"on which level this context is in context chain. First one has level 0"
	^self parent level + 1! !

!WebContext methodsFor: 'private-ids'!
nextId
	" example: #id9. 
	Consider also already registered ids in contexts above in chain if any "
	^'id', (self nextIdNumber printString) asSymbol! !

!WebContext methodsFor: 'private-ids'!
nextIdNumber
	"considering also already registered ids on above contexts"
	| nr |
	nextId isNil ifTrue: [nextId := self ids size + 1].
	nr := self isFirst not ifTrue: [self parent nextIdNumber - 1] ifFalse: [0].
	nr := nr + nextId + 1.
	nextId := nextId + 1.
	^nr! !

!WebContext methodsFor: 'private-other'!
other
	^other! !

!WebContext methodsFor: 'private-other'!
otherAt: aSymbol
	^self otherAt: aSymbol ifAbsent: [nil]! !

!WebContext methodsFor: 'private-other'!
otherAt: aSymbol ifAbsent: aBlock
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!WebContext methodsFor: 'private-other'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!WebContext methodsFor: 'private-other'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!WebContext methodsFor: 'accessing'!
page
	"a web page on which we are executing. This is always a window of first context in hte chain"
	^self first window! !

!WebContext methodsFor: 'accessing'!
parent
	"parent context up in the chain, but an app on the first context"
	^parent! !

!WebContext methodsFor: 'private'!
parent: aContext
	parent := aContext! !

!WebContext methodsFor: 'private'!
printString
	^'aWebContext id ', self id printString! !

!WebContext methodsFor: 'private-process'!
process
	"a process which executes the request in this context. It can be interrupted and handled to a process from 
	child context. In such case this process is waiting on semaphore for child process to finish and return 
	some value"
	^process! !

!WebContext methodsFor: 'private-process'!
process: aProcess
	process := aProcess! !

!WebContext methodsFor: 'private-process'!
processLoop
	[true] whileTrue:
		[self setIdleState.
		self semaphore wait.
		self setExecutingState.
		self request context: self. "to be sure"
		self result: (self app composeWebPageStepTwoFor: self request).
		self isFirst
			ifTrue: [self first mainSemaphore signal] "for main connection's process to proceed"
			ifFalse: [self parent answer notNil "if any answer, close me and signal parent"
				ifTrue: [self close] "which will also signal interrupted parent context to continue"		ifFalse: [
					self first mainSemaphore signal]] ] "for main connection's process to proceed"! !

!WebContext methodsFor: 'private-process'!
processPriority
	^Processor userBackgroundPriority! !

!WebContext methodsFor: 'private-ids'!
registerIdFor: anElement
	anElement id isNil ifTrue: [anElement id: self nextId]. "auto id if not manually defined!! "
	(self isRegistered: anElement) ifTrue: [^nil].
	(self ids includesKey: anElement id) ifTrue: 
		[self registeredSet remove: (self ids at: anElement id)]. "to replace with a new one"
	self ids at: anElement id put: anElement.
	self registeredSet add: anElement.! !

!WebContext methodsFor: 'private-ids'!
registeredSet
	^self ids at: #setOfRegisteredElements ifAbsent: [self initRegisteredSet]! !

!WebContext methodsFor: 'private-ids'!
removeId: aSymbol
	| element |
	element := self ids at: aSymbol ifAbsent: [^nil].
	self ids removeKey: aSymbol.
	self registeredSet remove: element ifAbsent: [].! !

!WebContext methodsFor: 'private-ids'!
replaceIdIn: anElement with: anOldElement
	"new anElement should have same id as an old one"
	anOldElement isNil ifTrue: [^nil].
	self registeredSet 
		remove: anOldElement ifAbsent: []; 
		add: anElement.
	self ids removeKey: anOldElement id ifAbsent: [].
	anElement attributesAt: #id put: anOldElement id. "anElement id: would deadlock!! "
	self ids at: anElement id put: anElement.! !

!WebContext methodsFor: 'private-ids'!
replacementAnnouncements
	"current elememnt id replacement announcements"
	^self ids at: #replacementAnnouncements ifAbsent: [self initReplacementAnnouncements]! !

!WebContext methodsFor: 'private-obsolete'!
request
	"OBSOLETE, use #event: instead!! "
	"current, later last request executed on that context"
	^self event! !

!WebContext methodsFor: 'private-obsolete'!
request: aRequest
	"OBSOLETE, use #event: instead!! "
	"current, later last request executed on that context"
	self event: aRequest! !

!WebContext methodsFor: 'accessing'!
result
	"resulted web element of executing the context"
	^result! !

!WebContext methodsFor: 'private'!
result: aWebElement
	result := aWebElement! !

!WebContext methodsFor: 'private-process'!
semaphore
	"on this semaphore the context process is waiting for child process to signal finishing its execution and 
	returning a result value"
	semaphore isNil ifTrue: [self initSemaphore].
	^semaphore! !

!WebContext methodsFor: 'private-process'!
semaphore: aSemaphore
	semaphore := aSemaphore! !

!WebContext methodsFor: 'executing'!
serialize: aRequest
	"Serialize execution if some other request is already executing"
	"for now just wait until previous request finish execution"
	[self isBusy ] 
		whileTrue: [(Delay forMilliseconds: 200) wait].! !

!WebContext methodsFor: 'accessing'!
session
	^self app session! !

!WebContext methodsFor: 'private-states'!
setClosed
	"a context is already closed"
	self state:  #closed! !

!WebContext methodsFor: 'private-states'!
setExecutingState
	"a context's process is executing the request"
	self state: #executing! !

!WebContext methodsFor: 'initialize-release'!
setId
	"set a random number and check it for uniquines"
	id := (AIDASite random next * 100000) truncated.
	(self app contexts includesKey: self id) ifTrue: [^self setId]  "repeat until unique"! !

!WebContext methodsFor: 'private-states'!
setIdleState
	"a context's process is in idle state, waiting to get a signal to execute next request"
	self state: #idle! !

!WebContext methodsFor: 'private-states'!
setInterruptedState
	"a context's process is in an interrupted state, waiting for subcontext to finish and close"
	self state: #interrupted! !

!WebContext methodsFor: 'private-states'!
setNoProcessState
	"a context doesn't haveits own process to execute a request"
	self state: #noprocess! !

!WebContext methodsFor: 'private-process'!
signal
	"signal a process to continue"
	self semaphore signal! !

!WebContext methodsFor: 'private-process'!
startProcess
	self process notNil ifTrue: [^nil].
	self process: ([self processLoop] forkAt: self processPriority)! !

!WebContext methodsFor: 'private-states'!
state
	" #noprocess #idle #executing #interrupted "
	state isNil ifTrue: [self setNoProcessState].
	^state! !

!WebContext methodsFor: 'private-states'!
state: aSymbol
	" #noprocess #idle #interrupted "
	state := aSymbol! !

!WebContext methodsFor: 'private-process'!
stopProcess
	self process isNil ifTrue: [^nil].
	self process terminate.
	self process: nil; semaphore: nil.
	self setNoProcessState! !

!WebContext methodsFor: 'accessing'!
view
	"view on which context is executed"
	^self first view! !

!WebContext methodsFor: 'private-process'!
wait
	"a process will be interrupted here until the next signal come"
	self setInterruptedState.
	self initSemaphore. "otherwise it doesn't wait, why?"
	self semaphore wait.
	self setExecutingState.! !

!WebContext methodsFor: 'accessing'!
window
	"a window (or web page) in which this context execute the request"
	window isNil ifTrue: [self initWindow].
	^window! !

!WebContext methodsFor: 'private'!
window: aWebWindow
	"a window (or web page) in which this context execute the request"
	window := aWebWindow! !

!WebContext class methodsFor: 'accessing'!
contextIdName
	"query name for contexts in in URLs: 'aidaCtx=1456' "
	^'aidaCtx'! !

!WebContext class methodsFor: 'instance creation'!
newOn: aContext
	^super new 
		parent: aContext;
		setNoProcessState "an initial state"! !

!WebContextFirst methodsFor: 'accessing'!
app
	"the instance of WebApplication on which this context is executing"
	^self parent! !

!WebContextFirst methodsFor: 'executing'!
close
	"close process if any, and release other things. It also removes itself from context chain"
	super close.! !

!WebContextFirst methodsFor: 'accessing'!
first
	"first context up in the chain. In this case is me"
	^self! !

!WebContextFirst methodsFor: 'initialize-release'!
initMainSemaphore
	mainSemaphore := Semaphore new.! !

!WebContextFirst methodsFor: 'initialize-release'!
initWindow
	window := WebPage new  "as subclass of WebWindow"
		parent: self! !

!WebContextFirst methodsFor: 'testing'!
isFirst
	"is this first/upper context in the chain?"
	^true! !

!WebContextFirst methodsFor: 'accessing'!
level
	"on which level this context is in context chain. First one has level 0"
	^0! !

!WebContextFirst methodsFor: 'private-process'!
mainSemaphore
	"main process is waiting on this semaphire for context's process to signaling back the finishment"
	mainSemaphore isNil ifTrue: [self initMainSemaphore].
	^mainSemaphore! !

!WebContextFirst methodsFor: 'accessing'!
parent: aWebApplication
	parent := aWebApplication! !

!WebContextFirst methodsFor: 'private'!
printString
	^'aWebContextFirst 
	view: ' , self view printString , '
	id: ', self id printString! !

!WebContextFirst methodsFor: 'accessing'!
view
	"view on which context is executed"
	^view! !

!WebContextFirst methodsFor: 'accessing'!
view: aSymbol
	"view on which context is executed. #main is default"
	view := aSymbol isNil 
		ifTrue: [#main] 
		ifFalse: [aSymbol]! !

!WebContextFirst class methodsFor: 'instance creation'!
newOn: aWebApplication
	^super new 
		parent: aWebApplication;
		setNoProcessState "an initial state"! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
addArray: aFirstArray to: aSecondArray

	1 to: aFirstArray size do: [:index |
		aSecondArray
			at: index
			put: (aFirstArray at: index) + (aSecondArray at: index)]! !

!WebCounter methodsFor: 'adding' stamp: ' 21/4/07 22:07'!
addCounter: aWebCounter
	"add counts from specified counter"
	aWebCounter year = self year ifTrue: 
		[self addArray: aWebCounter dailyCounts to: self dailyCounts].
	self addArray: aWebCounter hourlyCounts to: self hourlyCounts.
	self total: self total + aWebCounter total.
	aWebCounter yearlyHistory keysAndValuesDo: [:yr :array |
		self addArray: array to: (self yearlyHistory at: yr ifAbsentPut: [Array new: 366 withAll: 0]) ].

"WebCounter new addCounter: WebCounter new"! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allCountsInYear: aYearNumber

	aYearNumber = self year 
		ifTrue: [^self dailyCounts copy]
		ifFalse: 
			[^(self yearlyHistory 
				at: aYearNumber 
				ifAbsent: [^Array new: 366 withAll: 0]) copy]! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allCountsThatYear
	
	"return array of counts for each day in current year"

	^self allCountsInYear: Date today year! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allHourlyCounts

	^self hourlyCounts copy! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allTodayHourlyCounts

	^self todayHourlyCounts copy! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checkIfNewYear

	(Date today year = (self year + 1)) ifTrue:
		[self yearlyHistory
			at: self year
			put: self dailyCounts.
		self initDailyCounts.
		self year: Date today year].! !

!WebCounter methodsFor: 'counting' stamp: ' 21/4/07 22:07'!
countRequest: aWebRequest

	"register a request by incrementing daily, hourly and total counter."

	self incCounterOnTimestamp: aWebRequest timestamp! !

!WebCounter methodsFor: 'accessing' stamp: 'mivsek 1/10/2008 19:19'!
countsFrom: aStartDate to: anEndDate

	| collection |
	collection := OrderedCollection new.
	aStartDate asDays to: anEndDate asDays do: [:days | 
		collection add: (self countsOnDate: (SpDate fromDays: days))].
	^collection! !

!WebCounter methodsFor: 'accessing' stamp: 'JM 4/26/2007 21:38'!
countsMonthlyFromDate: aDate
	| date collection |
	date := SpDate newDay: 1
		month: aDate monthIndex
		year: aDate year.
	collection := OrderedCollection new.
	[date < SpDate today] whileTrue:
		[collection add: (self countsOnMonth: date monthIndex year: date year).
		date := SpDate newDay: 1
			month: (date + 31) monthIndex
			year: (date + 31) year].
	^collection

"AIDASite default totalCounter countsMonthlyFromDate: Date today - 6"! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
countsMonthlyOnYear: aYear

	^(1 to: 12) collect: [:month | self countsOnMonth: month year: aYear]

"WebServer default totalCounter countsMonthlyOnYear: 1999"! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
countsOnDate: aDate

	| counts |
	counts := self allCountsInYear: aDate year.
	^counts at: aDate day! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
countsOnHour: aNumber

	^self hourlyCounts at: aNumber! !

!WebCounter methodsFor: 'accessing' stamp: 'JM 4/26/2007 21:32'!
countsOnMonth: aMonth year: aYear

	| counts date |
	date := SpDate newDay: 1 month: aMonth year: aYear.
	counts := self allCountsInYear: date year.
	^(date day to: date day + date daysInMonth - 1)
		inject: 0 into: [:sum :dy | sum + (counts at: dy)]

"WebServer default totalCounter countsOnMonth: 10 year: 1999"! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
countsTodayOnHour: aNumber

	^self todayHourlyCounts at: aNumber! !

!WebCounter methodsFor: 'accessing'!
currentWeekCounts
	"counts for every day in current week"
	| firstDay collection |
	firstDay := SpDate today subtractDays: SpDate today weekdayIndex + 1.
	collection := OrderedCollection new.
	firstDay asDays to: firstDay asDays + 6 do: [:days |
		collection add: (self countsOnDate: (SpDate fromDays: days))].
	^collection! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
dailyCounts
	"array of counters for each day in current year. When new year arrives, counters are 
	copied in a yearlyHistory"

	dailyCounts isNil ifTrue: [self initDailyCounts].
	^dailyCounts! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
day
	day isNil ifTrue: [self day: Date today dayOfYear].
	^day! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
day: aNumber
	day := aNumber! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
hourlyCounts
	"array of counters for each hour in a day."

	hourlyCounts isNil ifTrue: [self initHourlyCounts].
	^hourlyCounts! !

!WebCounter methodsFor: 'counting' stamp: 'JM 4/25/2007 21:22'!
incCounter

	"increment daily, hourly and total counter with date and time now"

	self incCounterOnTimestamp: SpTimestamp now! !

!WebCounter methodsFor: 'counting' stamp: ' 21/4/07 22:07'!
incCounterOnTimestamp: aTimestamp

	"increment daily, hourly and total counter with date and time defined"

	
	self incDailyCounterOnDate: aTimestamp asDate.
	self incHourlyCounterOnTimestamp: aTimestamp.
	self incTotal.! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
incDailyCounterOnDate: aDate
	aDate year = self year 
		ifTrue: 
			[self dailyCounts at: aDate day put: (self  dailyCounts at: aDate day) + 1]
		ifFalse:
			[self checkIfNewYear.
			self incHistoryCounterOnDate: aDate].! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
incHistoryCounterOnDate: aDate
	| array |
	aDate year < self year ifTrue: [^self error: 'future years not allowed'].
	array := (self yearlyHistory at: aDate year ifAbsentPut: [Array new: 366 withAll: 0] ).
	array at: aDate day put: (array at: aDate day)+1! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
incHourlyCounterOnTime: aTime
	| hours |
	hours := aTime hours.
	self hourlyCounts at: hours+1 	put: (self  hourlyCounts at: hours+1) + 1.! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
incHourlyCounterOnTimestamp: aTimestamp
	| hours |
	hours := aTimestamp asTime hours.
	self hourlyCounts at: hours+1 put: (self  hourlyCounts at: hours+1) + 1.
	self incTodayHourlyCounterOnTimestamp: aTimestamp! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
incTodayHourlyCounterOnTimestamp: aTimestamp

	| hours dayOfYear |
	dayOfYear := aTimestamp asDate day.
	self day ~= dayOfYear 	ifTrue: 
		[self initTodayHourlyCounts.
		self day: dayOfYear].
	hours := aTimestamp asTime hours.
	self todayHourlyCounts 
		at: hours+1
		put: (self  todayHourlyCounts at: hours+1) + 1.! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
incTotal

	self total: self total + 1.! !

!WebCounter methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initDailyCounts
	dailyCounts := Array new: 366 withAll: 0.
	self year: Date today year.! !

!WebCounter methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initHourlyCounts
	hourlyCounts := Array new: 24 withAll: 0.! !

!WebCounter methodsFor: 'initialize-release' stamp: 'JM 4/25/2007 21:22'!
initStarted
	"set a timestamp to a current time"
	started := SpTimestamp now asSeconds.! !

!WebCounter methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initTodayHourlyCounts

	todayHourlyCounts := Array new: 24 withAll: 0.
	self day: Date today day.! !

!WebCounter methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initTotal

	self total: 0.! !

!WebCounter methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initYearlyHistory
	yearlyHistory := Dictionary new.! !

!WebCounter methodsFor: 'testing' stamp: 'np 10/24/2008 12:57'!
isFirstOnDate: aDate sinceDays: nrOfDays
	"a first/new count since specified nr of days, when there were no counts"
	| since current |
	current := aDate day.
	since := (day - nrOfDays) max: 1. "well what about first 7 days in new year?"
	(self dailyCounts at: current) = 0 ifTrue: [^false].
	since to: current-1 do: [:d | (self dailyCounts at: d) > 0 ifTrue: [^false] ].
	^true! !

!WebCounter methodsFor: 'private'!
printString

	^'aWebCounter total: ', self total printDotString! !

!WebCounter methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
reset

	"set all counters to zero and set started timestamp to now. YOU WILL LOOSE ALL HISTORY
	OF COUNTS !! "

	self initDailyCounts.
	self initHourlyCounts.
	self initTotal.
	self initStarted.! !

!WebCounter methodsFor: 'accessing' stamp: 'janko 10/31/2008 16:05'!
started
	"return a timestamp, from when web visits are counted"

	started isNil ifTrue: [self initStarted].
	^SpTimestamp fromSeconds: started! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
today
	
	"return number of requests today"

	^self countsOnDate: Date today! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
todayHourlyCounts
	"array of counters for each hour today."

	todayHourlyCounts isNil ifTrue: [self initTodayHourlyCounts].
	^todayHourlyCounts! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
todayHourlyCounts: anObject
	todayHourlyCounts := anObject! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
total
	"total number of visits, registered by this counter"

	total isNil ifTrue: [self initTotal].
	^total.! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
total: aNumber
	total := aNumber.! !

!WebCounter methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
weekly
	"total count in current week"
	^self currentWeekCounts inject: 0 into: [:sum :each | sum + each]! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
year
	year isNil ifTrue: [self year: Date today year].
	^year! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
year: aNumber
	year := aNumber.! !

!WebCounter methodsFor: 'private' stamp: ' 21/4/07 22:07'!
yearlyHistory
	yearlyHistory isNil ifTrue: [self initYearlyHistory].
	^yearlyHistory! !

!WebCounter methodsFor: 'accessing' stamp: 'mivsek 1/10/2008 19:19'!
yesterday
	"return number of requests yesterday"
	^self countsOnDate: (SpDate today subtractDays: 1)! !

!WebCounter class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
instVarMap
	"Gemstone odb"

	^super instVarMap,
		#( 	(todayHourlyCounts nil)	)! !

!WebCounter class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new reset! !

!WebCounter class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
replicationSpec
	"Gemstone"
	^super replicationSpec, 
	 	#( 	(started max 2)
			(day replicate)
			(year replicate)
			(dailyCounts max 2)
			(hourlyCounts max 2)
			(total replicate)
			(yearlyHistory stub)	)! !

!WebCounter class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
setupOdbStorage
	"Versant"

	self 
		store: #(started dailyCounts hourlyCounts total )
		as: #(Integer IntegerArray IntegerArray Integer).! !

!WebCounter class methodsFor: 'summing' stamp: ' 21/4/07 22:07'!
sumCounters: aCounterCollection

	"return a new counter with sum of all specified counters"
	| sumCounter |
	sumCounter := WebCounter new.
	aCounterCollection do: [:counter |
		sumCounter addCounter: counter].
	^sumCounter! !

!WebCounter class methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
throughMidnightTest

	Janko := WebCounter new.
	[100 timesRepeat: 
		[Janko incCounter.
		(Delay forSeconds: 1) wait]
	] fork.
	^Janko inspect

"WebCounter throughMidnightTest"! !

!WebCounter class methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
throughNewYearTest

	Janko := WebCounter new.
	[100 timesRepeat: 
		[Janko incCounter.
		(Delay forSeconds: 1) wait]
	] fork.
	^Janko inspect

"WebCounter throughNewYearTest"! !

!WebDateInputField methodsFor: 'private'!
addCalendarSetupScriptOn: aStream
	aStream nextPutAll: '<script type="text/javascript">Calendar.setup({ inputField : "', self inputFieldId, 		'", ifFormat : "', self inputFieldFormat, 
		'", button : "', self buttonId, '"});</script>', self eol! !

!WebDateInputField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
button
	^button! !

!WebDateInputField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
button: aWebButton
	button := aWebButton! !

!WebDateInputField methodsFor: 'private'!
buttonId
	^self button id! !

!WebDateInputField methodsFor: 'private'!
buttonImage
	"from WebStyle calendarButtonGif !! "
	| methodImage |
	methodImage := WebMethodImage
		fromMethod: #calendarButtonGif
		on: self style 
		contentType: 'image/gif' 
		site: self style site.
	^(WebImage image: methodImage)
		title: 'Choose date';
		imageAlign: #middle;
		onMouseOver: 'this.style.cursor=''pointer'' ';
		onMouseOut: 'this.style.cursor=''default'' '! !

!WebDateInputField methodsFor: 'initialize-release'!
initialize
	super initialize.
	self size: 11. 
	self app style ensureJsAndCssForCalendarInHeader.
	self app style ensureJsResourceForCalendarSetup.! !

!WebDateInputField methodsFor: 'private'!
inputFieldFormat
	"the date format"
	^'%e.%m.%Y'  "17.01.1965"! !

!WebDateInputField methodsFor: 'private'!
inputFieldId
	^self id! !

!WebDateInputField methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isDateInputField
	^true! !

!WebDateInputField methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self ensureId.
	self button: self buttonImage. self button registerId.
	super streamHtmlTo: aStream for: aRequest on: aSession.
	self button streamHtmlTo: aStream for: aRequest on: aSession.
	self addCalendarSetupScriptOn: aStream.! !

!WebDelayedField methodsFor: 'accessing' stamp: 'mivsek 6/13/2007 16:16'!
defaultDelay
	"delay before posting, in seconds"
	^1! !

!WebDelayedField methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
delay
	"delay before posting, in seconds"
	delay isNil ifTrue: [self delay: self defaultDelay].
	^delay! !

!WebDelayedField methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
delay: aNumber
	"delay before posting, in seconds"
	delay := aNumber! !

!WebDelayedField methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isDelayedField
	^true! !

!WebDelayedField methodsFor: 'events-ajax'!
onChangePost
	"on key up, not on change we send a #change event with a delay after last event!! "
	self setSingleFieldPost.   "so that field will actually be saved, otherwise change will be just announced"
	self onKeyUp: 
		(self scriptForEvent: #change context: self context). "script with delayed post!!"
	(self eventHandlerFor: #change)
		addAcceptPostedInput! !

!WebDelayedField methodsFor: 'events-ajax'!
onChangePostAndUpdate: anElement with: anArgObject
	"on key up, not on change we send a #change event with a delay after last event!! "
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	self onChangePost.
	(self eventHandlerFor: #change)
		addUpdate: anElement with: anArgObject.! !

!WebDelayedField methodsFor: 'private'!
scriptForEvent: anEventSymbol context: aWebContext
	"send current value of this form element, but with delay after last event"
	^'aidaDelayedEvent(''', anEventSymbol asString, ''',''', 
		(self ensureId; id) asString, ''',''', 
		aWebContext id asString, ''',',
		'this.value,', (self delay*1000) printString, ');'

"	^'aidaEvent(''', anEventSymbol asString, ''',''', 
		(self ensureId; id) asString, ''',''', 
		aWebContext id asString, ''',',
		'this.value);'
"! !

!WebDemo methodsFor: 'accessing'!
asJson
	"to return some JSON content on http://localhost:8888/demo.json"
	^WebJSON stringify: #(12 'Aida' 45)! !

!WebDemo methodsFor: 'accessing' stamp: 'np 3/15/2009 16:00'!
content
	"for Rich Editor demo"
	content isNil ifTrue: [^''].
	^content! !

!WebDemo methodsFor: 'accessing' stamp: 'np 3/15/2009 16:00'!
content: aString
	"for Rich Editor demo"
	^content := aString! !

!WebDemo methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
date
	date isNil ifTrue: [^''].
	^date! !

!WebDemo methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
date: aString
	date := aString! !

!WebDemo methodsFor: 'introduction' stamp: 'janko 7/8/2011 23:35'!
defaultIntroductionText

^'<b>Congratulations!!</b><br><br>
You just started your Aida/Web Smalltalk Web Application Server. Here you can look at few simple <a href=/demo?view=grid><b>demos</b></a> (see navigation bar at the left) and on top left there are links to main website, where you can find more information. <br>
<br>
You are encougared to:
<ul>
<li>look at <a href=http://www.aidaweb.si/screenshots.html><b>Screenshots</b></a> to see, what kind of complex web applications you can build with AIDA/Web,</li>
<li>see <a href=http://www.aidaweb.si/tutorial.html><b>Tutorial</b></a> to build your first web application,</li>
<li>read other <a href=http://www.aidaweb.si/documentation.html><b>Documentation</b></a> to learn more (Architecture, Administrator''s guide, Programer''s guide, Ajax, Advanced features, Articles and presentations and more),</li> 
<li>join the <a href=http://www.aidaweb.si/community.html><b>Community</b></a>.</li>
</ul>
You can also <a href=/admin?view=login><b>login</b></a> with username: <b>admin</b> and password: <b>password</b>. <br><br>

Development team wish you a lot of great moments with Aida/Web !!
'.! !

!WebDemo methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
delayedInput
	delayedInput isNil ifTrue: [^''].
	^delayedInput! !

!WebDemo methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
delayedInput: aString
	delayedInput := aString! !

!WebDemo methodsFor: 'accessing'!
delete
	"for a control flow example"
	deleted := true.! !

!WebDemo methodsFor: 'accessing'!
deleted
	"for a control flow example"
	deleted isNil ifTrue: [self resetDelete].
	^deleted! !

!WebDemo methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
editField
	"for in-place editor demo"
	editField isNil ifTrue: [^'Click me to edit!!'].
	^editField! !

!WebDemo methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
editField: anObject
	editField := anObject! !

!WebDemo methodsFor: 'accessing'!
field1
	^field1! !

!WebDemo methodsFor: 'accessing'!
field1: anObject
	field1 := anObject! !

!WebDemo methodsFor: 'accessing'!
field2
	^field2! !

!WebDemo methodsFor: 'accessing'!
field2: anObject
	field2 := anObject! !

!WebDemo methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
input
	input isNil ifTrue: [^''].
	^input! !

!WebDemo methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
input: aString
	input := aString! !

!WebDemo methodsFor: 'introduction' stamp: 'jm 6/28/2009 11:09'!
introduction
	"introduction text, In instvar to allow changing it by Scribo and other packages at installation"
	introduction isNil ifTrue: [self introduction: self defaultIntroductionText].
	^introduction! !

!WebDemo methodsFor: 'introduction' stamp: 'jm 6/28/2009 11:06'!
introduction: aString
	"introduction text, In instvar to allow changing it by Scribo and other packages at installation"
	introduction := aString.! !

!WebDemo methodsFor: 'accessing'!
preferredUrl
	^'/demos'! !

!WebDemo methodsFor: 'accessing'!
resetDelete
	"for a control flow example"
	deleted := false.! !

!WebDemo methodsFor: 'accessing'!
submitValue
	submitValue isNil ifTrue: [^''].
	^submitValue! !

!WebDemo methodsFor: 'accessing'!
submitValue: aString
	submitValue := aString! !

!WebDemo class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
default
	^AIDASite default demo! !

!WebDemoApp methodsFor: 'actions'!
actionAjaxSomething
	"from #ajaxSubmitExample, just to test Ajax action calling"
	Transcript cr; show: 'Ajax submit'! !

!WebDemoApp methodsFor: 'actions-control flow'!
actionControlFlow
	"just for access rights setup"! !

!WebDemoApp methodsFor: 'actions-control flow'!
actionControlFlowDelete
	"tree-like control flow in action!! "
	(self ask: (WebDialog newConfirm text: 'Delete?') )
		ifTrue: [self observee delete]! !

!WebDemoApp methodsFor: 'actions-control flow'!
actionControlFlowReset
	self observee resetDelete! !

!WebDemoApp methodsFor: 'actions' stamp: 'mivsek 3/7/2008 19:17'!
actionEditMembers
	"just for security to work!!"! !

!WebDemoApp methodsFor: 'actions' stamp: ' 21/4/07 22:07'!
actionEditMembersSave
	self redirectToView: #gridSelected! !

!WebDemoApp methodsFor: 'actions' stamp: 'janko 8/1/2008 20:44'!
actionFileUpload
	self fileStream notNil ifTrue:
		[self fileStream close]. "while content were already streamed to the file before"! !

!WebDemoApp methodsFor: 'actions' stamp: 'mivsek 3/7/2008 19:16'!
actionGridSelected
	"just for security to work!!"! !

!WebDemoApp methodsFor: 'actions' stamp: ' 21/4/07 22:07'!
actionGridSelectedEditMembers
	self redirectToView: #editMembers! !

!WebDemoApp methodsFor: 'actions' stamp: ' 21/4/07 22:07'!
actionWebdav
	| stream file |
	file := self webdavExampleFilename asFilename. file exists ifTrue: [file delete].
	[stream :=  file appendStream. stream binary. 
	stream nextPutAll: self observee file asByteArray] 
		ensure: [self observee file: nil. stream close].! !

!WebDemoApp methodsFor: 'actions'!
actionrichEditor
	"just to enable setup of access rights"! !

!WebDemoApp methodsFor: 'views'!
addWebDAVVBScript
	"to open directly from web and not copy a document in local cache"
	self context page scriptBefore: '
 <SCRIPT LANGUAGE=VBScript>
   Function OpenDoc(strLocation)
   Dim objWord
      Set objWord = CreateObject("Word.Application")
      objWord.Visible = true
      objWord.Documents.Open strLocation
   End Function
 </SCRIPT>
'! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxAutocompleteExampleTo: e
	| field1 field2 result |
	e cell colspan: 2; addTextH4: 'Example: Autocomplete field with data from server'. e newRow.
	e cell valign: #top; addTextSmall: 'Type first chars of month names to select: '; addBreak.
	field1 := WebAutocompleteField 
		aspect: #field1 for: self observee choicesAspect: #monthsStarting: for: self.
	e cell add: field1.
	e newCell addTextSmall: 'Again, the choice will be posted instantly: '. e cell addBreak.
	result := self ajaxAutocompleteResult.
	field2 := WebAutocompleteField 
		aspect: #field2 for: self observee choicesAspect: #monthsStarting: for: self.
	field2 afterPostAndUpdate: result.
	e cell add: field2. e cell addBreak.
	e cell add: result.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxAutocompleteResult
	| e |
	e := WebElement new.
	e addTextBold: self observee field2.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxDelayedFieldElement
	| e |
	e := WebElement new.
	e addTextBold: self observee delayedInput.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxInPlaceEditorExample
	| e |
	e := WebElement new.
	e addTextH4: 'Example: In-place editor example'.
	e addText: 'Click text below to edit it'. e addBreak.
"	e addInPlaceEditableTextAspect: #editField for: self observee." "that's shorter way"
	e add: ((WebInPlaceEditableText aspect: #editField for: self observee)
		triggerElement: ((WebImage gif: #buttonEditGif) title: 'Edit this text') ). "image to enter edit"
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxLiveAndDelayedFieldExample
	| e element1 input1 element2 input2 |
	e := WebElement new. e table width: 1. "100%"
	e cell colspan: 2; addTextH4: 'Example: Live and Delayed input send to server'. e newRow.
	element1 := self ajaxLiveFieldElement.
	input1 := WebInputField aspect: #input for: self observee.
	input1 onKeyUpPostAndUpdate: element1.
	e cell width: 0.5; add: input1; addBreak; add: element1.
	element2 := self ajaxDelayedFieldElement.
	input2 := WebDelayedField aspect: #delayedInput for: self observee.
	input2 afterPostUpdate: element2.
	e newCell add: input2; addBreak; add: element2.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxLiveAndDelayedFieldExampleTo: e
	| element1 input1 element2 input2 |
	e cell colspan: 2; addTextH4: 'Example: Live and Delayed input send to server'. e newRow.
	element1 := self ajaxLiveFieldElement.
	input1 := WebInputField aspect: #input for: self observee.
	input1 onKeyUpPostAndUpdate: element1.
	e cell width: 0.5; add: input1; addBreak; add: element1.
	element2 := self ajaxDelayedFieldElement.
	input2 := WebDelayedField aspect: #delayedInput for: self observee.
	input2 onChangePostAndUpdate: element2.
	e newCell add: input2; addBreak; add: element2.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxLiveFieldElement
	| e |
	e := WebElement new.
	e addTextBold: self observee input.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxPeriodicUpdaterExample
	| e element |
	e := WebElement new.
	e addTextH4: 'Periodicaly update element from server'.
	element := self ajaxTimeElement.
	element updateEverySeconds: 1.
	e add: element.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxPopupDialogExample
	| e |
	e := WebElement new.
	e addTextH4: 'Popup info dialog'.
	(e addNilLinkText: 'Click me for popup')
		onClickPopup: (WebDialog newInfo text: 'Just hello!!').
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxPopupWindowExample
	| e |
	e := WebElement new.
	e addTextH4: 'Example: Popup window with Ajax content from server'.
	(e addNilLinkText: 'Click me for popup')
		onClickPopup: self ajaxPopupWindowLive.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxPopupWindowLive
	| e |
	e := WebElement new.
	self context event isClassicalRequest ifTrue: [^e]. "because this method is also called while building 
		 										    main page in #ajaxPopupWindowExample"
	e addTextH1: 'Popup window with live content from server'. e addBreak.
	e addText: 'Timestamp now: ',  SpTimestamp now printString; addBreak; addBreak.
	(e addNilLinkText: 'popup one more')
		onClickPopup: self ajaxPopupWindowLive2 thenUpdate: e. "to refresh time"
	e addText: ' | '.
	e addCloseLinkText: 'close'.   "closing link, via Ajax closes also the window and context on the server"
	^e! !

!WebDemoApp methodsFor: 'views-ajax' stamp: 'janko 11/1/2011 13:07'!
ajaxPopupWindowLive2
	| e |
	e := WebElement new.
	e addText: SpTimestamp now printString; addBreak.
	e addCloseLinkText: 'close'.   "closing link"
	e addText: ' or '.
	(e addButtonText: 'Close')
		onSubmitClose.
	^e! !

!WebDemoApp methodsFor: 'views-ajax' stamp: 'janko 10/26/2011 22:41'!
ajaxSubmitExample
	| e |
	e := WebElement new.
	e addTextH4: 'Example: Ajax form submit to the server'.
	e addInputFieldAspect: #submitValue for: self observee. e addSpace.
	(e addButtonText: 'Ajax submit' action: #something) "will call also call #actionAjaxSomething"
		onSubmitUpdate: e.
	e addBreak; addTextBold: self observee submitValue.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxTimeElement
	| e |
	e := WebElement newSpan.
	e style: '{background-color: #eee }'.
	e addTextBold: SpDate today shortPrintSloString, ' ', SpTimestamp now asTime printSecSloString. 
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxUpdateTimeExample
	| e element |
	e := WebElement new.
	e addTextH4: 'Example: Update element from server'.
	element := self ajaxTimeElement.
	e add: element; addBreak.
	(e addNilLinkText: 'Click me to update')
		onClickUpdate: element.
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxValidationExample
	| e field |
	e := WebElement new. e table width: 220.
	e cell colspan:2; addTextH4: 'Instant validation example'. e newRow.
	e cell width: 160; addText: 'Today''s year is: '.
	field := e cell addInputFieldAspect: #year for: self size: 4.
	field 
		onChangePost;
		validIfTrue: [:value | value isEmpty"temporary!!" or: [value asInteger = Date today year]];
		errorText: 'Wrong!!'.
	e newCell add: field errorElement. "this element will show error text in red near input field, if year is wrong"
	^e! !

!WebDemoApp methodsFor: 'views-ajax'!
ajaxVerificationExample
	| e field |
	e := WebElement new.
	e addTextH4: 'Example: instant verification example'.
	e addText: 'Today''s year is: '. e addBreak.
	field := e addInputFieldAspect: #year for: self.
	field 
		onChangePost;
		validIfTrue: [:value | value asInteger = Date today year];
		errorText: 'Wrong!!'.
	e add: field errorElement. "this element will show error text in red near input field, if year is wrong"
	^e! !

!WebDemoApp methodsFor: 'views-grid'!
classesEditElement
	| e |
	e := WebElement new.
	e addButtonText: 'Save' action: #save.
	e add: (WebGrid new
		columnNames: #('' 'Class name');
		columnAspects: #(nil #name);
		sortOn: 2;
		collection: WebApplication allWebAppClasses;
		checkboxesColumn: 1 collection: self selectedClasses;
		yourself).
	^e! !

!WebDemoApp methodsFor: 'views-grid'!
classesSelectedElement
	| e |
	e := WebElement new.
	e addButtonText: 'Select classes' action: #editMembers.
	e add: (WebGrid new
		columnNames: #('nr.' 'Class name');
		columnAspects: #(nil #name);
		setNumbering; sortOn: 2;
		collection: self selectedClasses;
		yourself).
	^e! !

!WebDemoApp methodsFor: 'views-grid'!
classesTableElement
	| e |
	e := WebElement new.
	e add: (WebGrid new
		columnNames: #('nr.' 'Class name');
		columnFilters: #(nil true);
		columnAspects: #(nil #name);
		setNumbering; sortOn: 2;
		collection: WebApplication allWebAppClasses;
		yourself).
	^e! !

!WebDemoApp methodsFor: 'accessing' stamp: 'janko 8/1/2008 21:13'!
fileContentType
	^fileContentType! !

!WebDemoApp methodsFor: 'accessing' stamp: 'janko 8/1/2008 21:14'!
fileContentType: aString
	fileContentType := aString! !

!WebDemoApp methodsFor: 'accessing' stamp: 'janko 8/1/2008 20:09'!
fileStream
	"for file upload"
	^fileStream! !

!WebDemoApp methodsFor: 'accessing' stamp: 'janko 8/1/2008 20:09'!
fileStream: aFileStream
	"for file upload"
	fileStream := aFileStream! !

!WebDemoApp methodsFor: 'accessing' stamp: 'janko 8/1/2008 21:12'!
filename
	filename isNil ifTrue: [^''].
	^filename! !

!WebDemoApp methodsFor: 'accessing' stamp: 'janko 8/1/2008 21:13'!
filename: aString
	filename := aString! !

!WebDemoApp methodsFor: 'views-control flow'!
flowConfirmDeleteExample
	"see #actionControlFlowDelete for actual control flow example"
	| e |
	e := WebElement new.
	e addTextH4: 'Example: Delete with confirmation dialog'.
	self observee deleted not
		ifTrue: 
			[(e addButtonText: 'Delete' action: #delete) "then see #actionControlFlowDelete !! "
			"	onSubmitUpdate: e"]  "later!!"
		ifFalse: 
			[e addTextBold: 'Deleted!!'; addSpace; addButtonText: 'Reset delete' action: #reset].
	^e! !

!WebDemoApp methodsFor: 'views-grid'!
gridTabsElement
 	^ViewTabs new
		addView: #grid description: 'All App classes';
		addView: #gridSelected description: 'Selected App classes';
		yourself.! !

!WebDemoApp methodsFor: 'views'!
introductionElement
	| e |
	e := WebElement new.
	e addText: self observee introduction. "see WebDemo>>defaultIntroductionText for initial content"
	^e! !

!WebDemoApp methodsFor: 'views-jquery'!
jQueryAutocompleteExampleTo: e
	| field1 |
	e cell colspan: 2; addTextH4: 'Example: jQuery Autocomplete field with data from server'. e newRow.
	e cell valign: #top; addTextSmall: 'Type first chars of month names to select: '; addBreak.
	field1 := WebAutocomplete2Field 
		aspect: #field1 for: self observee choicesAspect: #monthsStarting: for: self.
	e cell add: field1.
	^e! !

!WebDemoApp methodsFor: 'views-jquery'!
jQueryEditableExampleTo: e
	e cell colspan: 2; addTextH4: 'Example: jQuery in-place editable field with data from server'. e newRow.
	e addText: 'Click text below to edit it'. e addBreak.
"	e addInPlaceEditableTextAspect: #editField for: self observee." "that's shorter way"
	e add: ((WebInPlaceEditable2Text aspect: #editField for: self observee)
		triggerElement: ((WebImage gif: #buttonEditGif) title: 'Edit this text') ). "image to enter edit"
	^e! !

!WebDemoApp methodsFor: 'views-javascript'!
jsShowAlertExample
	| e |
	e := WebElement new.
	e addTextH4: 'Example 1: onClick event on some text'. e addBreak.
	e add: 
		((WebText text: 'click on me to show alert!!') onClick: 'alert(''This is an alert!!'')'). 
	^e.! !

!WebDemoApp methodsFor: 'views-javascript'!
jsShowHideToggleExample
	| e element |
	e := WebElement new.
	e addTextH4: 'Example 2: show/hide an element with a click'.
	element := WebElement new addText: 'This element is now shown'; style: '{background-color: #ccc }'.
	element hide.  "hide from the start"
	e 
		add: ((WebText text: 'show') onClickShow: element); addSpace;
		add: ((WebText text: 'hide') onClickHide: element); addSpace;
		add: ((WebText text: 'toggle') onClickToggle: element); addSpace;
	 	add: element.
	^e! !

!WebDemoApp methodsFor: 'views-javascript'!
jsShowWithMouseOverExample
	| e element |
	e := WebElement new.
	e addTextH4: 'Example 3: show/hide an element with mouse over'.
	element := WebElement new addText: 'This element is now shown'; style: '{background-color: #ccc }'.
	element hide.  "hide from the start"
	e 
		add: ((WebText text: 'mouse over to show') 
			onMouseOverShow: element; onMouseOutHide: element); addSpace;
	 	add: element.
	^e! !

!WebDemoApp methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
liveImage
	^liveImage! !

!WebDemoApp methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
liveImage: aWebLiveImage
	liveImage := aWebLiveImage! !

!WebDemoApp methodsFor: 'views-ajax'!
monthsStarting: aString
	"as choicesAspect for autocompletion demo"
	"WebDemoApp new monthsStarting: 'j' "
	| months |
	months := 
		#('januar' 'prosinec' 'sijec^anj' 'January' 
		   'februar', 'svec^an' 'veljac^a' 'February'
		   'marec', 'sus^ec' 'oz^ujak' 'Mart'
		   'april', 'mali traven' 'travanj' 'April'
		   'maj', 'veliki traven' 'svibanj' 'May'
		   'junij', 'roz^nik' 'lipanj' 'June'
		   'julij', 'mali srpen' 'srpanj' 'July'
		   'avgust', 'veliki srpen' 'kolovoz' 'August'
		   'september', 'kimavec' 'rujan' 'September'
		   'oktober', 'vinotok' 'listopad' 'October'
		   'november', 'listopad' 'studeni' 'November'
		   'december', 'gruden' 'prosinac' 'December').
	^months select: [:each | aString, '*' match: each]! !

!WebDemoApp methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
selectedClasses
	selectedClasses isNil ifTrue: [self selectedClasses: OrderedCollection new].
	^selectedClasses! !

!WebDemoApp methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
selectedClasses: anObject
	selectedClasses := anObject! !

!WebDemoApp methodsFor: 'accessing' stamp: 'janko 8/1/2008 20:12'!
setStartStamp
	"start timestamp of some action"
	^startStamp := SpTimestamp now! !

!WebDemoApp methodsFor: 'accessing' stamp: 'janko 8/1/2008 20:12'!
startStamp
	"start timestamp of some action"
	^startStamp! !

!WebDemoApp methodsFor: 'views-upload'!
uploadReportAndResetElement
	"report if anything then delete file and reset variables"
	| e elapsed fileSize |
	e := WebElement new.
	self filename isEmpty ifTrue: [^e].
	elapsed := SpTimestamp now asSeconds - self startStamp asSeconds.
	fileSize := (SpFilename named: self filename) fileSize.
	e addText: 'uploaded file: ', self filename, ' size: ', fileSize printDotString, ' bytes in ', 
		elapsed printDotString, ' seconds (', ((fileSize/(elapsed max: 1)) rounded) printDotString, 'bytes/s)'.
	(SpFilename named: self filename) delete.
	self filename: ''. self fileStream: nil.
	^e! !

!WebDemoApp methodsFor: 'views'!
viewAjax
	| e |
	e := WebElement new. e table width: 1. "100%"
	e cell colspan: 2; addTextH1: 'Simple AJAX examples'. e newRow. 
	e cell addText: 'See the code in method #viewAjax from WebDemoApp'. e newRow.
	e cell width: 0.6; valign: #top; add: self ajaxUpdateTimeExample. 
"	e newCell width: 0.4; valign: #top; add: self ajaxPeriodicUpdaterExample.  " e newRow. 
	self ajaxLiveAndDelayedFieldExampleTo: e. e newRow.
	self ajaxAutocompleteExampleTo: e. e newRow.
	e cell add: self ajaxInPlaceEditorExample. e newRow.
	e cell valign: #top; add: self ajaxPopupWindowExample.
	e newCell valign: #top; add: self ajaxPopupDialogExample. e newRow.
	e cell valign: #top; add: self ajaxSubmitExample. 
	e newCell valign: #top; add: self ajaxValidationExample. e newRow.
	self style pageFrameWith: e title: 'AJAX examples'! !

!WebDemoApp methodsFor: 'views'!
viewCalendar
	| e |
	e := WebElement new.
	e addTextH1: #en->'Date input with Javascript Calendar example'.	 e addBreak.
	e addDateInputFieldAspect: #date for: self observee. e addBreak.
	self style pageFrameWith: e title: 'Calendar example'! !

!WebDemoApp methodsFor: 'views'!
viewControlFlow
	| e |
	e := WebElement new.
	e cell addTextH1: 'Tree-like control flow examples'. e newRow. e newRow.
	e add: self flowConfirmDeleteExample.
	self style pageFrameWith: e title: 'Control flow examples'! !

!WebDemoApp methodsFor: 'views-grid'!
viewEditMembers
	| e |
	e := WebElement new.
	e cell addTextH1: 'WebGrid, tabs, live filtering, Ajax sorting, checkboxes...'. e newRow.
	e cell add: self classesEditElement.
	self style pageFrameWith: e title: 'Grid example'! !

!WebDemoApp methodsFor: 'views-upload'!
viewFileUpload
	| e field fname |
	e := WebElement new.
	e cell addTextH1: 'File upload example'. e newRow. e newRow.
	field := WebFileInputField 
		beforeStreamingDo: [:datum |  "datum is actually MIME part"
			fname := datum filename trimBlanks. 
			fname notEmpty ifTrue:
				[self fileStream: (SpFilename named: fname) writeStream. "will be closed in action method"
				self fileStream binary.
				datum writeStream: self fileStream.
				self setStartStamp ] ]    "for measuring upload time"
		filenameAspect: #filename 
		contentTypeAspect: #fileContentType 
		forObject: self.
	e cell add: field; addButtonText: 'Upload'. e newRow.
	e cell add: self uploadReportAndResetElement. "also deletes uploaded file!!"
	self style pageFrameWith: e title: 'File upload example'! !

!WebDemoApp methodsFor: 'views-grid'!
viewGrid
	| e |
	e := WebElement new.
	e cell addTextH1: 'WebGrid, tabs, live filtering, Ajax sorting, checkboxes...'. e newRow.
	e cell addText: 'See the code in method #viewGrid from WebDemoApp'. e newRow.
	e cell add: self gridTabsElement. e newRow.
	e cell add: self classesTableElement.
	self style pageFrameWith: e title: 'Grid example'! !

!WebDemoApp methodsFor: 'views-grid'!
viewGridSelected
	| e |
	e := WebElement new.
	e cell addTextH1: 'WebGrid, tabs, live filtering, Ajax sorting, checkboxes...'. e newRow.
	e cell add: self gridTabsElement. e newRow.
	e cell add: self classesSelectedElement.
	self style pageFrameWith: e title: 'Grid example'! !

!WebDemoApp methodsFor: 'views'!
viewImageGallery
	| e |
	e := WebElement new.
	e addText: 'This is a collection of so called <b>method images</b>, that is: images embeded in methods in class <b>WebStyle</b> or its subclasses.'.

	"filetype icons"
	e cell cell addGif: #pdfSmallGif. e cell newCell addText: 'pdfSmallGif'. e cell newRow.
	e cell cell addGif: #pdfMediumGif. e cell newCell addText: 'pdfMediumGif'. e cell newRow.
	e cell cell addGif: #pdfBigGif. e cell newCell addText: 'pdfBigGif'. e cell newRow.
	e cell cell addGif: #wordBigGif. e cell newCell addText: 'wordBigGif'. e cell newRow.
	e cell cell addGif: #excelBigGif. e cell newCell addText: 'excelBigGif'. e cell newRow.
	e cell cell addGif: #xmlBigGif. e cell newCell addText: 'xmlBigGif'. e cell newRow.
	e newCell.

	"filetype icons"
	e cell cell addGif: #arrowBigBlueGif. e cell newCell addText: 'arrowBigBlueGif'. e cell newRow.
	e cell cell addGif: #arrowBigRedGif. e cell newCell addText: 'arrowBigRedGif'. e cell newRow.
	e cell cell addGif: #arrowBigYellowGif. e cell newCell addText: 'arrowBigYellowGif'. e cell newRow.
	e cell cell addGif: #arrowDownBigRedGif. e cell newCell addText: 'arrowDownBigRedGif'. e cell newRow.
	e cell cell addGif: #arrowSmallBlackGif. e cell newCell addText: 'arrowSmallBlackGif'. e cell newRow.
	e cell cell addGif: #arrowTriangleRedGif. e cell newCell addText: 'arrowTriangleRedGif'. e cell newRow.
	e cell cell addGif: #arrowTriangleYellowGif. e cell newCell addText: 'arrowTriangleYellowGif'. e cell newRow.
	e cell cell addGif: #arrowCircledRedGif. e cell newCell addText: 'arrowCircledRedGif'. e cell newRow.
	e cell cell addGif: #arrowCircledGreyGif. e cell newCell addText: 'arrowCircledGreyGif'. e cell newRow.
	e newRow.

	e cell cell addPDFLinkTo: 'http://wiki.eranova.si/e-logis/DOWNLOAD/EAN-standards-roadmap.pdf'.
	e cell newCell addText: 'addPDFLinkTo: '.
	self style pageFrameWith: e title: 'Gallery of embedded images'! !

!WebDemoApp methodsFor: 'views-javascript'!
viewJavascript
	| e |
	e := WebElement new.
	e cell addTextH1: 'Simple Javascript examples'. e newRow. e newRow.
	e cell addText: 'See the code in method #viewJavascript from WebDemoApp'. e newRow.
	e cell add: self jsShowAlertExample. e newRow.
	e cell add: self jsShowHideToggleExample. e newRow.
	e cell add: self jsShowWithMouseOverExample. e newRow. 
	self style pageFrameWith: e title: 'Javascript examples'! !

!WebDemoApp methodsFor: 'views'!
viewJquery
	| e |
	e := WebElement new. e table width: 1. "100%"
	e cell colspan: 2; addTextH1: 'Simple jQuery examples'. e newRow. 
	self jQueryAutocompleteExampleTo: e. e newRow.
	self jQueryEditableExampleTo: e. e newRow.
	self style pageFrameWith: e title: 'AJAX examples'! !

!WebDemoApp methodsFor: 'views'!
viewLiveImage
	| e |
	self liveImage isNil ifTrue: [self liveImage: WebGraph new].  "subclass WebLiveImage"
	e := WebElement new.
	e addTextH1: 'Live image example'. e addBreak.
	e addImage: self liveImage.
	self style pageFrameWith: e title: 'Live image example'! !

!WebDemoApp methodsFor: 'views'!
viewMain
	| e |
	e := WebElement new.
	e addTextH1: 'Introduction'. e addBreak.
	e add: self introductionElement.
	self style pageFrameWith: e title: 'Aida/Web - Introduction'! !

!WebDemoApp methodsFor: 'views'!
viewRichEditor
	| e |
	e := WebElement new.
	e addTextH1: 'JavaScript HTML WYSIWYG Editor example'.	 e addBreak.
	e addRichEditorAspect: #content for: self observee size: 50@10. e addBreak.
	e addButtonText: 'Save'. e addBreak.
	e addTextH2: 'Result: '. e addBreak.
	e addText: self observee content.
	self style pageFrameWith: e title: 'Rich Editor example'! !

!WebDemoApp methodsFor: 'views'!
viewWebdav
	| e link |
	"link := '/', self webdavExampleFilename."
	link := self site uriPattern first currentUrl, '/', self webdavExampleFilename.
	self addWebDAVVBScript. "IE only!!"
	link := 'javascript:OpenDoc(''', link, ''')'. "for IE browser only!!"
	e := WebElement new. self title: 'WebDAV publishing example'.
	e cell addTextH2: self title. e newRow. e cell addNbSp. e newRow.
	e cell addText: '1. Upload  MS Word document: '.
	e cell add: (WebFileInputField aspect: #file filenameAspect: #filename 
		contentTypeAspect: #fileContentType forObject: self observee). 
	e cell addSpace; addButtonText: 'Upload'. e newRow.
	e cell addText: '2. Now open document from: '. e cell addLinkTo: link text: 'here'. e newRow.
	e cell addText: '3. Save document'. e newRow.
	e cell addText: '4. Repeat from 2 to see if changes got saved'. e newRow.
	self style pageFrameWith: e title: self title.! !

!WebDemoApp methodsFor: 'views' stamp: 'janko 10/28/2011 15:28'!
viewWidgets
	| e |
	e := WebElement new. e table width: 1. "100%"
	e cell colspan: 2; addTextH1: 'Widget examples'. e newRow. 
	e cell addText: 'See the code in method #viewWidgets from WebDemoApp'. e newRow.
	e cell width: 0.6; valign: #top; add: self widgetEmbeddedExample.  e newRow.
	e cell add: self widgetComposedExample.  e newRow.
	e cell add: self widgetPopupExample. 
	self style pageFrameWith: e title: 'Widget examples'! !

!WebDemoApp methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
webdavExampleFilename
	^'aida-webdav-example.doc'.! !

!WebDemoApp methodsFor: 'views-widgets' stamp: 'janko 10/28/2011 18:49'!
widgetComposedExample
	| e |
	e := WebElement new.
	e addTextH4: 'Example: Widget composed of two widgets'.
	e add: WebDemoWidget2 new.
	^e! !

!WebDemoApp methodsFor: 'views-widgets' stamp: 'janko 10/26/2011 22:41'!
widgetEmbeddedExample
	| e |
	e := WebElement new.
	e addTextH4: 'Example: Widget embeded on the page'.
	e add: WebDemoWidget new.
	^e! !

!WebDemoApp methodsFor: 'views-widgets'!
widgetPopupExample
	| e |
	e := WebElement new.
	e addTextH4: 'Example: Widget popup example'.
	e addTextSmall: 'Updated: ', Time now printString. e addBreak.
	(e addNilLinkText: 'Click to popup')
		onClickPopup: WebDemoWidget new.
	e addText: ' | '.
	(e addNilLinkText: 'Popup then update')
		onClickPopup: WebDemoWidget new thenUpdate: e.
	e addText: ' | '.
	(e addNilLinkText: 'Click to popup composed widget')
		onClickPopup: WebDemoWidget2 new.

	^e! !

!WebDemoApp methodsFor: 'accessing'!
year
	"used in #ajaxValidationExample"
	year isNil ifTrue: [^''].
	^year! !

!WebDemoApp methodsFor: 'accessing'!
year: aString
	"used in #ajaxValidationExample"
	year := aString! !

!WebDemoWidget methodsFor: 'views'!
build
	| field |
	self addTextSmall: 'Widget created: ', Time now printString. self addBreak.
	self addText: 'Password check'. 
	self cell valign: #top; addText: 'Username: '.
	field := (self newCell addInputFieldAspect: #username for: self)
		onChangePost;
		validIfTrue: [:value | self site securityManager existUserNamed: value];
		errorText: 'This username does not exist!!'.
	self cell addBreak; add: field errorElement. 
	self newRow. self cell addText: 'Password: '.
	self newCell addInputFieldAspect: #password for: self.
	self newRow.
	(self addButtonText: 'Check')
		onSubmitDo: [self checkAndSetResult. self update];
		onSubmitClose.  "just for popups, ignored elsewhere"
	(self addSpace; addNilLinkText: 'Refresh time')
		onClickDo: [self update].
	self addSpace; addTextBold: self result! !

!WebDemoWidget methodsFor: 'actions' stamp: 'janko 10/28/2011 12:01'!
checkAndSetResult
	"check userna and password"
	(self site securityManager existUserNamed: self username withPassword: self password)
		ifTrue: [self result: 'Correct!!']
		ifFalse: [self result: 'Wrong!!']! !

!WebDemoWidget methodsFor: 'accessing' stamp: 'janko 10/27/2011 14:06'!
password
	^ password! !

!WebDemoWidget methodsFor: 'accessing' stamp: 'janko 10/27/2011 14:06'!
password: aString
	password := aString! !

!WebDemoWidget methodsFor: 'accessing' stamp: 'janko 10/27/2011 19:20'!
result
	result ifNil: [^''].
	^ result
! !

!WebDemoWidget methodsFor: 'accessing' stamp: 'janko 10/27/2011 19:20'!
result: aString
	result := aString
! !

!WebDemoWidget methodsFor: 'accessing' stamp: 'janko 10/27/2011 14:05'!
username
	^ username! !

!WebDemoWidget methodsFor: 'accessing' stamp: 'janko 10/27/2011 14:06'!
username: aString
	username := aString! !

!WebDemoWidget2 methodsFor: 'views'!
build
	"compose a widget from two subwidgets"
	self cell add: WebDemoWidget new.
	self newCell add: WebDemoWidget new.! !

!WebDialog methodsFor: 'printing' stamp: 'janko 11/1/2011 13:05'!
build
	self class: #dialog.
	self isConfirmation ifTrue: [self buildConfirmation].
	self isInfo ifTrue: [self buildInfo].! !

!WebDialog methodsFor: 'printing'!
buildConfirmation
	self addText: self text.
	self addBreak; addBreak.
	(self addButtonText: 'YES')
		class: #'dialog-button';
		onSubmitAnswer: true;
		onSubmitClose.
	self addSpace.
	(self addButtonText: 'NO')
		class: #'dialog-button';
		onSubmitAnswer: false;
		onSubmitClose.! !

!WebDialog methodsFor: 'printing'!
buildInfo
	self addText: self text.
	self addBreak; addBreak.
	(self addButtonText: 'Close')
		onSubmitClose.! !

!WebDialog methodsFor: 'testing'!
isConfirmation
	^self type = #confirmation! !

!WebDialog methodsFor: 'testing'!
isInfo
	^self type = #information! !

!WebDialog methodsFor: 'accessing'!
text
	"text to be written on a dialog, like a confirmation question"
	text isNil ifTrue: [^''].
	^text! !

!WebDialog methodsFor: 'accessing'!
text: aString
	"text to be written on a dialog, like a confirmation question"
	text := aString.! !

!WebDialog methodsFor: 'private'!
type
	"#confirmation etc."
	^type! !

!WebDialog methodsFor: 'private'!
type: aSymbol
	type := aSymbol! !

!WebDialog class methodsFor: 'instance creation'!
newConfirm
	"confirm something with YES or NO button"
	^super new
		type: #confirmation;
		build.! !

!WebDialog class methodsFor: 'instance creation'!
newInfo
	"just show some information and close button"
	^super new
		type: #information;
		build.! !

!WebElement methodsFor: 'events-effects&dragdrop'!
acceptDropsTo: aCollectionOfElements
	| script |
	"Scriptaculous specific"
	self ensureId.
	ScriptaculousLibrary ensureScriptaculous.
	script := '// <!![CDATA[ 
		Sortable.create("', self id asString,'"'.
	(self isKindOf: WebList) ifFalse: [
		self setDiv.
		script := script,  'tag: "div", '].
	script := script, ',{dropOnEmpty: true,constraint: false, containment: ['.
	aCollectionOfElements do: [:each |
		each ensureId.
		script := script, each id, ','].
	script := script,']});
	// ]]>'.
	self parent scriptAfter: script! !

!WebElement methodsFor: 'private-subelements'!
add: aWebElement
	"Include new element as one of the receiver's elements.  Answer aWebElement.
	If you nest a web page into another web page, then add only elements of it"
	self checkAndInitElements.  "if not composite element, then error"
	"if nested web pages then add elements without header"
	(aWebElement isKindOf: WebApplication) ifTrue: [^self halt].
	((aWebElement isKindOf: WebPage) and: [self isKindOf: WebPage])
		ifTrue: [^elements add: aWebElement elements].
	aWebElement parent: self.
	elements add: aWebElement.
	aWebElement postAddAction. "now the element is added to the parent, it can do some more actions"
	^aWebElement! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addAnchorName: aString
	^self add: (WebAnchor name: aString)! !

!WebElement methodsFor: 'adding form elements'!
addAspect: aSymbol for: anObject input: aBoolean size: aSizeNumberOrPoint
	"adds an auto converted text of aspect for that object. If imput argument is true, then add 
	an input field or text area, depending in size (eg. size: 5 or size: 5@5)"
	aBoolean
		ifFalse: 
			[^self addText: (WebFormElement autoConvertToString: (anObject perform: aSymbol))]
		ifTrue:
			[(aSizeNumberOrPoint isKindOf: Number) 	ifTrue: 
				[^self add: (WebInputField new
							size: aSizeNumberOrPoint;
							aspect: aSymbol for: anObject)].
			(aSizeNumberOrPoint isKindOf: Point) ifTrue: 
				[^self add: (WebTextArea new
							size: aSizeNumberOrPoint;
							aspect: aSymbol for: anObject)] 
			].! !

!WebElement methodsFor: 'adding other elements' stamp: ' 21/8/07 09:38'!
addBreak
	^self add: (WebSeparator break).! !

!WebElement methodsFor: 'adding form buttons'!
addButtonGif: anImageSymbol
	"add a button as an image"
	^self add: (WebButton image: (WebImage gif: anImageSymbol))! !

!WebElement methodsFor: 'adding form buttons'!
addButtonGif: anImageSymbol action: aSymbol
	"add a button as an image"
	^self add: (WebButton image: (WebImage gif: anImageSymbol) action: aSymbol)! !

!WebElement methodsFor: 'adding form buttons'!
addButtonJpeg: anImageSymbol
	"add a button as an image"
	^self add: (WebButton image: (WebImage jpeg: anImageSymbol))! !

!WebElement methodsFor: 'adding form buttons'!
addButtonJpeg: anImageSymbol action: aSymbol
	"add a button as an image"
	^self add: (WebButton image: (WebImage jpeg: anImageSymbol) action: aSymbol)! !

!WebElement methodsFor: 'adding form buttons'!
addButtonPng: anImageSymbol
	"add a button as an image"
	^self add: (WebButton image: (WebImage jpeg: anImageSymbol))! !

!WebElement methodsFor: 'adding form buttons'!
addButtonPng: anImageSymbol action: aSymbol
	"add a button as an image"
	^self add: (WebButton image: (WebImage png: anImageSymbol) action: aSymbol)! !

!WebElement methodsFor: 'adding form buttons'!
addButtonText: aString
	^self add: (WebButton text: aString)! !

!WebElement methodsFor: 'adding form buttons'!
addButtonText: aString action: aSymbol
	"for more than one buttons. Action method is a composed name from 'action', aView, Symbol.
	example: for view #main, action #addFolder is action method #actionMainAddFolder"
	^self add: (WebButton text: aString action: aSymbol)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addCheckboxAspect: aSymbol for: anObject
	"aspect method will be called and true/false will be set/clear on an object"
	^self add: (WebCheckBox aspect:  aSymbol for: anObject)! !

!WebElement methodsFor: 'adding form elements'!
addCheckboxObject: anObject from: aCollection
	"if checked, this object will be put in collection. If object is initially in collection, 
	checkbox will be checked. Usefull for easy selection among many objects"
	^self add: (WebCheckBox newForObject: anObject from: aCollection)! !

!WebElement methodsFor: 'adding links'!
addCloseLinkText: aString
	"a link to close that window if popup (it also closes its execution context!!)"
	^(self addNilLinkText: aString)
		onClickClose! !

!WebElement methodsFor: 'adding other elements' stamp: ' 21/8/07 09:38'!
addComment: aString
	^self add: (WebComment text: aString).! !

!WebElement methodsFor: 'adding ajax components' stamp: ' 21/8/07 09:38'!
addDateInputFieldAspect: aSymbol for: anObject
	"with popup calendar"
	^self add: (WebDateInputField new aspect:  aSymbol for: anObject)! !

!WebElement methodsFor: 'adding ajax components' stamp: ' 21/4/07 22:07'!
addDelayedFieldAspect: aSymbol for: anObject
	"for Ajax instant posting, posting is done with a delay. Usefull for live-search fields"
	^self add: (WebDelayedField new aspect:  aSymbol for: anObject)! !

!WebElement methodsFor: 'adding ajax components' stamp: ' 21/4/07 22:07'!
addDelayedFieldAspect: aSymbol for: anObject size: aNumber
	"for Ajax instant posting, posting is done with a delay. Usefull for live-search fields"
	^self add: ((WebDelayedField new aspect:  aSymbol for: anObject) size: aNumber)! !

!WebElement methodsFor: 'adding other elements' stamp: ' 21/8/07 09:38'!
addErrorReport
	^self add: self app errorReport! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addGif: aSymbol
	"this method will be called in your webStyle and this method 
	should return a gif in byte array format"
	^self add: (WebImage gif: aSymbol)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addGif: aSymbol size: aPoint
	"this method will be called in your webStyle and this method 
	should return a gif in byte array format"
	^self add: (WebImage gif: aSymbol size: aPoint)! !

!WebElement methodsFor: 'adding other elements' stamp: ' 21/8/07 09:38'!
addHelpLink
	"link to help page for current view and App. If not exist, then nothing, exept for 
	admin - link to creation of new help page"
	^self add: self helpLink! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addImage: anImageOrURL
	^self add: (WebImage image: anImageOrURL)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addImage: anImageOrURL imageMap: aWebImageMap
	^self add: 
		((WebImage image: anImageOrURL)
			imageMap: aWebImageMap)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addImage: anImageOrURL size: aPoint
	^self add: (WebImage image: anImageOrURL size: aPoint)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addImage: anImageOrURL size: aPoint align: aSymbol
	^self add: ((WebImage image: anImageOrURL size: aPoint) align: aSymbol)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addImage: anImageOrURL size: aPoint valign: aSymbol
	^self add: ((WebImage image: anImageOrURL size: aPoint) valign: aSymbol)! !

!WebElement methodsFor: 'adding ajax components' stamp: ' 21/8/07 09:38'!
addInPlaceEditableTextAspect: aSymbol for: anObject
	^self add: (WebInPlaceEditableText aspect:  aSymbol for: anObject)! !

!WebElement methodsFor: 'adding ajax components' stamp: ' 21/8/07 09:38'!
addInPlaceEditableTextAspect: aSymbol for: anObject size: aNumberOrPoint
	^self add: (WebInPlaceEditableText aspect:  aSymbol for: anObject size: aNumberOrPoint)! !

!WebElement methodsFor: 'adding ajax components' stamp: ' 21/8/07 09:38'!
addInPlaceEditableTextAspect: aSymbol for: anObject size: aNumberOrPoint allow: aBoolean
	^self add: 
		(WebInPlaceEditableText aspect:  aSymbol for: anObject size: aNumberOrPoint allow: aBoolean)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addInputFieldAspect: aSymbol for: anObject
	^self add: (WebInputField new aspect:  aSymbol for: anObject)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addInputFieldAspect: aSymbol for: anObject size: aNumber
	^self add: ((WebInputField new aspect:  aSymbol for: anObject) size: aNumber)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addJpeg: aSymbol
	"this method will be called in your webStyle and this method 
	should return a gif in byte array format"
	^self add: (WebImage jpeg: aSymbol)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addJpeg: aSymbol size: aPoint
	"this method will be called in your webStyle and this method 
	should return a gif in byte array format"
	^self add: (WebImage jpeg: aSymbol size: aPoint)! !

!WebElement methodsFor: 'adding form elements'!
addLabelFor: anElementOrId text: aString
	"<label> tag  defines a label for related input element"
	^self add: 
		(WebLabel newFor: anElementOrId text: aString)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject gif: aGifSymbol title: aString
	^self add: ((WebLink linkTo: anObject) title: aString; addGif: aGifSymbol; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject gif: aGifSymbol title: aString size: aPoint
	^self add: ((WebLink linkTo: anObject) title: aString; addGif: aGifSymbol size: aPoint; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject gif: aGifSymbol title: aString view: aViewSymbol
	^self add: (((WebLink linkTo: anObject) title: aString; view: aViewSymbol) 
		addGif: aGifSymbol; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject gif: aGifSymbol title: aString view: aViewSymbol
	 parameter: aParmString value: aValueString

	^self add: (((WebLink linkTo: anObject) 
		title: aString; view: aViewSymbol;
		parameter: aParmString value: aValueString) 
			addGif: aGifSymbol; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject image: anImageOrURL
	^self add: ((WebLink linkTo: anObject) addImage: anImageOrURL; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject image: anImageOrURL parameter: aParmString value: aValueString
	^self add: (((WebLink linkTo: anObject)
		parameter: aParmString value: aValueString) addImage: anImageOrURL; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject image: anImageOrURL size: aPoint
	^self add: ((WebLink linkTo: anObject) addImage: anImageOrURL size: aPoint; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject image: anImageOrURL view: aViewSymbol
	^self add: (((WebLink linkTo: anObject) view: aViewSymbol) 
		addImage: anImageOrURL; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject jpeg: aSymbol title: aString
	^self add: ((WebLink linkTo: anObject) title: aString; addJpeg: aSymbol; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject jpeg: aSymbol title: aString view: aViewSymbol
	^self add: (((WebLink linkTo: anObject) title: aString; view: aViewSymbol) 
		addJpeg: aSymbol; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject png: aPngSymbol title: aString
	^self add: ((WebLink linkTo: anObject) title: aString; addPng: aPngSymbol; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject png: aPngSymbol title: aString view: aViewSymbol
	^self add: (((WebLink linkTo: anObject) title: aString; view: aViewSymbol) 
		addPng: aPngSymbol; yourself)! !

!WebElement methodsFor: 'adding links (image)' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject png: aPngSymbol title: aString view: aViewSymbol
	 parameter: aParmString value: aValueString

	^self add: (((WebLink linkTo: anObject) 
		title: aString; view: aViewSymbol;
		parameter: aParmString value: aValueString) 
			addPng: aPngSymbol; yourself)! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject text: aString
	^self add: (WebLink text: aString  linkTo: anObject)! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject text: aString attributes: anArray
	^self add: (WebLink text: aString  attributes: anArray linkTo: anObject)! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject text: aString parameter: aParmString value: aValueString
	^self add: (WebLink text: aString  linkTo: anObject 
		parameter: aParmString value: aValueString)! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject text: aString 
	parameter: a1ParmString value: a1ValueString
	parameter: a2ParmString value: a2ValueString

	^self add: (WebLink text: aString  linkTo: anObject 
		parameter: a1ParmString value: a1ValueString
		parameter: a2ParmString value: a2ValueString)! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject text: aString view: aViewString
	^self add: ((WebLink text: aString  linkTo: anObject)
		view: aViewString; yourself)! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject text: aString view: aViewString  parameter: aParmString value: aValueString
	^self add: ((WebLink text: aString  linkTo: anObject)
		view: aViewString;
		parameter: aParmString value: aValueString; yourself)! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addLinkTo: anObject text: aString view: aViewString  
		parameter: aParm1String value: aValue1String 
		parameter: aParm2String value: aValue2String

	^self add: ((WebLink text: aString  linkTo: anObject)
		view: aViewString;
		parameter: aParm1String value: aValue1String;
		parameter: aParm2String value: aValue2String; yourself)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addLiveImage: aWebLiveImage
	^self add: 
		((WebImage image: aWebLiveImage)
			size: (aWebLiveImage width)@(aWebLiveImage height))! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addLiveImage: aWebLiveImage imageMap: aWebImageMap
	^self add: 
		((WebImage image: aWebLiveImage)
			size: (aWebLiveImage width)@(aWebLiveImage height);
			imageMap: aWebImageMap)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addMenuAspect: aSymbol collection: aCollection selected: aSelectedCollection
	"Multiple selection menu.. Aspect of every element in aColection will be shown in menu. 
	Selection will be put in aSelectedCollection. Here also an initial selection can be set"
	^self add: (WebMenu aspect: aSymbol collection: aCollection selected: aSelectedCollection)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addMenuAspect: aSymbol collection: aCollection selectedToAspect: aSymbol2 of: anObject
	"Single selection menu.. Aspect of every element in aColection will be shown in menu. 
	Single selection will be put in an seelcted aspect of object. Here also initial selection can be set"
	^self add: 
		(WebMenu aspect: aSymbol collection: aCollection selectedToAspect: aSymbol2 of: anObject)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addMenuCollection: aCollection selected: aSelectedCollection
	"Multiple selection menu..Every element (text!!) in aColection will be shown in menu. 
	Selection will be put 	in aSelectedCollection. Here also an initial selection can be set"
	^self add: (WebMenu collection: aCollection selected: aSelectedCollection)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addMenuCollection: aCollection selectedToAspect: aSymbol2 of: anObject
	"Single selection menu. Every element (text!!) in aColection will be shown in menu. 
	Single selection will be put in an seelcted aspect of object. Here also initial selection can be set"
	^self add: (WebMenu collection: aCollection selectedToAspect: aSymbol2 of: anObject)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addMethodImage: aWebMethodImage
	^self add: 
		(WebImage image: aWebMethodImage)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addMethodImage: aWebMethodImage size: aPoint
	^self add: 
		((WebImage image: aWebMethodImage) size: aPoint)! !

!WebElement methodsFor: 'adding other elements' stamp: ' 21/8/07 09:38'!
addNbSp
	^self addText: '&nbsp;'.! !

!WebElement methodsFor: 'adding other elements' stamp: ' 21/8/07 09:38'!
addNbSp: aNumber
	aNumber timesRepeat: [self addNbSp].! !

!WebElement methodsFor: 'adding links'!
addNilLinkText: aString
	"just to click on it and trigger some onClick event"
	^self addLinkTo: '#' text: aString! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addPDFLinkTo: anObject
	^self add: ((WebLink linkTo: anObject) addGif: #pdfBigGif)! !

!WebElement methodsFor: 'adding other elements'!
addPageBreak
	"for printing to printer, to break into a new page!!"
	self add: (WebElement newDiv class: #pageBreak).

"	^self addBreak
		class: #printOnly;
		style: 'page-break-after: always';
		yourself."! !

!WebElement methodsFor: 'adding other elements' stamp: ' 21/8/07 09:38'!
addParagraph
	^self add: (WebSeparator paragraph).! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addPasswordFieldAspect: aSymbol for: anObject
	^self add: (WebInputField new type: #password; aspect:  aSymbol for: anObject)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addPasswordFieldAspect: aSymbol for: anObject size: aNumber
	^self add: ((WebInputField new type: #password; aspect:  aSymbol for: anObject) size: aNumber)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addPng: aSymbol
	"this method will be called in your webStyle and this method 
	should return a png in byte array format"
	^self add: (WebImage png: aSymbol)! !

!WebElement methodsFor: 'adding images' stamp: ' 21/8/07 09:38'!
addPng: aSymbol size: aPoint
	"this method will be called in your webStyle and this method 
	should return a png in byte array format"
	^self add: (WebImage png: aSymbol size: aPoint)! !

!WebElement methodsFor: 'adding text' stamp: 'janko 7/30/2008 15:15'!
addRedStar
	"red * for mandatory fields in a form"
	^self addText: '<sup>*</sup>'! !

!WebElement methodsFor: 'adding ajax components' stamp: ' 21/8/07 09:38'!
addRichEditorAspect: aSymbol for: anObject
	"JavaScript HTML WYSIWYG editor instead of textarea"
	^self add: (WebRichEditor new aspect:  aSymbol for: anObject)! !

!WebElement methodsFor: 'adding ajax components' stamp: ' 21/8/07 09:38'!
addRichEditorAspect: aSymbol for: anObject size: aPoint
	"JavaScript HTML WYSIWYG editor instead of textarea"
	^self add: ((WebRichEditor new aspect:  aSymbol for: anObject) size: aPoint)! !

!WebElement methodsFor: 'adding other elements'!
addRuler
	^self addRulerSize: 1! !

!WebElement methodsFor: 'adding other elements' stamp: ' 21/8/07 09:38'!
addRulerSize: aNumber
	^self add: (WebSeparator rulerSize: aNumber).! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addSecureLinkTo: anObject text: aString
	^self add: ((WebLink text: aString  linkTo: anObject) security: #grayed)! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addSecureLinkTo: anObject 
	text: aString parameter: aParmString value: aValueString

	^self add: ((WebLink text: aString  linkTo: anObject 
		parameter: aParmString value: aValueString) security: #grayed)! !

!WebElement methodsFor: 'adding links' stamp: ' 21/8/07 09:38'!
addSecureLinkTo: anObject text: aString view: aViewString
	^self add: ((WebLink text: aString  linkTo: anObject 
		view: aViewString) security: #grayed)! !

!WebElement methodsFor: 'adding text' stamp: ' 21/8/07 09:38'!
addSpace
	"just a simple space, nothing more"
	^self addText: ' '! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 11:50'!
addText: aStringOrAssociation "multilang"
	aStringOrAssociation isNil ifTrue: [^nil].
	^self add: (WebText text: aStringOrAssociation)! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 11:50'!
addText: aStringOrAssociation attributes:  aSymbolArray
	aStringOrAssociation isNil ifTrue: [^nil].
	^self add: ((WebText text: aStringOrAssociation) textAttributes: aSymbolArray)! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 11:51'!
addText: aStringOrAssociation header: aNumber
	aStringOrAssociation isNil ifTrue: [^nil].
	^self add: ((WebText text: aStringOrAssociation) header: aNumber)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addTextAreaAspect: aSymbol for: anObject
	^self add: (WebTextArea new aspect:  aSymbol for: anObject)! !

!WebElement methodsFor: 'adding form elements' stamp: ' 21/4/07 22:07'!
addTextAreaAspect: aSymbol for: anObject size: aPoint
	^self add: ((WebTextArea new aspect:  aSymbol for: anObject) size: aPoint)! !

!WebElement methodsFor: 'adding text' stamp: ' 21/8/07 09:38'!
addTextAspect: aSymbol for: anObject
	"depening on portlet mode (#view or #edit) return only text or make an input field"
	^self app inEditMode
		ifTrue: [self addInputFieldAspect: aSymbol for: anObject]
		ifFalse: [self addText: (anObject perform: aSymbol)]! !

!WebElement methodsFor: 'adding text' stamp: ' 21/8/07 09:38'!
addTextAspect: aSymbol for: anObject attributes: aSymbolOrArray
	"depening on portlet mode (#view or #edit) return only text or make an input field"
	^self app inEditMode
		ifTrue: [self addInputFieldAspect: aSymbol for: anObject]
		ifFalse: [self addText: (anObject perform: aSymbol) attributes: aSymbolOrArray]! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 11:46'!
addTextBig: aStringOrAssociation
	^self addText: aStringOrAssociation attributes: #big! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 12:18'!
addTextBold: aStringOrAssociation
	^self addText: aStringOrAssociation attributes: #b! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 12:19'!
addTextBoldAspect: aSymbol for: anObject
	"depening on portlet mode (#view or #edit) return only text or make an input field"
	^self addTextAspect: aSymbol for: anObject attributes: #b! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 11:47'!
addTextCode: aStringOrAssociation
	^self addText: aStringOrAssociation attributes: #code.! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 12:19'!
addTextH1: aStringOrAssociation
	^self addText: aStringOrAssociation header: 1! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 12:19'!
addTextH2: aStringOrAssociation
	^self addText: aStringOrAssociation header: 2! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 12:19'!
addTextH3: aStringOrAssociation
	^self addText: aStringOrAssociation header: 3! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 12:19'!
addTextH4: aStringOrAssociation
	^self addText: aStringOrAssociation header: 4! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 12:19'!
addTextH5: aStringOrAssociation
	^self addText: aStringOrAssociation header: 5! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 12:20'!
addTextItalic: aStringOrAssociation
	^self addText: aStringOrAssociation attributes: #i! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 11:48'!
addTextPreformated: aStringOrAssociation
	^self addText: aStringOrAssociation attributes: #pre.! !

!WebElement methodsFor: 'adding text' stamp: 'janko 9/30/2011 11:49'!
addTextSmall: aStringOrAssociation
	^self addText: aStringOrAssociation attributes: #small! !

!WebElement methodsFor: 'private-events'!
afterCloseUpdate
	"For later update, like after window close"
	^self otherAt: #afterCloseUpdate ifAbsent: [nil]! !

!WebElement methodsFor: 'private-events'!
afterCloseUpdate: anElement
	"For later update, like after window close"
	self otherAt: #afterCloseUpdate put: anElement! !

!WebElement methodsFor: 'testing' stamp: 'janko 4/25/2012 10:58'!
aidaIsRespondingStreamed
	^false! !

!WebElement methodsFor: 'private-streaming'!
aidaPresenterFor: aRequest on: aSession
	^self! !

!WebElement methodsFor: 'private-obsolete'!
ajaxCallUrl
	"relative url of an app observee object. This url is used for AJAX calls back to the server"
	| app linkTarget |
	app := self app.
	linkTarget := app isStandaloneApp 
		ifTrue: [app class] 
		ifFalse: [app observee isVersionedObject 
			ifTrue: [app observee currentVersion] ifFalse: [app observee] ].
	^AIDASite 
		convert: ( app site urlResolver halfUrlFor: linkTarget) 
		toCodepage: #utf8! !

!WebElement methodsFor: 'private-obsolete'!
ajaxCallUrlExtended
	"relative url of an app observee object. This url is used for AJAX calls back to the server"
	"also includes 'ajaxRequest' in query part, to distinguish ajax request from others"
	"Prototype specific"
	| viewParm versionParm |
	viewParm := 'view=', self context form view asString.
	versionParm := ''.
	(self app isStandaloneApp not and: [self app observee isVersionedObject]) ifTrue:
		[self app observee isCurrentVersion ifFalse: 
			[versionParm := 'version=', self app observee versionNumber, '&'] ].
	^self ajaxCallUrl, '?', viewParm, '&', versionParm, 'ajaxRequest'! !

!WebElement methodsFor: 'private-obsolete'!
ajaxCallUrlParametersFor: anElement context: aContext
	"ajax url must have 'ajaxRequest' parm in query part!! Deal also with versioned objects"
	"Prototype specific"
	| idSymbol viewParm versionParm contextParm |
	idSymbol := (anElement isNil
		ifTrue: [#nil] 
		ifFalse: [anElement ensureId. anElement id] ).
	viewParm := 'view=', aContext view asString.
	versionParm := ''.
	self app observee isVersionedObject ifTrue:
		[self app observee isCurrentVersion 
			ifFalse: [versionParm := 'version=', self app observee versionNumber, '&'] ].
	contextParm := WebContext contextIdName "aidaCtx", '=', aContext id printString.
	^viewParm, '&', 
		versionParm, 
		'ajaxRequest&ajaxGetElementId=', idSymbol asString,
		'&', contextParm! !

!WebElement methodsFor: 'attributes'!
align: aSymbol
	"element alignment #left #center #right"
	(#(left center right) includes: aSymbol) ifFalse: [self error: 'wrong align symbol'].
	self attributesAt: #align put: aSymbol asString! !

!WebElement methodsFor: 'private-subelements'!
allElements
	"get a collection of all subelements of elements down in a hierarcy of this element"
	| collection |
	collection := OrderedCollection new.
	self elements notNil ifTrue:
		[collection addAll: self elements.
		self elements do: [:each | collection addAll: each allElements] ].
	^collection

"
| el |
el := WebElement new.
el add: (WebLink image: nil  linkTo: nil).
el add: (WebText text: 'aaa').
el allElements.
"! !

!WebElement methodsFor: 'accessing'!
app
	"return anApplication on which we are composing a web page"
	| object |
	self creationObject notNil ifTrue:
		[self creationObject isWebApplication ifTrue: [^self creationObject].
		self creationObject isWebWidget ifTrue: [^self creationObject app].]. 
	self parent isNil ifTrue: 
		[object := self firstAppFromStack.
		^object isNil ifTrue: [nil] ifFalse: [object ] ].
	^parent app! !

!WebElement methodsFor: 'subelements'!
article
	"Return a current HTML5 subelement if it is of that tag. Create it if not yet exist"
	^self subelementTag: #article.! !

!WebElement methodsFor: 'accessing'!
asString
	"return only text part of the element and its subelements"
	| stream |
	elements isNil ifTrue: [^''].
	stream := WriteStream on: String new.
	self elements do: [:each | stream nextPutAll: each asString].
	^stream contents! !

!WebElement methodsFor: 'subelements'!
aside
	"Return a current HTML5 subelement if it is of that tag, error otherwise. Create it if not yet exist"
	^self subelementTag: #aside.! !

!WebElement methodsFor: 'private-attributes' stamp: ' 21/4/07 22:07'!
attributes
	^attributes! !

!WebElement methodsFor: 'private-attributes' stamp: ' 21/4/07 22:07'!
attributesAt: aSymbol
	self attributes isNil ifTrue: [^nil].
	^self attributes at: aSymbol ifAbsent: [nil]! !

!WebElement methodsFor: 'private-attributes'!
attributesAt: aSymbol add: aString
	"some attributes can have more than one value (like javascript for events)"
	| coll |
	self attributes isNil ifTrue: [self initAttributes].
	coll := self attributes at: aSymbol ifAbsentPut: [OrderedCollection new].
	(coll isKindOf: OrderedCollection) ifFalse:
		[coll := (self attributes at: aSymbol put: 
			(OrderedCollection new add: (self attributes at: aSymbol); yourself)) ].
	coll add: aString! !

!WebElement methodsFor: 'private-attributes' stamp: ' 21/4/07 22:07'!
attributesAt: aSymbol put: aString
	self attributes isNil ifTrue: [self initAttributes].
	self attributes at: aSymbol put: aString! !

!WebElement methodsFor: 'private-attributes'!
basicId: aSymbol
	^self attributesAt: #id put: aSymbol asSymbol! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 3/31/2008 01:39'!
beDraggable
	self beDraggableAndRevert: false! !

!WebElement methodsFor: 'events-effects&dragdrop'!
beDraggableAndRevert: aBoolean
	"Scriptaculous specific"
	self ensureId.
	ScriptaculousLibrary ensureScriptaculous.
	self scriptAfter: '// <!![CDATA[ 
	new Draggable("', self id asString,'",{revert:', aBoolean asString, '});
	// ]]> 
	'! !

!WebElement methodsFor: 'events-effects&dragdrop'!
beSortable
	"Scriptaculous specific"
	| script |
	self ensureId.
	ScriptaculousLibrary ensureScriptaculous.
	script := '// <!![CDATA[ 
		Sortable.create("', self id asString,'",{'.
	(self isKindOf: WebList) ifFalse: [
		self setDiv.
		script := script,  'tag: "div", '].
	script := script, 'dropOnEmpty: true, constraint: false});
		// ]]>'.
	self scriptAfter: script! !

!WebElement methodsFor: 'private'!
canUpdate
	"only pure WebElements (not subclasses, ok, few exceptions) can Ajax/WebSocket update"
	^self class == WebElement! !

!WebElement methodsFor: 'tables' stamp: ' 21/4/07 22:07'!
cell
	"return a current table cell"
	self initTableIfNessesary.
	^self otherAt: #currentCell! !

!WebElement methodsFor: 'private' stamp: ' 21/4/07 22:07'!
cell: aWebTableCell
	self initTableIfNessesary.
	self otherAt: #currentCell put: aWebTableCell.! !

!WebElement methodsFor: 'private-ajax'!
changeContextFrom: oldCtx to: newCtx
	"scan for all references to contexts and change them. Also in subelements"
	self changeContextInAttributesFrom: oldCtx to: newCtx.
	self elements do: [:each | each changeContextFrom: oldCtx to: newCtx]! !

!WebElement methodsFor: 'private-ajax'!
changeContextInAttribute: aString from: oldCtx to: newCtx
	| in out aidaCtx |
	aidaCtx := WebContext contextIdName.
	(('*', aidaCtx, '*') match: aString) ifFalse: [^nil].
	in := aString readStream. out := WriteStream on: String new.
	[in atEnd] whileFalse: 
		[out nextPutAll: (in upToAll: aidaCtx). 
		in atEnd not ifTrue: 
			[in next "=". in upTo: $&.               "& not always? "
			out nextPutAll: aidaCtx, '=', newCtx id printString, '&' ] ].   
	^out contents! !

!WebElement methodsFor: 'private-ajax'!
changeContextInAttributesFrom: oldCtx to: newCtx
	"scan for all references to contexts and change them"
	| attrToChange |
	self attributes isNil ifTrue: [^nil].
	attrToChange := #( #onClick #onDblClick #onKeyDown #onKeyPress #onKeyUp 
		#onMouseDown #onMouseMove #onMouseOut #onMouseOver #onMouseUp 
		#onSelect #onFocus #onChange #onSubmit #onReset).
	(self attributes associations select: [:each | attrToChange includes: each key]) do: [:assoc |
		assoc value class = OrderedCollection
			ifTrue: [self attributesAt: assoc key put: 
					(assoc value collect: [:each | self changeContextInAttribute: each from: oldCtx to: newCtx]) ]
			ifFalse: [self attributesAt: assoc key put: (self changeContextInAttribute: assoc value from: oldCtx to: newCtx)] ].! !

!WebElement methodsFor: 'private-ajax'!
check: anElementToUpdate on: aContext
	"check if element is updatable: it is first in a creation method. id is set and if in composition mode, set it.
	Raise error with good description to help better prepare Ajax updatable elements"
	anElementToUpdate isWebWidget ifTrue: [^anElementToUpdate registerId]. "to be sure"
	anElementToUpdate isStubElement ifTrue: [^true].
"	anElementToUpdate isFirstInMethod ifFalse:
		[^self error: 'Element to update must be first element in creation method!! Widget can be used instead']. "
	anElementToUpdate registerId. "if not already"! !

!WebElement methodsFor: 'testing'!
checkAndInitElements
	"lazy initialization od elements, when needed. Only for composite elements, else error"
	self isComposite 
		ifTrue:[(elements = nil) ifTrue: [elements := OrderedCollection new.       ]]
		ifFalse: [Smalltalk error: 'This is not a composite WebElement'].! !

!WebElement methodsFor: 'private-ajax' stamp: 'janko 1/2/2012 15:57'!
checkIfFirstInMethodOn: aContext
	"is this element created as first one in this method? Set the flag if true. Needed for checking if element is
	able to Ajax update or not"
	"this method doens't work correclty yet, it declares other elements in method as first too!!!!!!"
	| stContext request |
	stContext := thisContext . "find a context of a creation metod"
	[stContext receiver isWebApplication 
		or: [stContext receiver isWebWidget 
			or: [stContext receiver isWebStyle]] ]
		whileFalse: 
			[stContext := stContext sender. stContext isNil ifTrue: [^nil]].
	request := aContext event notNil
		ifTrue: [aContext event]
		ifFalse: [self firstRequestFromStack].
	(request isNil or: [request isAjaxRequest not])
		 ifTrue: [self otherAt: #firstInMethod put: true. ^self]. "Temporary!! in case of WebSocket message there is no request"
	(request creationStContexts includes: stContext) ifFalse:
		[self otherAt: #firstInMethod put: true.
		request creationStContexts add: stContext]! !

!WebElement methodsFor: 'attributes'!
class: aSymbolOrArray
	"one or more style classes of that element. Used for Cascaded Style Sheets"
	| clsText |
	(self class == WebElement and: [self hasTag not]) ifTrue: [self setDiv]. "ensure at least some tag"
	clsText := (aSymbolOrArray class = Array)
		ifTrue: [aSymbolOrArray
			inject: '' into: [:text :cls | cls = aSymbolOrArray first 
				ifTrue: [cls asString] ifFalse: [text, ' ', cls asString]] ] 
		ifFalse: [aSymbolOrArray asString].
	self attributesAt: #class put: clsText! !

!WebElement methodsFor: 'initialize-release'!
clear
	"remove all subelements including tables and event handlers"
	self elements do: [:each | each parent: nil].
	self initElements.
	self clearTableInfo.
	self initScripts.
"	self initEventHandlers. "! !

!WebElement methodsFor: 'initialize-release'!
clearAttributesExceptId
	self attributes keys do: [:name |
		name ~= #id ifTrue: [self attributes removeKey: name] ]! !

!WebElement methodsFor: 'tables' stamp: ' 21/4/07 22:07'!
clearTableInfo
	"clear all table information"
	self initTable! !

!WebElement methodsFor: 'private' stamp: ' 21/4/07 22:07'!
colorValue: aColorSymbol
	"Hex number format is: #rrbbgg if not in that format, then it can be a color name as defined in 
	class variable Colors (class method initColorDictionary). If unknown color, then attribute is set to nil"
	| attribute |
	attribute := aColorSymbol asString asLowercase asSymbol.
	attribute := WebElement colorDictionary at: attribute ifAbsent:
		[attribute asString do: [:chr | 
			(chr isDigit or: [chr asInteger between: $a asInteger and: $f asInteger]) ifFalse: [^self] ] ].
	^'#', (attribute asString copyWithout: $# )

"WebElement new colorValue: #red"! !

!WebElement methodsFor: 'accessing'!
context
	"return a web execution context on which we are composing a web page"
	self creationContext notNil ifTrue: 	[^self creationContext].
	^self parent notNil 
		ifTrue: [self parent context] "web window/page knows the best"
		ifFalse: [	self firstContextFromStack] "slow!! "! !

!WebElement methodsFor: 'private'!
creationContext
	"a context which created this element. If element is not updatable, then nil"
	^self otherAt: #creationContext ifAbsent: nil! !

!WebElement methodsFor: 'private'!
creationContext: aWebContext
	"a context which created this updatable element"
	^self otherAt: #creationContext put: aWebContext! !

!WebElement methodsFor: 'private'!
creationMethod
	"a method which created this element, always from some App or Widget. 
	Valid only for aWebElement, never for its subclasses!!"
	^self otherAt: #creationMethod ifAbsent: [nil]! !

!WebElement methodsFor: 'private'!
creationMethod: aSymbol
	"a method which created this element, always from some App or Widget. 
	Valid only for aWebElement, never for its subclasses!!"
	self otherAt: #creationMethod put: aSymbol.! !

!WebElement methodsFor: 'private'!
creationObject
	"a Widget or App which created this element. 
	Valid only for aWebElement, never for its subclasses!!"
	^self otherAt: #creationObject ifAbsent: [nil]! !

!WebElement methodsFor: 'private'!
creationObject: aWidgetOrApp
	"a Widget or App which created this element. 
	Valid only for aWebElement, never for its subclasses!!"
	^self otherAt: #creationObject put: aWidgetOrApp! !

!WebElement methodsFor: 'subelements'!
div
	"Return a current subelement if it is div. Create it if not yet exist"
	"The same as for tables: newTable, newCell, cell, .."
	^self subelementTag: #div.! !

!WebElement methodsFor: 'private-events'!
elementToReplace
	"Usually we 'replace' itself, but  for popup windows we replace an empty stub element"
	^self otherAt: #ElementToReplace ifAbsent: [self]! !

!WebElement methodsFor: 'private-events'!
elementToReplace: aWebElement
	"For now used for popup windows, where we don't update itself but replace an empty stub element"
	^self otherAt: #ElementToReplace put: aWebElement! !

!WebElement methodsFor: 'private' stamp: ' 21/4/07 22:07'!
elements
	elements isNil ifTrue: [self initElements].
	^elements! !

!WebElement methodsFor: 'attributes'!
ensureId
	"ensure that this element has Id and register it in the context"
	self id isNil ifTrue: [self registerId].! !

!WebElement methodsFor: 'private-identation' stamp: ' 21/4/07 22:07'!
eol
	self setNewline.
	^String with: Character cr with: Character lf.! !

!WebElement methodsFor: 'private-events'!
eventHandlerFor: aSymbol
	^self eventHandlers 
		at: aSymbol 
		ifAbsentPut: [WebEventHandler newForEvent: aSymbol on: self]! !

!WebElement methodsFor: 'private-events'!
eventHandlers
	eventHandlers isNil ifTrue: [self initEventHandlers].
	^eventHandlers! !

!WebElement methodsFor: 'private-events'!
eventHandlers: aDictionary
	eventHandlers := aDictionary! !

!WebElement methodsFor: 'private-events'!
existScriptForEvent: anEventString
	| eventPattern |
	eventPattern := '*aidaEvent(''', anEventString, '*'.
	self attributes isNil ifTrue: [^false].
	self attributes associationsDo: [:attribute |
		attribute value class = OrderedCollection
			ifFalse: [(eventPattern match: attribute value) ifTrue: [^true]]
			ifTrue: [(attribute value contains: [:attr | eventPattern match: attr]) ifTrue: [^true] ] ].
	^false! !

!WebElement methodsFor: 'subelements'!
figCaption
	"Return a current HTML5 subelement if it is of that tag, error otherwise. Create it if not yet exist"
	^self subelementTag: #figcaption.! !

!WebElement methodsFor: 'subelements'!
figure
	"Return a current HTML5 subelement if it is of that tag, error otherwise. Create it if not yet exist"
	^self subelementTag: #figure.! !

!WebElement methodsFor: 'private-subelements'!
first
	"Answer the first element.  If the receiver is empty, provide an error 
	notification."

	self checkAndInitElements.  "if not composite element, then error"
	^elements first! !

!WebElement methodsFor: 'subelements'!
footer
	"Return a current HTML5 subelement if it is of that tag, error otherwise. Create it if not yet exist"
	^self subelementTag: #footer.! !

!WebElement methodsFor: 'accessing' stamp: 'janko 10/27/2011 12:39'!
form
	"form to which belongs (or it will be) this element. it can be form on a page, popup window or widget"
	| form appOrWidget |
	self parent notNil ifTrue: 
		[form := self parent form. form notNil ifTrue: [^form] ].
	self creationObject notNil ifTrue: 
		[^self creationObject isWebWidget 
			ifTrue: [self creationObject form]	
			ifFalse: [self context form] ].
	appOrWidget := self firstWidgetOrAppFromStack.
	^(appOrWidget notNil and: [appOrWidget isWebWidget])
		ifTrue: [appOrWidget form]
		ifFalse: [self context form]! !

!WebElement methodsFor: 'subelements'!
hGroup
	"Return a current HTML5 subelement if it is of that tag, error otherwise. Create it if not yet exist"
	^self subelementTag: #hgroup.! !

!WebElement methodsFor: 'private-events'!
handleEvent: aWebEvent
	| handler |
	handler := self eventHandlerFor: aWebEvent event.
	handler isNil ifTrue: [self error: 'handler for that event does not exist'].
	^handler handleEvent: aWebEvent! !

!WebElement methodsFor: 'tags'!
hasTag
	"is this element enclosed or not in any tag like <div> or <span>"
	^self tag notNil! !

!WebElement methodsFor: 'subelements'!
header
	"Return a current HTML5 subelement if it is of that tag, error otherwise. Create it if not yet exist"
	^self subelementTag: #header.! !

!WebElement methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
helpLink
	^self app helpLink! !

!WebElement methodsFor: 'events'!
hide
	"hide me from web page"
	self ensureId.
	self scriptAfter: 'document.getElementById(''', self id, ''').style.display=''none'' '! !

!WebElement methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
id
	^self attributesAt: #id! !

!WebElement methodsFor: 'attributes'!
id: aSymbol
	"set a unique id of that element on a page. Used in javascript, urls, style sheets"
	"duplicate ids not allowed, error is raised!!"
	| ctx |
	ctx := self context.
	self id notNil ifTrue: "unregister old id"
		[(ctx isRegistered: self) ifTrue: 
			[ctx removeId: self id]].
	self basicId: aSymbol asSymbol.
	(self class = WebElement and: [self hasTag not]) ifTrue: [self setDiv]. "element with id must be at least div"
	ctx registerIdFor: self.! !

!WebElement methodsFor: 'private-identation' stamp: ' 21/4/07 22:07'!
ident
	"ident this tag to its level"
	| depth eol|
	eol := ''.
	self shouldIdent & self isNewline not ifTrue: [eol := self eol]. 
	depth := (self identationLevel - self identDepth) max: 0.
	self identDepth: self identationLevel.
	^eol, (String new: depth withAll: Character tab )! !

!WebElement methodsFor: 'private-identation'!
identDepth
	"how idented we are"
	| page |
	page := self webPage.
	^page notNil ifTrue: [page identDepth] ifFalse: [0].! !

!WebElement methodsFor: 'private-identation'!
identDepth: aNumber
	"how idented we are"
	| page |
	page := self webPage.
	^page isNil ifTrue: [0] ifFalse: [page identDepth: aNumber]! !

!WebElement methodsFor: 'private-identation' stamp: ' 21/4/07 22:07'!
identMore
	"ident inside tag content to its level and one deepier"
	self isNewline ifFalse: [self eol]. 
	self identDepth: self identationLevel+1.
	^String new: self identationLevel+1 withAll: $ ! !

!WebElement methodsFor: 'private-identation'!
identationLevel	
	"How much we need to ident. Top element (web page) has level 0"
	| page |
	self isWebPage ifTrue: [^0].
	^self parent notNil
		ifTrue: 
			[page := self webPage. page isNil ifTrue: [^0].
			self shouldIdent 
				ifTrue: [page identationLevel + 1] 
				ifFalse: [page identationLevel]]
		ifFalse: [0]! !

!WebElement methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initAttributes
	attributes := Dictionary new.! !

!WebElement methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initElements
	elements := OrderedCollection new.! !

!WebElement methodsFor: 'initialize-release'!
initEventHandlers
	eventHandlers := Dictionary new.! !

!WebElement methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initOther
	other := Dictionary new.! !

!WebElement methodsFor: 'initialize-release'!
initScripts
	self other isNil ifTrue: [^nil].
	self other removeKey: #scriptBefore ifAbsent: [].
	self other removeKey: #scriptAfter ifAbsent: [].! !

!WebElement methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initTable
	"just remove from other, later will be initalized lazily"
	self other isNil ifTrue: [^nil].
	self other 
		removeKey: #currentTable ifAbsent: [];
		removeKey: #currentRow ifAbsent: [];
		removeKey: #currentCell ifAbsent: [].! !

!WebElement methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initTableIfNessesary
	"if not already exist"
	self otherAt: #currentTable ifAbsent: [self newTable]! !

!WebElement methodsFor: 'initialize-release'!
initialize
	"override in subclasses if needed"
	"always start with super initialize!! "! !

!WebElement methodsFor: 'testing'!
isActive
	"this element is still part of some active (displayed on the browser) App view"
	self parent isNil ifTrue: [^false].
	^self parent isActive! !

!WebElement methodsFor: 'testing'!
isComposite
	"true, if this element is allowed to be composed by subelements.
	This method should be overriden by subclasess if a new element is not a 	composite."
	^true! !

!WebElement methodsFor: 'tags'!
isDiv
	^self tag = #div! !

!WebElement methodsFor: 'private-ajax'!
isFirstInMethod
	"is this element created as first one in its creation method?"
	^(self otherAt: #firstInMethod ifAbsent: [false])! !

!WebElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isFormElement
	^false! !

!WebElement methodsFor: 'private-identation'!
isNewline
	"are we at start of new line?"
	| page |
	page := self webPage.
	^page notNil ifTrue: [page isNewline] ifFalse: [false]! !

!WebElement methodsFor: 'testing'!
isPureWidget
	"not a window or page, which are also widgets, as subclasses"
	^false! !

!WebElement methodsFor: 'tags'!
isSpan
	^self tag = #span! !

!WebElement methodsFor: 'testing' stamp: 'jm 8/26/2009 15:02'!
isStubElement
	^false! !

!WebElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebApplication
	^false! !

!WebElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebElement
	^true! !

!WebElement methodsFor: 'testing'!
isWebForm
	^false! !

!WebElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebPage
	^false! !

!WebElement methodsFor: 'testing'!
isWebWidget
	^false! !

!WebElement methodsFor: 'testing'!
isWebWindow
	^false! !

!WebElement methodsFor: 'private-events'!
isWindowPopupRequested
	"click on this element requested a popup"
	^self otherAt: #WindowPopupRequested ifAbsent: [false]! !

!WebElement methodsFor: 'testing'!
isWrapped
	"basic elements (inputs, buttons, ..) must be wrapped in <span> element to become updatable"
	^self otherAt: #Wrapped ifAbsent: [false]! !

!WebElement methodsFor: 'private-subelements'!
last
	"Answer the last element.  If the receiver is empty, create an error notification."

	self checkAndInitElements.  "if not composite element, then error"
	^elements last! !

!WebElement methodsFor: 'private-identation' stamp: ' 21/4/07 22:07'!
level	
	"How deep we are in element hierarchy. Top element has level 0"
	^self parent notNil
		ifTrue: [self parent level + 1]
		ifFalse: [0]! !

!WebElement methodsFor: 'subelements'!
list
	"Return a current list (<ul> by default) subelement if it is of that tag, error otherwise. Create it if not yet exist"
	self subelement ifNil: [^self newList].
	self subelement class == WebList ifFalse: [self error: 'Current subelement is not of desired tag'].
	^self subelement! !

!WebElement methodsFor: 'accessing'!
method
	"a method which created this element, always from some App or Widget. 
	Valid only for aWebElement, never for its subclasses!!"
	^self otherAt: #creationMethod ifAbsent: [nil]! !

!WebElement methodsFor: 'subelements'!
nav
	"Return a current HTML5 subelement if it is of that tag, error otherwise. Create it if not yet exist"
	^self subelementTag: #nav.! !

!WebElement methodsFor: 'subelements'!
newArticle
	"New HTML5 <article> structural subelement"
	^self newSubelementTag: #article! !

!WebElement methodsFor: 'subelements'!
newAside
	"New HTML5 <aside> structural subelement"
	^self newSubelementTag: #aside! !

!WebElement methodsFor: 'tables' stamp: ' 21/4/07 22:07'!
newCell
	"add a new cell to current table row. Return a new WebTableCell so that you can send messages
	to it immediatelly - color, width, addText etc."
	self cell: WebTableCell new.
	self row add: self cell.
	^self cell! !

!WebElement methodsFor: 'subelements'!
newDiv
	"add and immediatelly return a new DIV. I remembers it, later can be found with #div"
	"The same as for tables: newTable, newCell, cell, .."
	^self newSubelementTag: #div.! !

!WebElement methodsFor: 'subelements'!
newFigCaption
	"New HTML5 structural subelement"
	^self newSubelementTag: #figcaption! !

!WebElement methodsFor: 'subelements'!
newFigure
	"New HTML5 structural subelement"
	^self newSubelementTag: #figure! !

!WebElement methodsFor: 'subelements'!
newFooter
	"New HTML5 structural subelement"
	^self newSubelementTag: #footer! !

!WebElement methodsFor: 'subelements'!
newHGroup
	"New HTML5 structural subelement"
	^self newSubelementTag: #hgroup! !

!WebElement methodsFor: 'subelements'!
newHeader
	"New HTML5 structural subelement"
	^self newSubelementTag: #header! !

!WebElement methodsFor: 'subelements'!
newList
	"add and immediatelly return a new list (<ul> by default, send #ordered for <ol>). I remember it, later can be found 
	with #list"
	"The same as for tables: newTable, table, newCell, cell, .."
	self subelement: (WebList new unordered).
	self add: self subelement.
	^self subelement! !

!WebElement methodsFor: 'subelements'!
newNav
	"New HTML5 structural subelement"
	^self newSubelementTag: #nav! !

!WebElement methodsFor: 'tables' stamp: ' 21/4/07 22:07'!
newRow
	"add a new row to current table. Return a new WebTableRow so that you can send messages
	to it immediatelly - color, width etc. Also reset current row and current cell to a new ones. "
	self row: WebTableRow new.
	self table add: self row.
	self newCell.
	^self row! !

!WebElement methodsFor: 'subelements'!
newSection
	"New HTML5 structural subelement"
	^self newSubelementTag: #section! !

!WebElement methodsFor: 'subelements'!
newSpan
	"add and immediatelly return a new span. I remembers it, later can be found with #span"
	"The same as for tables: newTable, newCell, cell, .."
	^self newSubelementTag: #span! !

!WebElement methodsFor: 'private-subelements'!
newSubelementTag: aTagSymbol
	"add and immediatelly return a new structural element with that tag. It remembers it, later can 
      be found with a method, like #div" "The same princliple as for tables: newTable, newCell, cell, .."
	self subelement: (WebElement new tag: aTagSymbol).
	self add: self subelement.
	^self subelement! !

!WebElement methodsFor: 'tables' stamp: ' 21/4/07 22:07'!
newTable
	"add a new table to this element. Return a new WebTable so that you can send messages
	to it immediatelly - color, width etc. Also reset current row and current cell to a new ones. "
	self table: WebTable new.
	self add: self table.
	self newRow.
	^self table! !

!WebElement methodsFor: 'initialize-release'!
nilAttributes
	attributes := nil.! !

!WebElement methodsFor: 'tags'!
noDiv
	"remove automatically generated DIV"
	self isDiv ifTrue: [self tag: nil]! !

!WebElement methodsFor: 'attributes'!
noId
	"remove Id, usually because it is automatically generated"
	self attributes isNil ifTrue: [^nil].
	^self attributes removeKey: #id ifAbsent: [nil]! !

!WebElement methodsFor: 'private-obsolete'!
oldAddCloseLinkText: aString
	"OBSOLETE"
	"a link to close that window if popup (it also closes by Ajax its execution context!!)"
	| ctx link |
	ctx := self context.
	link := self addNilLinkText: aString.
	link
		onClick: 'closeLightboxLevel(', ctx level printString,')'; "from WebStyle>>js30Lightbox"
		onClickUpdate: nil from: nil with: nil optional: 'aidaCloseWindow'.  "to close context too"
	ctx afterCloseUpdate notNil ifTrue: "if set by WebElement>>onClickPopup:thenUpdate:"
		[link onClick: "update on parent context of the popup!! "
			(self scriptForUpdate: ctx afterCloseUpdate from: ctx afterCloseUpdate
				with: nil 	optional: nil
				context: (ctx isFirst not ifTrue: [ctx parent] ifFalse: [ctx]) )]! !

!WebElement methodsFor: 'events-actions' stamp: 'janko 11/7/2011 14:13'!
on: anEventSymbol closeAndDo: aBlock
	"first evaluate a block then close the current window (usually popup)"
	self on: anEventSymbol do: aBlock. 
	(self eventHandlerFor: anEventSymbol) 
		addCloseWindow.! !

!WebElement methodsFor: 'events-actions' stamp: 'janko 11/7/2011 14:11'!
on: anEventSymbol do: aBlock
	"execute that block when this event occurs, like #click, #mouseOver etc."
	self 
		on: anEventSymbol 
		script: (self scriptForEvent: anEventSymbol context: self context).
	(self eventHandlerFor: anEventSymbol) 
		addActionBlock: aBlock.! !

!WebElement methodsFor: 'events' stamp: 'janko 11/21/2011 13:18'!
on: anEventSymbol script: aJavascriptCode
	" on #click, #keyPress etc add a scecified script"
	"possible events (but you can add:
	#click #dblClick 
	#keyPress #keyDown #keyUp
	#mouseUp #mouseDown #mouseMove #mouseOut #mouseOver
	"
	self 
		attributesAt: ('on', anEventSymbol asString asUppercase) asSymbol 
		add: aJavascriptCode! !

!WebElement methodsFor: 'events' stamp: 'janko 11/7/2011 13:58'!
onClick: aJavascriptCode
	self on: #click script: aJavascriptCode! !

!WebElement methodsFor: 'events-ajax'!
onClickClose
	"close the window if popup"
	self onClick: 
		(self scriptForEvent: #click context: self context).
	(self eventHandlerFor: #click) 
		addCloseWindow! !

!WebElement methodsFor: 'events-actions' stamp: 'janko 11/7/2011 14:14'!
onClickCloseAndDo: aBlock
	"on click first evaluate a block then close the current window (usually popup)"
	self on: #click closeAndDo: aBlock! !

!WebElement methodsFor: 'events-actions' stamp: 'janko 11/7/2011 14:11'!
onClickDo: aBlock
	"execute that block when this link is clicked"
	self on: #click do: aBlock! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 3/31/2008 00:06'!
onClickDoEffect: aSymbol
	self onClickDoEffect: aSymbol for: self! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 9/24/2008 17:04'!
onClickDoEffect: aSymbol duration: aNumber
	self onClickDoEffect: aSymbol for: self duration: aNumber! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 9/24/2008 17:05'!
onClickDoEffect: aSymbol for: anElementOrId
	^self onClickDoEffect: aSymbol for: anElementOrId duration: 1.0! !

!WebElement methodsFor: 'events-effects&dragdrop'!
onClickDoEffect: aSymbol for: anElementOrId duration: aNumber
	"Scriptaculous specific"
	| idSymbol |
	ScriptaculousLibrary ensureScriptaculous.
	idSymbol := anElementOrId isSymbol 
		ifTrue: [anElementOrId] ifFalse: [anElementOrId ensureId. anElementOrId id].
	self onClick: 'new Effect.', aSymbol asString, '(''', idSymbol asString, ''', {duration:', aNumber asString,'})'.! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 9/24/2008 17:03'!
onClickDoToggleEffect: aSymbol for: anElementOrId
	^self onClickDoToggleEffect: aSymbol for: anElementOrId duration: 1.0! !

!WebElement methodsFor: 'events-effects&dragdrop'!
onClickDoToggleEffect: aSymbol for: anElementOrId duration: aNumber
	"Scriptaculous specific"
	| idSymbol |
	ScriptaculousLibrary ensureScriptaculous.
	idSymbol := anElementOrId isSymbol 
		ifTrue: [anElementOrId] ifFalse: [anElementOrId ensureId. anElementOrId id].
	self onClick: 'new Effect.toggle(''', idSymbol asString, ''', ''', aSymbol asString, ''', {duration:', aNumber asString,'})'.! !

!WebElement methodsFor: 'events'!
onClickHide: anElement
	"hide specified element on mouse click on me"
	anElement ensureId.
	self onClick: 'document.getElementById(''', anElement id, ''').style.display=''none'' '.! !

!WebElement methodsFor: 'events-ajax'!
onClickPopup: anElement
	"popup a specified element (can be also a WebWidget) with fresh content from server (AJAX) in a 
       new window on the same page"
	self onClickPopup: anElement thenUpdate: nil! !

!WebElement methodsFor: 'events-ajax'!
onClickPopup: anElement thenUpdate: anElementToUpdate
	"popup a specified element (can be also a WebWidget) with fresh content from server (AJAX) in a 
       new window on the same page. Update anElementToUpdate after popup window is closed"
	| ctx |
	self ensureId. anElement ensureId.
	ctx := self context.
	anElementToUpdate notNil ifTrue: 
		[anElementToUpdate ensureId.
		anElement afterCloseUpdate: anElementToUpdate]. "will be copied ot popup window"
	(self existScriptForEvent: 'click') ifFalse: "only one script per event!!"
		[self onClick: (self scriptForEvent: #click context: self context)].
	(self eventHandlerFor: #click) 
		addPopup: anElement onStub: ctx window popupStub.
	self setWindowPopupRequested.! !

!WebElement methodsFor: 'events' stamp: 'np 10/20/2008 16:40'!
onClickReload
	"reload current page on click off that element"
	self onClick: 'window.location.reload()'.! !

!WebElement methodsFor: 'events'!
onClickShow: anElement
	"show specified element on mouse click on me"
	anElement ensureId.
	self onClick: 'document.getElementById(''', anElement id, ''').style.display=''block'' '.! !

!WebElement methodsFor: 'events' stamp: 'np 10/18/2008 13:34'!
onClickStore: aStringOrBoolean toAspect: aSymbol of: anObject
	"store the value via aspect (accessor/mutator method name) to specified object"
	^self notYetImplemented! !

!WebElement methodsFor: 'events'!
onClickToggle: anElement
	"toggle visibility of specified element on mouse click on me"
	anElement ensureId.
	self onClick: 'var e = document.getElementById(''', anElement id, '''); if (e.style.display == ''none'') a = ''block''; else a = ''none''; e.style.display = a; '! !

!WebElement methodsFor: 'events-ajax'!
onClickUpdate: anElement
	"update (and show if not yet) a specified element from server (Ajax)"
	self onClickUpdate: anElement with: nil! !

!WebElement methodsFor: 'private-obsolete'!
onClickUpdate: anElementToUpdate  from: anElementToRecreate with: anArgString optional: anArg2String
	"ElementToUpdate will be replaced with contents of the elementToRecreate after its creation method will be   
      called to recreate it. Except for popups both elements are actually the same"
	"First argument will be send as an argument of the method while second is optional"
	"Note that parameters will be sent at the time of building the element and not at the event!!" 
	"See WebApplication>>respondToAjaxRequest: and specially #ajaxUpdateOfOld:from: for more"
	anElementToUpdate notNil ifTrue: [anElementToUpdate ensureId]. 
	self onClick: 
		(self scriptForEvent: #click context: self context).
	(self eventHandlerFor: #click) addUpdate: anElementToUpdate with: anArgString.
"		(self scriptForUpdate: anElementToUpdate from: anElementToRecreate
			with: anArgString optional: anArg2String 
			context: self context)
"! !

!WebElement methodsFor: 'events-ajax'!
onClickUpdate: anElement with: anArgObject
	"Update a specified element from server (Ajax) with calling the element's creation method with an argument"
	"Creation method must be able to receive a parameter. For instance: #propertiesElementShow: aBoolean "
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	(self existScriptForEvent: 'click') ifFalse: "only one script per event!!"
		[self onClick: (self scriptForEvent: #click context: self context)].
	(self eventHandlerFor: #click) 
		addUpdate: anElement with: anArgObject.! !

!WebElement methodsFor: 'events' stamp: 'janko 11/7/2011 14:03'!
onKeyPress: aJavascriptCode
	self on: #keyPress script: aJavascriptCode! !

!WebElement methodsFor: 'events' stamp: 'janko 11/7/2011 14:04'!
onKeyUp: aJavascriptCode
	self on: #keyUp script: aJavascriptCode! !

!WebElement methodsFor: 'events' stamp: 'janko 11/7/2011 14:05'!
onMouseOut: aJavascriptCode
	self on: #mouseOut script: aJavascriptCode! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 3/31/2008 01:15'!
onMouseOutDoEffect: aSymbol
	self onMouseOutDoEffect: aSymbol for: self! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 9/24/2008 17:06'!
onMouseOutDoEffect: aSymbol duration: aNumber
	self onMouseOutDoEffect: aSymbol for: self duration: aNumber! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 9/24/2008 17:07'!
onMouseOutDoEffect: aSymbol for: anElementOrId
	^self onMouseOutDoEffect: aSymbol for: anElementOrId duration: 1.0! !

!WebElement methodsFor: 'events-effects&dragdrop'!
onMouseOutDoEffect: aSymbol for: anElementOrId duration: aNumber
	"Scriptaculous specific"
	| idSymbol |
	ScriptaculousLibrary ensureScriptaculous.
	idSymbol := anElementOrId isSymbol 
		ifTrue: [anElementOrId] ifFalse: [anElementOrId ensureId. anElementOrId id].
	self onMouseOut: 'new Effect.', aSymbol asString, '(''', idSymbol asString, ''', {duration: ', aNumber asString, '});'.! !

!WebElement methodsFor: 'events'!
onMouseOutHide: anElement
	"hide specified element when mouse get out of me"
	anElement ensureId.
	self onMouseOut: 'document.getElementById(''', anElement id, ''').style.display=''block'' '.! !

!WebElement methodsFor: 'events'!
onMouseOutShow: anElement
	"show specified element when mouse get out of me"
	anElement ensureId.
	self onMouseOut: 'document.getElementById(''', anElement id, ''').style.display=''block'' '.! !

!WebElement methodsFor: 'events-ajax'!
onMouseOutUpdate: anElement
	"update (and show if not yet) a specified element from server (Ajax)"
	self onMouseOutUpdate: anElement with: nil! !

!WebElement methodsFor: 'events-ajax'!
onMouseOutUpdate: anElement with: anArgObject
	"update a specified element from server wtih calling an element method with an argument"
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	self onMouseOut: 
		(self scriptForEvent: #mouseOut context: self context).
	(self eventHandlerFor: #mouseOut) 
		addUpdate: anElement with: anArgObject.! !

!WebElement methodsFor: 'events' stamp: 'janko 11/7/2011 14:06'!
onMouseOver: aJavascriptCode
	self on: #mouseOver script: aJavascriptCode! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 3/31/2008 01:15'!
onMouseOverDoEffect: aSymbol
	self onMouseOverDoEffect: aSymbol for: self! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 9/24/2008 17:07'!
onMouseOverDoEffect: aSymbol duration: aNumber
	self onMouseOverDoEffect: aSymbol for: self duration: aNumber! !

!WebElement methodsFor: 'events-effects&dragdrop' stamp: 'np 9/24/2008 17:08'!
onMouseOverDoEffect: aSymbol for: anElementOrId
	^self onMouseOverDoEffect: aSymbol for: anElementOrId duration: 1.0! !

!WebElement methodsFor: 'events-effects&dragdrop'!
onMouseOverDoEffect: aSymbol for: anElementOrId duration: aNumber
	"Scriptaculous specific"
	| idSymbol |
	ScriptaculousLibrary ensureScriptaculous.
	idSymbol := anElementOrId isSymbol 
		ifTrue: [anElementOrId] ifFalse: [anElementOrId ensureId. anElementOrId id].
	self onMouseOver: 'new Effect.', aSymbol asString, '(''', idSymbol asString, ''', {duration: ', aNumber asString,'});'.! !

!WebElement methodsFor: 'events'!
onMouseOverHide: anElement
	"hide specified element when mouse come over me"
	anElement ensureId.
	self onMouseOver: 'document.getElementById(''', anElement id, ''').style.display=''none'' '.! !

!WebElement methodsFor: 'events'!
onMouseOverShow: anElement
	"show specified element when mouse come over me"
	anElement ensureId.
	self onMouseOver: 'document.getElementById(''', anElement id, ''').style.display=''block'' '.! !

!WebElement methodsFor: 'private-obsolete'!
onMouseOverSyncUpdate: anElement
	"update (and show if not yet) a specified element from server (AJAX)"
	"wait until AJAX response returns (synchronous update)"
	self onMouseOverSyncUpdate: anElement with: nil! !

!WebElement methodsFor: 'private-obsolete'!
onMouseOverSyncUpdate: anElement with: anArgString
	"update a specified element from server (AJAX) wtih calling an element method with an argument"
	"wait until AJAX response returns (synchronous update)"
	"Prototype specific"
	| id url parms  |
	anElement ensureId. id := anElement id.
	url := self ajaxCallUrl. 
	parms:= self ajaxCallUrlParametersFor: anElement context: self context.
	anArgString notNil ifTrue: [parms := parms, '&parm=', anArgString].
	self onMouseOver: 'new Ajax.Updater(''', id asString, ''', ''', url, 
		''', {method: ''post'', postBody: ''', parms, ''', evalScripts: true, asynchronous: false})'! !

!WebElement methodsFor: 'events-ajax'!
onMouseOverUpdate: anElement
	"update (and show if not yet) a specified element from server (Ajax)"
	self onMouseOverUpdate: anElement with: nil! !

!WebElement methodsFor: 'events-ajax'!
onMouseOverUpdate: anElement with: anArgObject
	"update a specified element from server wtih calling an element method with an argument"
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	self onMouseOver: 
		(self scriptForEvent: #mouseOver context: self context).
	(self eventHandlerFor: #mouseOver) 
		addUpdate: anElement with: anArgObject.! !

!WebElement methodsFor: 'private-other' stamp: ' 21/4/07 22:07'!
other
	^other! !

!WebElement methodsFor: 'private-other' stamp: ' 21/4/07 22:07'!
otherAt: aSymbol
	^self otherAt: aSymbol ifAbsent: [nil]! !

!WebElement methodsFor: 'private-other' stamp: ' 21/4/07 22:07'!
otherAt: aSymbol ifAbsent: aBlock
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!WebElement methodsFor: 'private-other' stamp: ' 21/4/07 22:07'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!WebElement methodsFor: 'private-other' stamp: ' 21/4/07 22:07'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!WebElement methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
parent
	^parent! !

!WebElement methodsFor: 'private' stamp: ' 21/4/07 22:07'!
parent: aWebElement
	parent := aWebElement! !

!WebElement methodsFor: 'private' stamp: 'janko 10/27/2011 11:42'!
postAddAction
	"additional actions after this element was added to another (parent)"
	"override in your elements if needed"! !

!WebElement methodsFor: 'private-streaming'!
prepareAttributesToStreamOn: aSession
	"override if you like to change or otherwise prepare attribute values"
	"don't forget to call first super prepareAttributesToPrintOn: !! "
	#('title') do: [:attrName || attrValue |
		attrValue := self attributesAt: attrName.
		attrValue notNil ifTrue:
			[attrValue aidaIsAssociation 
				ifTrue: "multilang value of this attribute"
					[self attributesAt: attrName put: (self textFromMultilang: attrValue on: aSession)]
				ifFalse: [		
					(attrValue includes: $^ ) "slovene csz are converted if char ^ is after such a char"
						ifTrue: [self attributesAt: attrName put: attrValue convertToSloveneChars] ]
			]
		]! !

!WebElement methodsFor: 'private'!
prepareForTranslation
	"if element has multilingual text, make it in-line editable for translation"
	"Sublcasses should implement editing accordingly"
	self elements do: [:each | each prepareForTranslation]! !

!WebElement methodsFor: 'private-streaming'!
prepareToHtmlStreamingOn: aSession
	"all preparations just before html rendering"
	self prepareAttributesToStreamOn: aSession.  "some pre-html preparation of values"! !

!WebElement methodsFor: 'private-obsolete'!
printHTMLPageOn: aStream for: aRequest on: aSession
	"OBSOLETE!!"
	^self streamHtmlTo: aStream for: aRequest on: aSession! !

!WebElement methodsFor: 'private'!
printString
	^'a', self class printString, 
		(self tag notNil ifTrue: [' ', self tag asString] ifFalse: ['']),
		(self id notNil ifTrue: [' id: ', self id] ifFalse: ['']),
		((self attributesAt: #class)  notNil ifTrue: [' class: ', (self attributesAt: #class) ] ifFalse: [''])! !

!WebElement methodsFor: 'private-subelements'!
registerFormElements
	"find form elements down in element hierachy and register them in an apropriate 
       form (from page, popup window or widget)"
	self registerFormElementsTo: self form! !

!WebElement methodsFor: 'private-subelements'!
registerFormElementsTo: aWebForm
	"find form elements down in element hierachy and register them in an apropriate 
       form (from page, popup window or widget). Also setup the form hierarchy"
	| form |
	form := (self isWebForm and: [self ~= aWebForm])  "another form found, change to it as a registration target"
		ifTrue: [aWebForm addSubform: self. self] 
		ifFalse: [aWebForm].
	self isFormElement ifTrue: [form registerFormElement: self].
	self elements do: [:subelement |
		subelement registerFormElementsTo: form]! !

!WebElement methodsFor: 'attributes'!
registerId
	"put into current context ids dictionary for faster search from AJAX requests"
	| ctx |
	self id notNil ifTrue: [^nil]. "is probably already registered!! "
	ctx := self context.
	ctx notNil ifTrue: 	[ctx registerIdFor: self]! !

!WebElement methodsFor: 'private-subelements'!
replace: aSubelement with: anElement
	| index |
	index := self elements indexOf: aSubelement.
	self elements at: index put: anElement.
	anElement parent: self.
	aSubelement parent: nil.! !

!WebElement methodsFor: 'private-events'!
resetShallQueue
	"in #update, shall new element be queued for sendng to browser immediatelly or later. For popups 
	it is queued after element is wrapped in popup window, see WebApplication>>handleEvent: "
	^self otherAt: #ShallQueue put: false! !

!WebElement methodsFor: 'tables' stamp: ' 21/4/07 22:07'!
row
	"return a current table row"
	self initTableIfNessesary.
	^self otherAt: #currentRow! !

!WebElement methodsFor: 'private' stamp: ' 21/4/07 22:07'!
row: aWebTableRow
	self initTableIfNessesary.
	self otherAt: #currentRow put: aWebTableRow.! !

!WebElement methodsFor: 'scripts' stamp: ' 21/4/07 22:07'!
script: aString
	"add this JavaScript  to scripts executed after this element"
	self scriptAfter: aString! !

!WebElement methodsFor: 'private' stamp: ' 21/4/07 22:07'!
scriptAfter
	^self otherAt: #scriptAfter ifAbsent: [nil]! !

!WebElement methodsFor: 'scripts' stamp: ' 21/4/07 22:07'!
scriptAfter: aString
	"add this JavaScript  to scripts executed after this element"
	(self otherAt: #scriptAfter ifAbsentPut: [WebScript new]) script: aString! !

!WebElement methodsFor: 'scripts' stamp: 'mivsek 1/10/2008 22:19'!
scriptAfterExternal: anUrlOrObject
	"add this externalJavaScript  to scripts executed after this element"
	| url |
	url := anUrlOrObject isString
		ifTrue: [anUrlOrObject]
		ifFalse: [self site urlResolver halfUrlFor: anUrlOrObject].
	(self otherAt: #scriptAfter ifAbsentPut: [WebScript new]) source: url! !

!WebElement methodsFor: 'private' stamp: ' 21/4/07 22:07'!
scriptBefore
	^self otherAt: #scriptBefore ifAbsent: [nil]! !

!WebElement methodsFor: 'scripts' stamp: ' 21/4/07 22:07'!
scriptBefore: aString
	"add this JavaScript  to scripts executed before this element"
	(self otherAt: #scriptBefore ifAbsentPut: [WebScript new]) script: aString! !

!WebElement methodsFor: 'scripts' stamp: 'mivsek 1/10/2008 22:20'!
scriptBeforeExternal: anUrlOrObject
	"add this external JavaScript  to scripts executed before this element"
	| url |
	url := anUrlOrObject isString
		ifTrue: [anUrlOrObject]
		ifFalse: [self site urlResolver halfUrlFor: anUrlOrObject].
	(self otherAt: #scriptBefore ifAbsentPut: [WebScript new]) source: url! !

!WebElement methodsFor: 'private-events'!
scriptForEvent: anEventSymbol context: aWebContext
	^'aidaEvent(''', anEventSymbol asString, ''',''', 
		(self ensureId; id) asString, ''',''', 
		aWebContext id asString, ''')'! !

!WebElement methodsFor: 'private-obsolete'!
scriptForUpdate: anElementToUpdate from: anElementToRecreate with: anArgString optional: anArg2String  context: aContext
	"OBSOLETE"
	"ElementToUpdate will be replaced with contents of the elementToRecreate after its creation method will be   
      called to recreate it. Except for popups both elements are actually the same"
	"First argument will be send as an argument of the method while second is optional"
	"If both elements are nil, only arguments will be sent, usefull for sending commands only, like close window"
	"Note that parameters will be sent at the time of building the element and not at the event!!" 
	"See WebApplication>>respondToAjaxRequest: and specially #ajaxUpdate:from: for more"
	"Prototype specific"
	| idToUpdate url parms  |
	idToUpdate := anElementToUpdate notNil 
		ifTrue: [self check: anElementToUpdate on: aContext. anElementToUpdate id]
		ifFalse: [#nothingToUpdate].  "just send arguments, if any"
	url := self ajaxCallUrl. 
	parms:= self ajaxCallUrlParametersFor: anElementToUpdate context: aContext.
	anArgString notNil ifTrue: [parms := parms, '&parm=', anArgString].
	anArg2String notNil ifTrue: [parms := parms, '&parm2=', anArg2String].
	anElementToRecreate notNil ifTrue:
		[self check: anElementToRecreate on: aContext.
		parms := parms, '&ajaxElementToRecreateId=', anElementToRecreate id asString].
	^'new Ajax.Updater(''', idToUpdate asString, ''', ''', url, 
		''', {method: ''post'', postBody: ''', parms, ''', evalScripts: true, asynchronous: false})'! !

!WebElement methodsFor: 'subelements'!
section
	"Return a current HTML5 subelement if it is of that tag, error otherwise. Create it if not yet exist"
	^self subelementTag: #section.! !

!WebElement methodsFor: 'accessing'!
session
	"return a Session for which we are composing a web page"
	^self app session! !

!WebElement methodsFor: 'tags'!
setArticle
	"HTML5 <article> structural element"
	self tag: #article! !

!WebElement methodsFor: 'tags'!
setAside
	"HTML5 <aside> structural element"
	self tag: #aside! !

!WebElement methodsFor: 'private'!
setCreationMethodAndObject
	"find a name of a method and the object (Widget, App or Style) which created me"
	| stContext |
	stContext := thisContext.
	[stContext notNil] whileTrue: [
		((stContext receiver isKindOf: WebApplication) 
			or: [(stContext receiver isKindOf: WebWidget) 
				or: [stContext receiver isKindOf: WebStyle]]) ifTrue: 
					[self creationObject: stContext receiver. "who shall receive that method when needed"
					^self creationMethod: stContext selector].
		stContext := stContext sender].! !

!WebElement methodsFor: 'tags'!
setDiv
	self tag: #div! !

!WebElement methodsFor: 'tags'!
setFigCaption
	"HTML5 <figcaption> figure caption structural element"
	self tag: #figcaption! !

!WebElement methodsFor: 'tags'!
setFigure
	"HTML5 <figure> structural element"
	self tag: #figure! !

!WebElement methodsFor: 'tags'!
setFooter
	"HTML5 <footer> structural element"
	self tag: #footer! !

!WebElement methodsFor: 'tags'!
setHGroup
	"HTML5 <hgroup> header group structural element"
	self tag: #hgroup! !

!WebElement methodsFor: 'tags'!
setHeader
	"HTML5 <header> structural element"
	self tag: #header! !

!WebElement methodsFor: 'tags'!
setNav
	"HTML5 <nav> structural element"
	self tag: #nav! !

!WebElement methodsFor: 'private-identation'!
setNewline
	"we are no longer at start of line"
	| page |
	page := self webPage.
	page notNil ifTrue: [page setNewline].! !

!WebElement methodsFor: 'tags'!
setSection
	"HTML5 <section> structural element"
	self tag: #section! !

!WebElement methodsFor: 'tags'!
setSpan
	self tag: #span! !

!WebElement methodsFor: 'private-events'!
setWindowPopupRequested
	"click on this element requests a popup"
	^self otherAt: #WindowPopupRequested put: true! !

!WebElement methodsFor: 'private-events'!
shallQueue
	"in #update, shall new element be queued for sending to browser immediatelly or later. For popups 
	it is queued after element is wrapped in popup window, see WebApplication>>handleEvent: "
	^self otherAt: #ShallQueue ifAbsent: [true]! !

!WebElement methodsFor: 'private-identation'!
shouldIdent
	"true, if this element should be idented in html page"
	^self hasTag! !

!WebElement methodsFor: 'events'!
show
	"show me (if not already) on web page"
	self ensureId.
	self scriptAfter: 'document.getElementById(''', self id, ''').style.display=''block'' ' "is this good enough?"! !

!WebElement methodsFor: 'accessing'!
site
	"return a Site on which we are composing a web page"
	^self app site! !

!WebElement methodsFor: 'subelements'!
span
	"Return a current subelement if it is span. Create it if not yet exist"
	"The same as for tables: newTable, newCell, cell, .."
	^self subelementTag: #span! !

!WebElement methodsFor: 'private-streaming'!
streamAttribute: aNameSymbol value: aValue to: aStream for: aSession
	"if value is true/false, then if true, just print an atribute name, otherwise ommit both"
	"multivalue attributes are supposed to be javascript only!! "
	| multiValue |
	aStream nextPut:  $ . 
	((aValue ~= false) | (aValue == true)) ifTrue: [aStream nextPutAll: aNameSymbol asString].
	(aValue isNil or: [aValue isKindOf: Boolean]) ifTrue: [^self]. "just name"
	multiValue := aValue class == OrderedCollection.    aStream nextPutAll: '="'.
	multiValue not ifTrue: [aStream 
		nextPutAll: (AIDASite convertToWeb: aValue asString on: aSession); "UTF-8 encoding"
		nextPutAll: '"'. ^self].
	aValue do: [:value | 
		aStream nextPutAll:  (AIDASite convertToWeb: value asString on: aSession). "UTF-8"
		aStream nextPutAll: '; ']. "javascript sentence separator"
	aStream nextPutAll: '"'.! !

!WebElement methodsFor: 'private-streaming'!
streamAttributesTo: aStream for: aSession
	"start and end of tag is not my responsibility!!"
	self attributes isNil ifTrue: [^self].
	self attributes keysAndValuesDo: [:name :value |
		self streamAttribute: name value: value to: aStream for: aSession]! !

!WebElement methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	"WebElement with some attributes is enclosed inside <div> tag, for tricks with CSS"
	self prepareToHtmlStreamingOn: aSession.
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	self hasTag ifTrue: 
		[aStream nextPutAll: self ident, '<', self tag asString. self streamAttributesTo: aStream for: aSession. 
		aStream nextPutAll: '>', self eol].
	elements notNil ifTrue: [elements do: [:element | 
		element notNil ifTrue: [element streamHtmlTo: aStream for: aRequest on: aSession] ] ].
	self hasTag ifTrue: [aStream nextPutAll: self ident, '</', self tag asString, '>', self eol].
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebElement methodsFor: 'tags'!
structuralTags
	^#(
		div
		span
		article
		aside
		figure
		figcaption
		header
		footer
		hgroup
		nav
		section)! !

!WebElement methodsFor: 'accessing'!
style
	"return a WebStyle on which we are composing a web page"
	^self site style! !

!WebElement methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
style: aString
	"redefine a style of that element with CSS syntax, example:
	style: '{color: blue; font-style: italic}'   "
	self attributesAt: #style put: aString! !

!WebElement methodsFor: 'private-subelements'!
subelement
	"current subelement we are composing on. Similar as for tables"
	^self otherAt: #Subelement ifAbsent: [nil]! !

!WebElement methodsFor: 'private-subelements'!
subelement: aWebElement
	"current subelement we are composing on. Similar as for tables"
	^self otherAt: #Subelement put: aWebElement! !

!WebElement methodsFor: 'private-subelements'!
subelementTag: aTagSymbol
	"Return a current subelement if it is of that tag. Create it if not yet exist"
	"The same principle as for tables: newTable, newCell, cell, .."
	self subelement ifNil: [^self newSubelementTag: aTagSymbol].
	self subelement tag ~= aTagSymbol ifTrue: [self error: 'Current subelement is not of desired tag'].
	^self subelement! !

!WebElement methodsFor: 'tables' stamp: ' 21/4/07 22:07'!
table
	"return a current web table. If not yet exist, create it"
	self initTableIfNessesary.
	^self otherAt: #currentTable! !

!WebElement methodsFor: 'private' stamp: ' 21/4/07 22:07'!
table: aWebTable
	self otherAt: #currentTable put: aWebTable.! !

!WebElement methodsFor: 'tags'!
tag
	" #div, #span, ..."
	^self otherAt: #tag ifAbsent: [nil]! !

!WebElement methodsFor: 'private'!
tag: aSymbol
	" #div, #span, ..."
	self otherAt: #tag put: aSymbol! !

!WebElement methodsFor: 'private-streaming'!
tagClosing
	" /> for XHTML, > otherwise"
	| page |
	page := self webPage.
	page isNil ifTrue: [page := self app context page]. "as a last resort"
	^(page notNil and: [page isXHTML])
		ifTrue: ['/>']
		ifFalse: ['>']! !

!WebElement methodsFor: 'private-translation' stamp: 'janko 9/19/2011 14:21'!
textFromMultilang: aStringOrAssociation on: aSession
	"translate the multilang text in form #fr->'Bonjour' "
	^aSession site translator 
		translate: aStringOrAssociation
		to: aSession languageBasic
		for: self
		on: aSession! !

!WebElement methodsFor: 'attributes' stamp: 'janko 9/20/2011 09:02'!
title: aStringOrAssociation
	"title of an element. it will be shown when mouse pause over it"
	self attributesAt: #title put: aStringOrAssociation! !

!WebElement methodsFor: 'events'!
toogle
	"toogle element visibility on  web page"
	self ensureId.
	self scriptAfter: 
'var e = document.getElementById(''', self id, ''');
if (e.style.display == ''none'') a = ''block''; else a = ''none'';
e.style.display = a; ' 
"	self addText: '<script>Element.toggle(''', self id, ''')</script>'"! !

!WebElement methodsFor: 'events-ajax'!
update
	"recreate that element on app or widget and send to the browser to update itself there too"
	| new ctx |
	self canUpdate ifFalse: [self error: 'Only WebElements (not subclasses) can be updated'].
	self creationMethod isNil ifTrue: [^self]. "in form elements it will return new value!!"
	self id isNil ifTrue: [self error: 'web element to update must have id in advance, use #ensureId !!'].
	('view*' match: self creationMethod asString) ifTrue: 
		[^self error: 'Cannot update views!! View in question: #', self creationMethod].
	ctx := self context.
	ctx announceReplacementWith: self.
	new := (self creationMethod asString last = $: )
		ifTrue: [self creationObject perform: self creationMethod with: self updateArgument ]  "object method: parm"
		ifFalse: [self updateArgument notNil  "try to call the method with that argument anyway"
			ifTrue: [self creationObject perform: (self creationMethod, ':') asSymbol with: self updateArgument]
			ifFalse: [self creationObject perform: self creationMethod] ].
	ctx cancelReplacement. "if not already"
	((new isKindOf: WebElement) and: [new canUpdate]) ifFalse: [self error: 'New is not a web element!!'].
	new id isNil ifTrue: [self error: 'does creation method return created object?'].
	new registerFormElements.
	new prepareToHtmlStreamingOn: self session. "to prepare again"
	new afterCloseUpdate: self afterCloseUpdate. "if any, to signal for later update, after window close for instance"
	new eventHandlers: self eventHandlers.  "preserve handlers through updates"
	self shallQueue ifTrue:  "for popups queuing happens later after wrap in popup window"
		[self session queueUpdateElement: new]. "send immediatelly via WebSocket if open, or in Ajax response"
	^new! !

!WebElement methodsFor: 'private-events'!
updateArgument
	"an argument for an element update call, if any"
	^self otherAt: #UpdateArgument ifAbsent: [nil]! !

!WebElement methodsFor: 'private-events'!
updateArgument: anObject
	"an argument for an element update call, if any"
	self otherAt: #UpdateArgument put: anObject! !

!WebElement methodsFor: 'private-obsolete'!
updateEverySeconds: aNumber
	"OBSOLETE, use Comet techniques instead!!"
	"periodically update itself from server (AJAX) with calling an element method with a parameter"
	self updateEverySeconds: aNumber with: nil! !

!WebElement methodsFor: 'private-obsolete'!
updateEverySeconds: aNumber with: anArgString
	"OBSOLETE, use Comet techniques instead!!"
	"periodically update itself from server (AJAX) with calling an element method with an argument"
	"Prototype specific"
	| url parms  |
	self ensureId. self id.
	url := self ajaxCallUrl. 
	parms:= self ajaxCallUrlParametersFor: self context: self context.
	anArgString notNil ifTrue: [parms := parms, '&parm=', anArgString].
	parms := parms, '&ajaxElementToRecreateId=', self id asString.
	self scriptAfter: '
		function createRequest() {
			new Ajax.Request(''', url, ''', { method: ''post'', postBody: ''', parms, ''',
				onSuccess: function(transport) {
					document.getElementById(''', self id, ''').innerHTML=transport.responseText;
				}
			});
		}
		var intervalID= window.setInterval(createRequest, ', (aNumber*1000) printString, ');'.
"
	idToUpdate := anElementToUpdate notNil 
		ifTrue: [self check: anElementToUpdate on: aContext. anElementToUpdate id]
		ifFalse: [#nothingToUpdate]. 
	url := self ajaxCallUrl. 
	parms:= self ajaxCallUrlParametersFor: anElementToUpdate context: aContext.
	anArgString notNil ifTrue: [parms := parms, '&parm=', anArgString].
	anArg2String notNil ifTrue: [parms := parms, '&parm2=', anArg2String].
	anElementToRecreate notNil ifTrue:
		[self check: anElementToRecreate on: aContext.
		parms := parms, '&ajaxElementToRecreateId=', anElementToRecreate id asString].
"


"	this original Prototype one caues memory leak!! "
"	self scriptAfter: 'new Ajax.PeriodicalUpdater(''', self id asString, ''', ''', url, 
		''', {method: ''post'', postBody: ''', parms, 
		''', evalScripts: true, frequency: ', aNumber printString, '})'
"! !

!WebElement methodsFor: 'events-ajax'!
updateWith: anArgObject
	"recreate that element by calling cration method with one argument,
	and send to the browser to update itself there"
	anArgObject notNil ifTrue: [self updateArgument: anArgObject].
	^self update! !

!WebElement methodsFor: 'accessing'!
webPage
	"find a WebPage up in the hierarchy on which this element belongs"
	^(self parent notNil and: [self parent isWebElement])
		ifTrue: [self parent webPage]
		ifFalse: [nil]! !

!WebElement methodsFor: 'accessing'!
widget
	"on which widget this element is shown, if any"
	self parent isNil ifTrue: [^nil].
	^self parent widget! !

!WebElement methodsFor: 'private'!
wrap
	"wrap this element in <span> element to become updatable, if the element is basic one, 
	like button or input field"
	| wrap |
	self isWrapped ifTrue: [^nil].
	self parent isNil ifTrue: [self error: 'cannot wrap yet'].
	wrap := WebElement newSpan.
	wrap parent: self parent.
	self parent elements
		remove: self;
		add: wrap.
	wrap add: self. self parent: wrap.
	wrap ensureId.
	self otherAt: #Wrapped put: true.! !

!WebElement class methodsFor: 'color values' stamp: ' 21/4/07 22:07'!
colorDictionary
	"return a dictionary of color names as keys and hex values for colors in 
	some web elements such as page and table background, text, links etc."
	Colors isNil ifTrue: [self initColorDictionary].
	^Colors! !

!WebElement class methodsFor: 'color values' stamp: ' 21/4/07 22:07'!
initColorDictionary
	"WebElement initColorDictionary"
	"WebElement colorDictionary"
	Colors := IdentityDictionary new.
	Colors 
		at: #white				put: #'ffffff';
		at: #red					put: #'ff0000' ;
		at: #green				put: #'00ff00' ;
		at: #blue				put: #'0000ff' ;
		at: #magenda			put: #'ff00ff';
		at: #cyan				put: #'00ffff' ;
		at: #yellow				put: #'ffff00' ;
		at: #black				put: #'000000';

		at: #aquamarine			put: #'70db93';

		at: #bakerschocolade	put: #'5c3317';
		at: #blueviolet	put: #'9f5f9f';
		at: #brass		put: #'b5a642';
		at: #brightgold	put: #'d9d919';
		at: #brown		put: #'a62a2a';
		at: #bronze		put: #'8c7853';
		at: #bronzeii		put: #'a67d3d';

		at: #cadetblue		put: #'5f9f9f';
		at: #coolcooper		put: #'d98719';
		at: #cooper			put: #'b87333';
		at: #coral			put: #'ff7f00';
		at: #cornflowerblue	put: #'42426f';

		at: #darkbrown		put: #'5c4033';
		at: #darkgreen		put: #'2f4f2f';
		at: #darkgreencooper put: #'4a766e';
		at: #darkolivegreen	put: #'4f4f2f';
		at: #darkorchid		put: #'9932cd';
		at: #darkpurple		put: #'871f78';
		at: #darkslateblue	put: #'6b238e';
		at: #darkslategrey	put: #'2f4f4f';
		at: #darktan			put: #'97694f';
		at: #darkturquoise	put: #'7093db';
		at: #darkwood		put: #'855e42';
		at: #dimgrey		put: #'545454';
		at: #dustyrose		put: #'856363';

		at: #feldspar			put: #'d19275';
		at: #firebrick			put: #'8e2323';
		at: #forestgreen		put: #'238e23';

		at: #gold			put: #'cd7f32';
		at: #goldenrod		put: #'dbdb70';
		at: #grey			put: #'c0c0c0';
		at: #greencooper	put: #'527f76';
		at: #greenyellow		put: #'93db70';

		at: #huntergreen		put: #'215e21';

		at: #indianred		put: #'4e2f2f';

		at: #khaki		 	put: #'9f9f5f';

		at: #lightblue		put: #'c0d9d9';
		at: #lightgrey		put: #'a8a8a8';
		at: #lightsteelblue	put: #'8f8fbd';
		at: #lightwood		put: #'e9c2a6';
		at: #limegreen		put: #'32cd32';

		at: #mandarianorange	put: #'e47833';
		at: #maroon			put: #'8e236b';
		at: #mediumaquamarine	put: #'32cd99';
		at: #mediumblue	put: #'3232cd';
		at: #mediumforestgreen	put: #'6b8e23';
		at: #mediumgoldenrod	put: #'eaeaae';
		at: #mediumorchid	put: #'9370db';
		at: #mediumseagreen	put: #'426f42';
		at: #mediumslateblue	put: #'7f00ff';
		at: #mediumspringgreen	put: #'7fff00';
		at: #mediumturquoise	put: #'70dbdb';
		at: #mediumvioletred		put: #'db7093';
		at: #mediumwood	put: #'a68064';
		at: #midnightblue	put: #'2f2f4f';
		
		at: #navyblue		put: #'23238e ';
		at: #neonblue		put: #'4d4dff';
		at: #neonpink		put: #'ff6ec7';
		at: #newmidnightblue	put: #'00009c';
		at: #newtan			put: #'ebc79e ';
		
		at: #oldgold			put: #'cfb53b ';
		at: #orange			put: #'ff7f00';
		at: #orangered		put: #'ff2400';
		at: #orchid			put: #'db70db';

		at: #palegreen		put: #'8fbc8f';
		at: #pink			put: #'bc8f8f';
		at: #plum			put: #'eaadea';

		at: #quartz			put: #'d9d9f3';

		at: #richblue			put: #'5959ab';

		at: #salmon			put: #'6f4242';
		at: #scarlet			put: #'8c1717';
		at: #seagreen		put: #'238e68';
		at: #semiswetchocolate		put: #'6b4226';
		at: #sienna			put: #'8e6b23';
		at: #silver			put: #'e6e8fa';
		at: #skyblue			put: #'3299cc';
		at: #slateblue		put: #'007fff';
		at: #spicypink		put: #'ff1cae';
		at: #springgreen		put: #'00ff7f';
		at: #steelblue		put: #'236b8e';
		at: #summersky		put: #'38b0de';

		at: #tan				put: #'db9370';
		at: #thistle			put: #'d8bfd8';
		at: #turquoise		put: #'adeaea';

		at: #verydarkbrown	put: #'5c4033';
		at: #verylightgrey	put: #'cdcdcd';
		at: #violet			put: #'4f2f4f';
		at: #violetred		put: #'cc3299';

		at: #wheat			put: #'d8d8bf';
		at: #yellowgreen		put: #'99cc32'.! !

!WebElement class methodsFor: 'testing'!
isWebApplication
	"for tests in climbing on the stack"
	^false! !

!WebElement class methodsFor: 'testing'!
isWebWidget
	"for tests in climbing on the stack"
	^false! !

!WebElement class methodsFor: 'instance creation'!
new
	| instance ctx |
	instance := super basicNew initialize.
	self == WebElement ifTrue: 
		[instance setCreationMethodAndObject. "Widget or App"
		ctx := instance context.  "?? how this work?" "because initialy nil, it start climbing the stack?"
		instance creationContext: ctx.
		instance checkIfFirstInMethodOn: ctx.  "and set the #firsInMethod"
"		instance isFirstInMethod ifTrue:
			[instance setDiv; registerId]. " "fist elements in creation method are always DIVs and have ids"
		(ctx notNil and: [ctx currentReplacement notNil]) ifTrue: 
			"replace id from old element in Ajax updating, see WebApplication>>ajaxUpdate:from:on:"
			[ctx replaceIdIn: instance with: ctx currentReplacement. 
			ctx cancelReplacement] ].
	^instance! !

!WebElement class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newClass: aSymbol
	"new with CSS class as specified"
	^self new class: aSymbol! !

!WebElement class methodsFor: 'instance creation'!
newDiv
	"element enclosed in div tag"
	^self new 
		setDiv;
		ensureId. "let all divs have ids in advance, for potential Ajax from action blocks like 'e update' "! !

!WebElement class methodsFor: 'instance creation'!
newId: aSymbol
	"new with id as specified. Be sure that you set some tag too, otherwise this id attribute won't be shown!!"
	^self new
		setDiv;
		id: aSymbol! !

!WebElement class methodsFor: 'instance creation'!
newSpan
	"element enclosed in span tag"
	^self new 
		setSpan;
		ensureId. "let all spans have ids in advance, for potential Ajax from action blocks like 'e update' "! !

!WebElement class methodsFor: 'color values' stamp: ' 21/4/07 22:07'!
valueForColor: aColorSymbolOrString
	"return a hex value for specified color. Case of color string is not important. 
	return red if color is unknown"
	| color |
	color := aColorSymbolOrString asString asLowercase asSymbol.
	^self colorDictionary at: color ifAbsent: [^self colorDictionary at: #red].

"
WebElement valueForColor: 'blue' 
"! !

!WebEvent methodsFor: 'accessing'!
app
	^self context app! !

!WebEvent methodsFor: 'accessing'!
context
	"a context in which this element occured"
	^context! !

!WebEvent methodsFor: 'private'!
context: aWebContextOrNumber
	context := aWebContextOrNumber! !

!WebEvent methodsFor: 'accessing'!
element
	"a web element on which this handler responds to events" 
	^element! !

!WebEvent methodsFor: 'private'!
element: aWebElementOrId
	element := aWebElementOrId! !

!WebEvent methodsFor: 'accessing'!
event
	"on which event this handler responds, like #click, #mouseOver etc." 
	^event! !

!WebEvent methodsFor: 'private'!
event: aSymbol
	event := aSymbol! !

!WebEvent methodsFor: 'parsing'!
fromJSON: aString
	"get an event from JSON message"
	| dict |
	dict := WebJSON parse: aString.
	self 	event: (dict at: 'event') asSymbol. "event is mandatory"
	(dict at: 'id') notNil ifTrue: [self element: (dict at: 'id') asSymbol].
	(dict at: 'context') notNil ifTrue: [self context: (dict at: 'context') asInteger].
	self pageUrl: (AIDASite convertFromWebString: (dict at: 'pageUrl')). "also mandatory"
	(dict includesKey: 'value') ifTrue: [self value: (dict at: 'value')].! !

!WebEvent methodsFor: 'testing'!
isAjaxRequest
	^false! !

!WebEvent methodsFor: 'testing'!
isClassicalRequest
	"classical requests are non Ajax HTTPRequests, not WebEvents"
	^false! !

!WebEvent methodsFor: 'testing'!
isWebEvent
	^true! !

!WebEvent methodsFor: 'testing'!
isWebRequest
	^false! !

!WebEvent methodsFor: 'accessing'!
pageUrl
	"Url of the page on which this event occured"
	^pageUrl! !

!WebEvent methodsFor: 'private'!
pageUrl: aString
	"Url of the page on which this event occured"
	pageUrl := aString! !

!WebEvent methodsFor: 'accessing'!
pageView
	"get the view from the Url"
	| query view |
	query := self pageUrl readStream upTo: $? ; upToEnd.
	query := (query readStream upTo: $# ) trimBlanks. "skip #anchor if any"
	(query isEmpty or: [(query includesSubString: 'view=') not ]) ifTrue: [^#main].
	view := query readStream upToAll: 'view';  skip: 5 "view="; upTo: $& .
	 ^view asSymbol! !

!WebEvent methodsFor: 'accessing-value'!
postData
	"parse a submited form in value into a postData with key/value pairs"
	"From Swazoo HTTPPost>>urlencodedDataFrom:"
	| postData tokens |
	postData := HTTPPostDataArray new.
	tokens := HTTPString subCollectionsFrom: (HTTPString stringFromBytes: self value) delimitedBy: $&.
	(tokens collect: [:each | HTTPString subCollectionsFrom: each delimitedBy: $=]) 
		do: 	[:keyVal | | datum key |
			datum := HTTPPostDatum new.
			datum value: (HTTPString decodedHTTPFrom: 
 				(keyVal last collect: [:char | char = $+ ifTrue: [Character space] ifFalse: [char]])).
			key := (HTTPString decodedHTTPFrom: 
 				(keyVal first collect: [:char | char = $+ ifTrue: [Character space] ifFalse: [char]])).
			postData at: key put: datum].
	^postData

"WebEvent new value: 'a=&c=d'; postData"! !

!WebEvent methodsFor: 'accessing-value'!
postKeysAndValuesDo: aTwoArgBlock 
	self postData 
		keysAndValuesDo: [:key :each | aTwoArgBlock value: key value: each value]! !

!WebEvent methodsFor: 'private'!
printString
	^'aWebEvent
	event: ', self event printString, '
	element: ', (self element notNil 
		ifTrue: [(self element isKindOf: Symbol) 
			ifTrue: [self element printString] 
			ifFalse: [self element class name, ' id: ', self element id printString] ]
		ifFalse: ['nil']), '
	context: ', (self context notNil 
		ifTrue: [(self context isKindOf: Number)  
			ifTrue: [self context printString] 
			ifFalse: [self context class name, ' ', self context id printString] ]
		ifFalse: ['nil'] ), '
	value: ', self value printString! !

!WebEvent methodsFor: 'parsing'!
reconnectOn: aSession
	"find a right element and a context (at start we have only their ids)"
	"deal specially with page unload event"
	| object app |
	object := aSession site urlResolver objectOnUrl: self relativeUrl.
	app := aSession webAppFor: object. 
	app isNil ifTrue: [^self].
	self context: (self context notNil
		ifTrue: [app contexts at: self context]
		ifFalse: [app contextForView: self pageView]). "for unload event"
	self context isNil ifTrue: [^self].
	self context event: self.
	#unload = self event ifTrue:
		[app contexts 
			detect: [:ctx | ctx window id = self element 
				ifTrue: [self element: ctx window. ^self] ifFalse: [false] ] 
			ifNone: [self element: nil. ^self] ].
	(  #( #load #newtab) includes: self event) "page events"
		ifTrue: [self element: self context page]  "element is entire page"
		ifFalse: [self element: (self context elementId: self element)].! !

!WebEvent methodsFor: 'accessing'!
relativeUrl
	"from page Url, without host and query part"
	| stream relative ch |
	stream := self pageUrl readStream.
	stream upTo: $/; upTo: $/; upTo: $/ . "skip protocol and hostname"
	relative := WriteStream on: String new.
	[stream atEnd] whileFalse:   "up to query part or #, if any"
		[ch := stream next. 
		(ch = $? or: [ch = $#]) 
			ifTrue: [stream upToEnd]
			ifFalse: [relative nextPut: ch] ].
	^'/', relative contents! !

!WebEvent methodsFor: 'accessing-value'!
value
	"corresponding value, if any. Like field value in submit event"
	^value! !

!WebEvent methodsFor: 'private'!
value: aString
	"corresponding value, if any. Like field value in submit event"
	value := aString! !

!WebEvent class methodsFor: 'instance creation'!
fromJSON: aJSONString on: aSession
	^super new
		fromJSON: aJSONString;
		reconnectOn: aSession! !

!WebEventHandler methodsFor: 'private'!
actionBlocks
	actionBlocks isNil ifTrue: [self initActionBlocks].
	^actionBlocks! !

!WebEventHandler methodsFor: 'actions'!
addAcceptPostedInput
	"event is a post of form element input, accept it"
	^self addActionBlock: [:receivedEvent || field |
		field := receivedEvent element.
		field acceptInputFromValue: receivedEvent value.
		field announceChange.
		(field isSingleFieldPost and: [field isValid])
			ifTrue: [field save] ] "otherwise save at complete form submit"! !

!WebEventHandler methodsFor: 'actions'!
addAcceptSubmittedForm
	"event is a submit of a form, accept it"
	^self addActionBlock: [:receivedEvent || form |
		form := receivedEvent element form.
		form acceptFormInputFrom: receivedEvent.
		form isValid ifTrue: [form save].
		form allFields do: [:field | 
			field isButton ifFalse: "don't handle itself once again"
				[field handleSubmitEvent: receivedEvent] ] ]  "call #submit event blocks on all form fields "! !

!WebEventHandler methodsFor: 'actions'!
addActionBlock: aBlock
	^self actionBlocks add: aBlock! !

!WebEventHandler methodsFor: 'actions'!
addAnswer: anObject
	"set answer to current context"
	^self addActionBlock:
		[:receivedEvent |
		receivedEvent context answer: anObject].! !

!WebEventHandler methodsFor: 'actions' stamp: 'janko 10/31/2011 20:08'!
addCloseWindow
	"closes that window and also its execution context"
	| ctx parentCtx |
	^self addActionBlock:
		[:receivedEvent |
		ctx := receivedEvent context. 
		ctx isFirst ifFalse:
			[parentCtx := ctx parent.
			ctx result: WebElement basicNew.
			parentCtx result: ctx result. "just in case"
			parentCtx answer: ctx answer. "if any"
			ctx first mainSemaphore signal. " to ensure continuing main thread"
			ctx parent isFirst ifTrue: [ctx parent stopProcess].  "we don't need it anymore"
			parentCtx window popupStub update. "to actually close popup window on browser"
			self runCloseEventHandler. "to run all action blocks on #close pseudo event"
			ctx window afterCloseUpdate notNil ifTrue: [ctx window afterCloseUpdate update].
			ctx close] ] "finaly the time to safely close our context"! !

!WebEventHandler methodsFor: 'actions'!
addJsonExists
	"jsonExists event: JSON support present in user's browser "
	^self addActionBlock:
		[:receivedEvent |
		receivedEvent context session 
			setJsonExists]! !

!WebEventHandler methodsFor: 'actions'!
addNewTab
	"page opened in a new tab"
	^self addActionBlock:
		[:receivedEvent | ]! !

!WebEventHandler methodsFor: 'actions'!
addPageUnload
	"unload event: page was closed or going to another one"
	^self addActionBlock:
		[:receivedEvent |
		receivedEvent context app 
			deactivateView: receivedEvent pageView]! !

!WebEventHandler methodsFor: 'actions'!
addPopup: anElement onStub: aStubElement
	^self addActionBlock:
		[:receivedEvent |
		anElement 
			elementToReplace: aStubElement; 
			creationContext: receivedEvent context; "changed to popup in WebApplication respondToEvent:"
			resetShallQueue; "queue for sending to browser not in #update but after popup is wraped in window"
			update]! !

!WebEventHandler methodsFor: 'actions'!
addUpdate: anElement with: anArgObject
	^self addActionBlock:
		[:receivedEvent |
		anElement updateWith: anArgObject] "if any (not nil)"! !

!WebEventHandler methodsFor: 'accessing'!
context
	"a web exectution context on which element with this handler was created"
	^self element context! !

!WebEventHandler methodsFor: 'accessing'!
element
	"a web element on which this handler responds to events" 
	^element! !

!WebEventHandler methodsFor: 'private'!
element: aWebElement
	element := aWebElement! !

!WebEventHandler methodsFor: 'accessing'!
event
	"on which event this handler responds, like #click, #mouseOver etc." 
	^event! !

!WebEventHandler methodsFor: 'private'!
event: aSymbol
	event := aSymbol! !

!WebEventHandler methodsFor: 'actions'!
handleEvent: aWebEvent
	"Execute all action blocks in order and return result of the last. Result of last 
	action block should be a kind of WebElement"
	| result |
	self actionBlocks do: [:actionBlock | 
		result := actionBlock numArgs = 0 
			ifTrue: [actionBlock value]  "onClickDo: blocks have usually no argument"
			ifFalse: [actionBlock value: aWebEvent] ].
	^result  "only last result is returned, is that ok? "! !

!WebEventHandler methodsFor: 'initialize-release'!
initActionBlocks
	actionBlocks := OrderedCollection new.! !

!WebEventHandler methodsFor: 'actions'!
runCloseEventHandler
	"run all action blocks on the closed widget, on #close pseudo event"
	| handler |
	handler := self element widget eventHandlerFor: #close.
	handler notNil ifTrue:
		[^handler handleEvent: nil]. "event is not important"! !

!WebEventHandler class methodsFor: 'instance creation'!
newForEvent: aSymbol on: aWebElement 
	^super new
		element: aWebElement;
		event: aSymbol! !

!WebFieldSet methodsFor: 'private'!
hasTag
	^super hasTag! !

!WebFieldSet methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	"Initialize a newly created instance. This method must answer the receiver."

	" *** Replace this comment with the appropriate initialization code *** "
	^self! !

!WebFieldSet methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
legend
	^legend! !

!WebFieldSet methodsFor: 'accessing' stamp: 'janko 9/19/2011 14:23'!
legend: aStringOrAssociation "multilang assoc"
	"a label to be shown on left top corner of fieldset"
	legend := aStringOrAssociation! !

!WebFieldSet methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession 
	| text |
	self prepareToHtmlStreamingOn: aSession.
	aStream nextPutAll: self ident , '<fieldset'.
	self 
		streamAttributesTo: aStream
		for: aSession.
	aStream nextPutAll: '>' , self eol.
	self legend notNil ifTrue: [
		text := self legend aidaIsAssociation "multilingual"
			ifTrue: [self textFromMultilang: self legend on: aSession]
			ifFalse: [self legend].
		aStream nextPutAll: self identMore , '<legend>' , 
		(AIDASite convertToWeb: text on: aSession) , 
		'</legend>' , self eol].
	super 
		streamHtmlTo: aStream for: aRequest on: aSession.
	aStream nextPutAll: self ident , '</fieldset>' , self eol! !

!WebFieldSet class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	"Answer a newly created and initialized instance."
	^super new initialize! !

!WebFieldSet class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newLegend: aString
	^self new legend: aString! !

!WebFileInputField methodsFor: 'aspect adapting' stamp: 'mu 5/5/2008 10:48'!
acceptFileAttributesFrom: aRequest field: aString
	| mutator |
	self filenameAspect notNil ifTrue:
		[| filename |
		mutator := (self filenameAspect asString, ':') asSymbol.
		filename := AIDASite convert: (aRequest postDataAt: aString) filenameWithoutPath fromCodepage: self session codePage.
		self object perform: mutator with: filename].
	self contentTypeAspect notNil ifTrue:
		[mutator := (self contentTypeAspect asString, ':') asSymbol.
		self object perform: mutator with: (aRequest postDataAt: aString) contentType]! !

!WebFileInputField methodsFor: 'aspect adapting' stamp: ' 21/4/07 22:07'!
aspect: aSymbol filenameAspect: aSymbol2 contentTypeAspect: aSymbol3 forObject: anObject
	^self aspect: aSymbol for: anObject; 
		filenameAspect: aSymbol2; 
		contentTypeAspect: aSymbol3! !

!WebFileInputField methodsFor: 'aspect adapting' stamp: ' 21/4/07 22:07'!
aspect: aSymbol filenameAspect: aSymbol2 forObject: anObject
	^self aspect: aSymbol for: anObject; filenameAspect: aSymbol2! !

!WebFileInputField methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
contentTypeAspect
	^contentTypeAspect! !

!WebFileInputField methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
contentTypeAspect: aSymbol
	contentTypeAspect := aSymbol! !

!WebFileInputField methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
filenameAspect
	^filenameAspect! !

!WebFileInputField methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
filenameAspect: aSymbol
	filenameAspect := aSymbol! !

!WebFileInputField methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	super initialize.
	self type: 'file'.! !

!WebFileInputField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
isFileInputField
	^true! !

!WebFileInputField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
isInputField
	^false! !

!WebFileInputField methodsFor: 'private' stamp: ' 21/8/07 09:38'!
isStreamed
	"file is received directly from request into output stream"
	^self writeStream notNil or: [self writeBlock notNil]! !

!WebFileInputField methodsFor: 'accessing'!
object: anObject
	"set or change the object of model adaptor"
	self adaptor isNil  ifTrue: [self adaptor: AidaModelAdaptor new].
	self adaptor subject: anObject! !

!WebFileInputField methodsFor: 'private'!
prepareAttributesToStreamOn: aSession
	"just override value preparation to nothing"! !

!WebFileInputField methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
writeBlock
	^writeBlock! !

!WebFileInputField methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
writeBlock: aBlockClosure
	"this block will be called just before start of streaming to writeStream"
	writeBlock := aBlockClosure! !

!WebFileInputField methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
writeStream
	^writeStream! !

!WebFileInputField methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
writeStream: aStream
	"output binary stream where uploaded file will be directy writen"
	writeStream := aStream! !

!WebFileInputField class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol filenameAspect: aSymbol2 contentTypeAspect: aSymbol3 forObject: anObject

	^self new aspect: aSymbol for: anObject; 
		filenameAspect: aSymbol2;
		contentTypeAspect: aSymbol3! !

!WebFileInputField class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol filenameAspect: aSymbol2 forObject: anObject

	^self new aspect: aSymbol for: anObject; 
		filenameAspect: aSymbol2! !

!WebFileInputField class methodsFor: 'instance creation' stamp: ' 21/8/07 09:38'!
beforeStreamingDo: aBlock filenameAspect: aSymbol2 contentTypeAspect: aSymbol3 forObject: anObject
	"A block will be called just before streaming begins, with a HTTPPostDatum as parameter. Block
	  must set a write stream in datum (for instance open an output file and stream on it)"
	"example block: [:datum | datum writeStream: 'myfile' writeStream binary] "
	^self new 
		writeBlock: aBlock; 
		object: anObject; 
		filenameAspect: aSymbol2;
		contentTypeAspect: aSymbol3! !

!WebFileInputField class methodsFor: 'instance creation' stamp: ' 21/8/07 09:38'!
beforeStreamingDo: aBlock filenameAspect: aSymbol2 forObject: anObject
	"A block will be called just before streaming begins, with a HTTPPostDatum as parameter. Block
	 must set a write stream in datum (for instance open an output file and stream on it)"
	"example block: [:datum | datum writeStream: 'myfile' writeStream binary] "
	"Don't forget to close such a stream after!! This can be done in App action method"
	^self new 
		writeBlock: aBlock; 
		object: anObject; 
		filenameAspect: aSymbol2! !

!WebFileInputField class methodsFor: 'instance creation' stamp: ' 21/8/07 09:38'!
toStream: aStream filenameAspect: aSymbol2 contentTypeAspect: aSymbol3 forObject: anObject
	"wrrite uploaded file directly to aStream, which must be binary"
	^self new 
		writeStream: aStream; 
		object: anObject; 
		filenameAspect: aSymbol2;
		contentTypeAspect: aSymbol3! !

!WebFileInputField class methodsFor: 'instance creation' stamp: ' 21/8/07 09:38'!
toStream: aStream filenameAspect: aSymbol2 forObject: anObject
	"wrrite uploaded file directly to aStream, which must be binary"
	^self new 
		writeStream: aStream; 
		object: anObject; 
		filenameAspect: aSymbol2! !

!WebFileInputTest methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
file
	^file! !

!WebFileInputTest methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
file: anObject
	file := anObject! !

!WebFileInputTest methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
filename
	^filename! !

!WebFileInputTest methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
filename: anObject
	filename := anObject! !

!WebFileInputTest methodsFor: 'testing' stamp: 'janko 7/24/2011 21:13'!
offtestFileUpload
	"this test temporarly off"
	| request session app |
	request := self postFileRequest.
	session := WebSession new. session lastRequest: request. request session: session.
	app := WebApplication new session: session.
	app ensureContextForView: #main for: request.
	app add: 
		((WebFileInputField aspect: #file filenameAspect: #filename forObject: self) name: 'field7').
	app window registerFormElements.
	"simulate receiving a request"
	app acceptInputsAndActionFrom: request.
	self assert: self filename = 'event.ical'.
	self assert: (self file readStream upTo: Character cr) = 'BEGIN:VCALENDAR'.! !

!WebFileInputTest methodsFor: 'testing' stamp: 'janko 7/24/2011 21:13'!
offtestStreamedFileUpload
	"this test temporarly off"
	| request session app stream |
	request := self postFileRequest.
	session := WebSession new. session lastRequest: request. request session: session.
	app := WebApplication new session: session.
	app ensureContextForView: #main for: request.
	stream := WriteStream on: ByteArray new.
	app add: 
		((WebFileInputField toStream: stream filenameAspect: #filename forObject: self) name: 'field7').
	app window registerFormElements.
	"simulate receiving a request"
	app context form registerStreamedFieldsInto: request. "announce where to stream uploaded file"
	app acceptInputsAndActionFrom: request. "this will trigger defered parsing of postdata and stream it to stream"
	self file: stream contents asString.
	self assert: self filename = 'event.ical'.
	self assert: (self file readStream upTo: Character cr) = 'BEGIN:VCALENDAR'.! !

!WebFileInputTest methodsFor: 'setup' stamp: ' 21/8/07 09:38'!
postFileRequest
	| requestStream |
	requestStream := SwazooStream on: String new.
	requestStream
		nextPutLine: 'POST  /document/aab.html HTTP/1.1';
		nextPutLine: 'Connection: Keep-Alive';
		nextPutLine: 'User-Agent: Mozilla/4.72 [en] (X11; I; Linux 2.3.51 i686)';
		nextPutLine: 'Host: biart.eranova.si';
		nextPutLine: 'Referer: http://www.bar.com/takeMeThere.html';
		nextPutLine: 'Content-Type: multipart/form-data; boundary= -----------------20752836116568320241700153999';
		nextPutLine: 'Content-Length: 845';
            crlf;
		nextPutLine: '-------------------20752836116568320241700153999';
		nextPutLine: 'Content-Disposition: form-data; name="id5273"';
		crlf; 
		nextPutLine: 'main';
		nextPutLine: '-------------------20752836116568320241700153999';
		nextPutLine: 'Content-Disposition: form-data; name="field2"';
		crlf; crlf;
		nextPutLine: '-------------------20752836116568320241700153999';
		nextPutLine: 'Content-Disposition: form-data; name="field7"; filename="event.ical"';
		nextPutLine: 'Content-Type: application/octet-stream';
		crlf; 
		nextPutLine: 'BEGIN:VCALENDAR';
		nextPutLine: 'PRODID:-//Squeak-iCalendar//-';
		nextPutLine: 'VERSION:2.0';
		nextPutLine: 'X-WR-CALNAME:test';
		nextPutLine: 'METHOD:PUBLISH';
		nextPutLine: 'BEGIN:VEVENT';
		nextPutLine: 'UID:an event with a start date and not date and time';
		nextPutLine: 'CATEGORIES:category1,category2';
		nextPutLine: 'CREATED:20050501T110231Z';
		nextPutLine: 'SEQUENCE:0';
		nextPutLine: 'SUMMARY:aTitle';
		nextPutLine: 'PRIORITY:5';
		nextPutLine: 'DTSTART;VALUE=DATE:20050425';
		nextPutLine: 'END:VEVENT';
		nextPutLine: 'END:VCALENDAR';
		crlf;
		nextPutLine: '-------------------20752836116568320241700153999';
		nextPutLine: 'Content-Disposition: form-data; name="attach"';
		crlf;
		nextPutLine: 'Attach';
		nextPutLine: '-------------------20752836116568320241700153999--'.

	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)! !

!WebForm methodsFor: 'model posting'!
acceptFormInputFrom: anEventOrRequest
 	"read a post data from request or WebEvent and write values to the valueModels of fields in a form.
	For checkboxes and radiobuttons, a set of values is expected under the same name"
	| postData value |
	postData := HTTPPostDataArray new. "like Dictionary, but multiple values per key"
	self uncheckAllProperChecboxesFor: anEventOrRequest. 
	self uncheckAllProperRadioButtonsFor: anEventOrRequest.
	anEventOrRequest  postKeysAndValuesDo: [:key :vlue | postData at: key put: vlue].
	self allFieldsIncludingSubforms do: [:field | 
		(postData includesKey: field name) ifTrue:
			[value := postData at: field name.
			field isMenu 
				ifTrue: [field acceptFormInputFrom: postData]
				ifFalse: [	field isFileInputField 
					ifTrue: 
						[field isStreamed ifFalse: [field value: (postData at: field name)] "streamed already read". 
						field acceptFileAttributesFrom: anEventOrRequest field: field name]
					ifFalse: [field acceptInputFromValue: value] ] "all other form elements"
			] 
		]! !

!WebForm methodsFor: 'model posting'!
acceptInputsFrom: aRequest
	"this method read form inputs (if any) and if all values pass validation, write them to the appropriate 
	aspects of model  objects. If entire form is validated, it saves inputs to model, all at once"
	| field |
	self acceptFormInputFrom: aRequest.  "just fields which are in request, can be only a single one in Ajax!!"
	aRequest isAjaxPostWithSingleInput  "form or single field validation"
		ifTrue: 
			[field := self fieldNamed: aRequest ajaxSingleInputName. 
			field isValid ifTrue: [field save] ]
		ifFalse: [self isValid ifTrue: [self save] ].    "check in action methods for validation again!!"! !

!WebForm methodsFor: 'accessing' stamp: 'jm 4/24/2009 20:44'!
action
	"Url of where to post form inputs, it is optional"
	^action! !

!WebForm methodsFor: 'accessing' stamp: 'jm 4/24/2009 20:44'!
action: aString
	"Url of where to post form inputs, it is optional"
	action := aString! !

!WebForm methodsFor: 'private'!
addSubform: aWebForm
	subforms isNil ifTrue: [self initSubforms].
	(subforms includes: aWebForm) ifTrue: [^nil].
	subforms copy do: [:form | 
		form parent == aWebForm parent ifTrue:  "parent was updated/recreated, old form discarded"
			[self removeSubform: form] ].
	subforms add: aWebForm.
	aWebForm superform: self! !

!WebForm methodsFor: 'private-fields' stamp: ' 21/8/07 09:38'!
addToFields: aWebFormElement
	"and to tab order"
	(self alreadyRegistered: aWebFormElement) ifTrue: [^self error: 'already exist!!'].
	self fields at: aWebFormElement name put: aWebFormElement.
	self tabOrder add: aWebFormElement.
	aWebFormElement isStreamed ifTrue: [self streamedFieldSet add: aWebFormElement].
	^self fieldSet add: aWebFormElement! !

!WebForm methodsFor: 'accessing' stamp: 'jm 11/11/2010 15:44'!
allFields
	"return all fields (form elements) in this form"
	^self fields values asSet
		remove: self fieldSet ifAbsent: [];
		remove: self streamedFieldSet ifAbsent: [];
		yourself
! !

!WebForm methodsFor: 'accessing'!
allFieldsIncludingSubforms
	"return all fields (form elements) in down the form hierarchy"
	| set  |
"	count := 0.
	stContext := thisContext sender.   ""TEMPORARY, FOR DEBUGGING!!""
	[stContext notNil] whileTrue: [
		(stContext receiver isKindOf: WebForm) ifTrue: 
			[count := count +1].
		stContext := stContext sender].
	count > 20 ifTrue: [self error: 'WebForm allFields infinite recursion!!'].
"
	set := self allFields.
	self subforms do: [:subform | set addAll: subform allFieldsIncludingSubforms].
	^set! !

!WebForm methodsFor: 'private-fields' stamp: ' 21/4/07 22:07'!
alreadyRegistered: aWebFormElement
	^self fieldSet includes: aWebFormElement! !

!WebForm methodsFor: 'private-ajax'!
announceChange: aFormElement
	self announcers do: [:each | each value: aFormElement]! !

!WebForm methodsFor: 'private-ajax'!
announcers
	"whom to announce form field change. A collection of blocks to call"
	^self otherAt: #announcers ifAbsentPut: [OrderedCollection new]! !

!WebForm methodsFor: 'model adapting'!
bufferedValueAspect: aSymbol for: anObject
	"find a bufered (not yet saved) value of this aspect of domain object"
	| flds |
	flds := self allFields select: [:each | each adaptor subject == anObject].
	^(flds detect: [:each | each adaptor aspect = aSymbol] ifNone: [^nil])
		adaptor buffer! !

!WebForm methodsFor: 'model posting'!
buttonFrom: aRequest
	"return a button pressed. For defining an action method or block to be called"
	"note that image buttons send values in coordinates, like search.x search.y"
	| btname buttonNames postKeys |
	btname := aRequest postDataAt: 'ajaxPressedButton'.  "in case of Ajax form submit"
	btname notNil ifTrue: [^btname value].
	buttonNames := (self fieldSet select: [:each | each isButton]) 
		collect: [:each | each name].
	postKeys := aRequest postDataKeys collect: [:key | key copyUpTo: $. ]. "remove .x .y"
	btname := buttonNames detect: [:each | postKeys includes: each] ifNone: [''].
	^self fieldNamed: btname.! !

!WebForm methodsFor: 'validation'!
collectErrorTexts
	"collect all validation error texts, separated by <br>"
	^self invalidFields 
		inject: ''
		into: [:text :each | text, each errorText, '<br>'].! !

!WebForm methodsFor: 'private-streaming'!
ensureOnSubmitReturnFalseAtEnd
	"for onSubmit script, ensure that 'return false' (if any) will be the last sentence in the script"
	| coll new |
	coll := self attributesAt: #onSubmit. coll isNil ifTrue: [^nil].
	(coll isKindOf: OrderedCollection) ifFalse: [^nil].
	(coll contains: [:each | '*return false*' match: each]) ifFalse: [^nil].
	new := coll reject: [:each | '*return false*' match: each].  "also to avoid duplicates"
	new := new add: 'return false'; yourself.
	self attributesAt: #onSubmit put: new.! !

!WebForm methodsFor: 'accessing'!
fieldNamed: aString
	"search down to subforms too"
	^self fields at: aString ifAbsent: 
		[self subforms do: [:form || field | 
			field := form fieldNamed: aString.
			field notNil ifTrue: [^field] ].
		nil].! !

!WebForm methodsFor: 'private-fields' stamp: ' 21/4/07 22:07'!
fieldSet
	^self fields at: #set ifAbsent: [self initFieldSet].! !

!WebForm methodsFor: 'tabulation' stamp: ' 21/4/07 22:07'!
fieldWithTabIndex: aNumber	
	"return a form element with that tab index"
	^self tabOrder detect: [:field | field tabIndex = aNumber] ifNone: [nil].! !

!WebForm methodsFor: 'private-fields' stamp: ' 21/4/07 22:07'!
fields
	"return a dictionary of all fields in this form. a field name is used as a key"
	fields isNil ifTrue: [self initFields].
	^fields! !

!WebForm methodsFor: 'private'!
form
	^self! !

!WebForm methodsFor: 'private'!
hasTag
	^false "well..."! !

!WebForm methodsFor: 'accessing'!
hideFormTag
	"form tag is not shown at all"
	^self otherAt: #FormTagHidden put: true! !

!WebForm methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initFieldSet
	"with all fields for fast check, if field is already registered"
	^self fields at: #set put: Set new.! !

!WebForm methodsFor: 'initialize-release' stamp: ' 21/8/07 09:38'!
initFields
	fields := Dictionary new.
	self initFieldSet. "with all fields for fast check, if field is already registered"
	self initStreamedFieldSet! !

!WebForm methodsFor: 'initialize-release' stamp: ' 21/8/07 09:38'!
initStreamedFieldSet
	"all fields which demands request post data streaming directly to output stream"
	^self fields at: #streamedFields put: Set new.! !

!WebForm methodsFor: 'initialize-release'!
initSubforms
	subforms := OrderedCollection new.! !

!WebForm methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initTabOrder
	tabOrder := OrderedCollection new.! !

!WebForm methodsFor: 'accessing'!
invalidFields
	"all fields whith a not valid value, including from subforms"
	^self allFieldsIncludingSubforms reject: [:each | each isValid]! !

!WebForm methodsFor: 'validation'!
isComplete
	"all required fields entered and all all fields valid"
	^self isEntered and: [self isValid]! !

!WebForm methodsFor: 'validation'!
isEntered
	"check if all required fields (form elements) have values entered. Check also subforms"
	self allFields do: [:field | field isEntered ifFalse: [^false] ].  "local form fields"
	self subforms do: [:subform | subform isEntered ifFalse: [^false] ].
	^true! !

!WebForm methodsFor: 'testing'!
isTagHidden
	"form tag is not shown at all"
	^self otherAt: #FormTagHidden ifAbsent: [false]! !

!WebForm methodsFor: 'testing'!
isTopForm
	"top form in page or popup window"
	^self superform isNil! !

!WebForm methodsFor: 'testing'!
isTopFormOnPage
	"top form on the whole page"
	^self isTopForm and: [self parent isWebPage]! !

!WebForm methodsFor: 'validation'!
isValid
	"check if all fields (form elements) have valid values. Check also subforms"
	self allFields do: [:field | field isValid ifFalse: [^false] ].  "local form fields"
	self subforms do: [:subform | subform isValid ifFalse: [^false] ].
	^true! !

!WebForm methodsFor: 'testing'!
isWebForm
	^true! !

!WebForm methodsFor: 'private-fields'!
nextFieldNumber
	"for unique numbering of fields on all form hierachy on the whole page" 
	| number |
	number := self otherAt: #NextFieldNumber ifAbsentPut: [0].
	number := number + 1.
	self otherAt: #NextFieldNumber put: number.
	^number! !

!WebForm methodsFor: 'tabulation'!
nextFieldTabOrderIn: aFormElement
	"next element to tab into"
	| inx |
	self tabOrder isEmpty ifTrue: [^nil].
	inx := self tabOrder indexOf: aFormElement.
	inx = 0 ifTrue: [^self tabOrder first].
	inx = self tabOrder size ifTrue: [^self tabOrder first]. "rotate"
	^self tabOrder at: inx+1! !

!WebForm methodsFor: 'private-ajax'!
onFormChangeDo: aBlock
	"run a block with changed field as argument immedatelly after field change is Ajax detected"
	self announcers add: aBlock! !

!WebForm methodsFor: 'events'!
onReset: aJavascriptCode
	self attributesAt: #onReset add: aJavascriptCode! !

!WebForm methodsFor: 'events'!
onSubmit: aJavascriptCode
	"many calls will add a JS code to the exisitng one!!"
	self attributesAt: #onSubmit add: aJavascriptCode! !

!WebForm methodsFor: 'events-ajax'!
onSubmitUpdate: anElement
	"update (and show if not yet) a specified element from server (AJAX)"
	self onSubmitUpdate: anElement with: nil optional: nil! !

!WebForm methodsFor: 'events-ajax'!
onSubmitUpdate: anElement with: anArgString optional: anArg2String
	"first argument will be send as an argument of the method while second is additional"
	"See WebApplication>>respondToAjaxRequest: and specially #ajaxUpdate:from: for more"
	"Prototype specific"
	self onSubmit: 
		(self scriptForUpdate: anElement from: anElement
			with: anArgString optional: anArg2String
		 	context: self context).! !

!WebForm methodsFor: 'private' stamp: 'janko 10/31/2011 20:20'!
parent: anElement
	"temporary, for debugging!!"
	^super parent: anElement.
! !

!WebForm methodsFor: 'private-streaming'!
prepareActionStringOn: aSession
	"example of action string:  '/object.html?view=edit&aidaCtx=70413#anchor123"
	| actionString upToAnchor anchor ctx |
	actionString :=  (self action notNil 
		ifTrue: [self action "predefined action" ] ifFalse: [aSession fullUrlForCurrentPage]).
	upToAnchor := actionString readStream upTo: $#.
	anchor := actionString readStream upTo: $#; upToEnd.
	ctx := self context.
	actionString := upToAnchor, ((actionString includes: $? ) ifTrue: ['&'] ifFalse: ['?']),
		(ctx notNil ifTrue: [WebContext contextIdName "aidaCtx", '=', self context id printString] ifFalse: ['']).
	anchor notEmpty ifTrue: [actionString := actionString, '#', anchor]. "anchor always at the end!!"
	^actionString! !

!WebForm methodsFor: 'private-streaming'!
prepareToHtmlStreamingOn: aSession
	self ensureOnSubmitReturnFalseAtEnd.  "for ajaxSubmit to break normal submiting and full page reload"
	super prepareToHtmlStreamingOn: aSession.
	self reorderTabulation. "late reordering to ensure that all form elements are present"! !

!WebForm methodsFor: 'private'!
printString
	^'aWebForm', (self isTopForm ifTrue: [' top '] ifFalse: [' ']), 
			(self isTopFormOnPage ifTrue: ['on page'] ifFalse: ['on popup']), 
		(self id notNil ifTrue: 
			[(String with: Character cr), '     id: ', self id] ifFalse: ['']),
		((self attributesAt: #class)  notNil ifTrue: 
			[(String with: Character cr), '     class: ', self attributesAt: #class ] ifFalse: ['']),
		(String with: Character cr), '     valid: ', self isValid printString,
		(String with: Character cr), '     fields: ', (self fields size - 2) printString,
		(String with: Character cr), '     superform: ', (self superform isNil ifTrue: ['nil'] ifFalse: ['aWebForm']),
		(String with: Character cr), '     subforms: ', self subforms size printString,
		(String with: Character cr), '     parent: ', self parent printString! !

!WebForm methodsFor: 'model adapting'!
registerFormElement: aFormElement
	"register (add to fields and set model adaptor) element to this form"
	aFormElement isFormElement ifFalse: [self error: 'not a form element!!'].
	(self alreadyRegistered: aFormElement) ifTrue: [^nil]. 
	aFormElement hasName ifFalse:
		[aFormElement name: 'field', (self topFormOnPage nextFieldNumber) printString].
	self addToFields: aFormElement. 
	(aFormElement isRadioButton | aFormElement isCheckBox)
		ifTrue: [aFormElement joinToForm: self]
		ifFalse:	["aWebFormElement adapt" "not needed anymore!!"]! !

!WebForm methodsFor: 'model adapting' stamp: ' 21/8/07 09:38'!
registerStreamedFieldsInto: aHTTPPost
	"for streams it needs to be done before you use any post data, otherwise it is too late!!"
	self streamedFieldSet do: [:field | 
		field writeBlock notNil 
			ifTrue: [aHTTPPost postDataAt: field name beforeStreamingDo: field writeBlock].
		field writeStream notNil 
			ifTrue: [aHTTPPost postDataAt: field name streamTo: field writeStream] ]! !

!WebForm methodsFor: 'private'!
removeSubform: aWebForm
	subforms isNil ifTrue: [^nil].
	subforms remove: aWebForm ifAbsent: [nil].! !

!WebForm methodsFor: 'tabulation'!
reorderTabulation
	"builds and reorders tabOrder to match tabIndex order of form (and subforms) elements"
	| flds withTabIndex |
	self initTabOrder.
	flds := self allFieldsIncludingSubforms.
	withTabIndex := flds select: [:each | each tabIndex notNil and: [each tabIndex ~= 0] ]. "with tab index explicitly set"
	withTabIndex := SortedCollection withAll: withTabIndex sortBlock: [:a :b | a tabIndex < b tabIndex].
	self tabOrder addAll: withTabIndex.
	withTabIndex := withTabIndex asSet.
	 "those without tab index at the end"
	self tabOrder addAll: (flds reject: [:each | withTabIndex includes: each]).! !

!WebForm methodsFor: 'model posting'!
save
	"save all changed form field values to the domain model. All values must be valid unitl any value is saved. 
	Raise error if any value is not validated. To avoid exception, check with #isValid before!!
	Save the subforms down in hierarchy as well"
	self isValid ifFalse: [self error: 'form fields not all valid'].
	self allFields do: [:field | field save]. "only changed fields are saved!! See WebModelAdaptor save"
	self subforms do: [:each | each save]! !

!WebForm methodsFor: 'private-ajax'!
scriptForPostAndUpdate: anElementToUpdate from: anElementToRecreate with: anArgString  optional: anArg2String button: aWebButton for: aContext
	"Whole form post!! Form from page, popup window or standalone widget"
	"Sychronous Ajax call, it blocks until call is finished!!"
	"ElementToUpdate will be replaced with contents of the elementToRecreate after its creation method will be   
      called to recreate it. Except for popups both elements are actually the same"
	"First argument will be send as an argument of the method while second is optional"
	"If both elements are nil, only arguments will be sent, usefull for sending commands only, like close window"
	"See WebApplication>>respondToAjaxRequest: for more"
	"Prototype specific"
	| url id parms buttonName buttonValue |
	id := anElementToUpdate notNil ifTrue: [anElementToUpdate ensureId; id] ifFalse: [#nil].
	url := self ajaxCallUrl. 
	parms := self ajaxCallUrlParametersFor: anElementToUpdate context: aContext.
	anArgString notNil ifTrue: [parms := parms, '&parm=', anArgString].
	anArg2String notNil ifTrue: [parms := parms, '&parm2=', anArg2String].
	anElementToRecreate notNil ifTrue: 
		[parms := parms, '&ajaxContentElementId=', 
			[anElementToRecreate registerId. anElementToRecreate id asString] value ].
	aWebButton notNil ifTrue: 
		[buttonName := aWebButton name.  "Form.Serialize somehow doesn't add that button, so we add it manually"
		buttonValue := aWebButton text].
	^'var serializedForm = Form.serialize(''', (self form registerId "if not yet"; id) asString, "page or widget form"
        '''); new Ajax.Updater(''', id asString, 
        ''', ''', "url, ''', {method: ''get'', parameters: ''', parms, ''' + form, evalScripts: true, asynchronous: false})'" url, 
        ''', {method: ''post'', postBody: serializedForm + ''', ('&', parms),  
	(aWebButton notNil ifTrue: ['&', buttonName, '=', buttonValue, '&ajaxPressedButton=', buttonName, ''] ifFalse: ['']), 
	''', evalScripts: true, asynchronous: false})'! !

!WebForm methodsFor: 'private' stamp: ' 21/4/07 22:07'!
shouldIdent
	^true! !

!WebForm methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession.
	self isTopForm 
		ifTrue:   "subforms don't have a method parameter"
			[self isTagHidden ifFalse: 
				[aStream nextPutAll: 
					self ident, '<form  method="post" action="', (self prepareActionStringOn: aSession),  
						'"', ' enctype="multipart/form-data"'.
				self streamAttributesTo: aStream for: aSession.
				aStream nextPutAll: '>', self eol] ]
		ifFalse: 
			[aStream nextPutAll: '<div comment="subform" '.
				self streamAttributesTo: aStream for: aSession.
				aStream nextPutAll: '>', self eol].
	super streamHtmlTo: aStream for: aRequest on: aSession.
	aStream nextPutAll:  self ident, 
		((self isTopForm and: [self isTagHidden not]) ifTrue: ['</form>'] ifFalse: ['</div>'])
		, self eol.! !

!WebForm methodsFor: 'private-fields' stamp: ' 21/8/07 09:38'!
streamedFieldSet
	^self fields at: #streamedFields ifAbsent: [self initStreamedFieldSet].! !

!WebForm methodsFor: 'accessing'!
subforms
	"forms in next level of widgets in this page/popup window/widget  "
	subforms isNil ifTrue: [^#() ].
	^subforms! !

!WebForm methodsFor: 'accessing'!
superform
	"parent form"
	^superform! !

!WebForm methodsFor: 'private'!
superform: aWebForm
	"parent form"
	self == aWebForm ifTrue: [self error: 'superform?']. "for debugging!!"
	superform := aWebForm! !

!WebForm methodsFor: 'private' stamp: ' 21/4/07 22:07'!
tabOrder
	"return a collection of all fields in this form, ordered by tab order"
	tabOrder isNil ifTrue: [self initTabOrder].
	^tabOrder! !

!WebForm methodsFor: 'tags'!
tag
	^#form! !

!WebForm methodsFor: 'accessing'!
topForm
	"returns the first, top form in the page/popup window"
	^self isTopForm 
		ifTrue: [self]
		ifFalse: [self superform topForm]! !

!WebForm methodsFor: 'accessing'!
topFormOnPage
	"returns the first, top form in the whole page"
	self isTopFormOnPage ifTrue: [^self].
	^self context first form! !

!WebForm methodsFor: 'model posting' stamp: 'janko 11/2/2011 21:45'!
uncheckAllProperChecboxesFor: anEventOrRequest
	"for single input event just that checbox, if any"
	| toUncheck |
	toUncheck := self allFieldsIncludingSubforms. "by default, for classical form submits"
	(anEventOrRequest isWebEvent  "probably check/uncheck event over  WebSocket "
		and: [anEventOrRequest element class == WebCheckBox]) 
			ifTrue: [toUncheck := Array with: anEventOrRequest element].
	anEventOrRequest isAjaxRequest ifTrue: 
		[toUncheck := Array with: 
			(self fields at: anEventOrRequest ajaxSingleInputName ifAbsent: [^nil])].
	toUncheck do: [:each | each isCheckBox ifTrue: [each uncheckValue] ]! !

!WebForm methodsFor: 'model posting'!
uncheckAllProperRadioButtonsFor: aRequest
	"for single input Ajax posts just that radio button, if any"! !

!WebForm methodsFor: 'accessing'!
unhideFormTag
	"form tag is not shown again"
	^self otherAt: #FormTagHidden put: false! !

!WebForm methodsFor: 'accessing'!
validFields
	"all fields whith a not valid value"
	^self allFields select: [:each | each isValid]! !

!WebForm methodsFor: 'accessing'!
view
	"for which app view is that form"
	^self context view! !

!WebFormElement methodsFor: 'private'!
acceptInputFromValue: aString
	self subclassResponsibility! !

!WebFormElement methodsFor: 'events'!
activate
	"move focus and select the text in that form field. (focus+select)"
	self ensureId.
	self scriptAfter: 'document.getElementById(''', self id, ''').activate' 
"	self scriptAfter: 'Field.activate(''', self id, ''')'"! !

!WebFormElement methodsFor: 'model adapting'!
adapterFor: anObject aspect: anAspectSymbolOrNumber
	"return an appropriate aspect adaptor for that element"
	((anObject isKindOf: Collection) or: [anObject isKindOf: WebTranslDict]) ifTrue:  
		"adapt to an element of collection, which must be an indexed one!! "
		[^(AidaModelAdaptor forIndex: anAspectSymbolOrNumber) subject: anObject].
	(anAspectSymbolOrNumber isKindOf: Symbol) ifTrue:
		[^(AidaModelAdaptor forAspect: anAspectSymbolOrNumber) subject: anObject].
	self error: 'innapropriate aspect'! !

!WebFormElement methodsFor: 'accessing'!
adaptor
	adaptor isNil ifTrue: [self initNullAdaptor]. "not yet connected to model, jsut to hold a value"
	^adaptor! !

!WebFormElement methodsFor: 'private'!
adaptor: aProtocolAdaptor
	adaptor := aProtocolAdaptor.! !

!WebFormElement methodsFor: 'private'!
addEnterTabScriptIfNessesary
	"allow ENTER key to be used for tabulation, like a TAB"
	"Prototype specific"
	| next nextId |
	self enterTabForm isNil ifTrue: [^nil].
	next := self enterTabForm nextFieldTabOrderIn: self.
	nextId := next notNil 
		ifTrue: [next ensureId; id]
		ifFalse: [''].  "no tabulation, but also no default ENTER action!!" 
	self scriptAfter: 'Event.observe(''', self id, ''', ''keypress'', function(event) {
  		if (event.keyCode == Event.KEY_RETURN) {  
			Event.stop(event); $(''', nextId, ''').activate(); } } )'! !

!WebFormElement methodsFor: 'private-events'!
announceChange
	self form announceChange: self! !

!WebFormElement methodsFor: 'accessing'!
aspect
	^self adaptor aspect! !

!WebFormElement methodsFor: 'model adapting'!
aspect: aSymbolOrNumber for: anObject
	"set the link between this form element and an aspect (name of instance variable) 
	of an object , which value is presented in this webFormElement. The appropriate 
	aspect adaptor is generated"
	self adaptor: 
		(self adapterFor: anObject aspect: aSymbolOrNumber)! !

!WebFormElement methodsFor: 'events'!
blockEnterKey
	"don't allow that ENTER key press trigger unwanted form submit"
	self on: #keyPress script: 'return blockEnter(event)'! !

!WebFormElement methodsFor: 'private-events'!
canUpdate
	"form elements can be Ajax updated, to disable/enable them, a button for instance"
	^true! !

!WebFormElement methodsFor: 'private'!
defaultErrorElement
	"this widget is Ajax updated with an error text in case of validation failure"
	^WebValidationError newFor: self.! !

!WebFormElement methodsFor: 'events'!
disable
	"disable (gray out) this form element"
	self ensureId.
	self scriptAfter: 'document.getElementById(''', self id, ''').disabled = true'! !

!WebFormElement methodsFor: 'attributes'!
disabled
	"disable this form element for user input"
	self attributesAt: #disabled put: nil "just attribute name, no value"! !

!WebFormElement methodsFor: 'private'!
dontSanitize
	"don't sanitize input from <script> and similar possibly malicius input"
	self otherAt: #NoSanitizing put: true! !

!WebFormElement methodsFor: 'events'!
enable
	"enable again this form element"
	self ensureId.
	self scriptAfter: 'document.getElementById(''', self id, ''').disabled = false'! !

!WebFormElement methodsFor: 'attributes'!
enabled
	self attributes removeKey: #disabled ifAbsent: [].! !

!WebFormElement methodsFor: 'private'!
enterTabForm
	"is tab with ENTER enabled and in which form"
	^enterTabForm! !

!WebFormElement methodsFor: 'private'!
enterTabForm: aForm
	enterTabForm := aForm! !

!WebFormElement methodsFor: 'validation'!
errorElement
	"this element is Ajax updated wit an error text in case of validation failure. Call it only once!!"
	"Styling is determined in DefaultWebStyle>>css321Validation. Red background by default"
	| e already |
	already := self otherAt: #ErrorElementAlready ifAbsent: [false].
	already ifTrue: [self error: 'Use validation error element only once!!'].
	self otherAt: #ErrorElementAlready put: true.
	e := self otherAt: #ErrorElement ifAbsentPut: [self defaultErrorElement]. "instance of WebValidationError"
	self onChangeUpdate: e.
	^e! !

!WebFormElement methodsFor: 'private'!
errorText
	"this text will be shown in errorElement in cas of validation failure"
	^self otherAt: #ErrorText ifAbsent: ['']! !

!WebFormElement methodsFor: 'validation'!
errorText: aString
	"this text will be shown in errorElement in case of validation failure"
	self otherAt: #ErrorText put: aString! !

!WebFormElement methodsFor: 'events'!
focus
	"move the input focus to that form field"
	self ensureId.
	self scriptAfter: 'document.getElementById(''', self id, ''').focus()'! !

!WebFormElement methodsFor: 'accessing'!
form
	"form (from page, popup window or widget) to which belongs (or it will be) this form element"
	^super form! !

!WebFormElement methodsFor: 'accessing'!
format
	"format of the value. Depends of value type. If nil, autoformating is used"
	"For Date can be #iso #sloDate #shortSloDate"
	^self adaptor format! !

!WebFormElement methodsFor: 'accessing'!
format: aSymbol
	"format of the value. Depends of value type. If nil, autoformating is used"
	"For Date can be #iso #sloDate #shortSloDate"
	^self adaptor format: aSymbol! !

!WebFormElement methodsFor: 'private-events'!
handleSubmitEvent: aWebEvent
	"if there is some onSubmit action registered from that form element. Called after whole form is submitted"
	| handler |
	handler := self eventHandlerFor: #submit.
	handler isNil ifTrue: [^nil].
	^handler handleEvent: aWebEvent! !

!WebFormElement methodsFor: 'testing'!
hasName
	^self name notNil and: [self name notEmpty]! !

!WebFormElement methodsFor: 'private'!
hasTag
	"form elements have always HTML tag"
	^true! !

!WebFormElement methodsFor: 'events'!
ignoreEnterKey
	"don't allow ENTER/RETURN key to submit a form unintentionally, for instance"
	"Prototype specific"
	self scriptAfter: 'Event.observe(''', self id, ''', ''keypress'', function(event) {
  		if (event.keyCode == Event.KEY_RETURN) { Event.stop(event); } } )'! !

!WebFormElement methodsFor: 'initialize-release'!
initNullAdaptor
	"not yet connected to model, just to hold a value"
	self adaptor: AidaModelNullAdaptor new! !

!WebFormElement methodsFor: 'initialize-release' stamp: ' 26/4/07 10:37'!
initialize
	self name: ''.
"	self app form registerFormElementsIn: self "! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isAutocompleteField
	^false! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isButton
	^false! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isCheckBox
	^false! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isDateInputField
	^false! !

!WebFormElement methodsFor: 'private'!
isDiv
	^false! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isEmpty
	"input field is empty or nil"
	| vlue |
	vlue := self object perform: self aspect.
	^vlue isNil 
		or: [((vlue isKindOf: String) and: [vlue isEmpty])
			or: [(vlue isKindOf: Number) and: [vlue = 0] ]]! !

!WebFormElement methodsFor: 'validation'!
isEntered
	"this input field is required and not empty. If not required it is entered even if empty"
	self isRequired ifFalse: [^true].
	^self adaptor changed
		ifTrue: [self adaptor isEmpty not] "changed value"
		ifFalse: [self isEmpty not] "old value"! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isFileInputField
	^false! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isFormElement
	^true! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isInputField
	^false! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isListBox
	^false! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isMenu
	^false! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isRadioButton
	^false! !

!WebFormElement methodsFor: 'validation'!
isRequired
	"this input field is required and must not stay empty"
	^self otherAt: #name ifAbsent: [false]! !

!WebFormElement methodsFor: 'private-events'!
isSingleFieldPost
	"is field Ajax posted immediatelly after change, as single one, not entire form"
	^self otherAt: #singleFieldPost ifAbsent: [false]! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/8/07 09:38'!
isStreamed
	"Post data from web request is streamed directly into output stream. 
	Only WebFileInputField can do that for now"
	^false! !

!WebFormElement methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isTextArea
	^false! !

!WebFormElement methodsFor: 'validation'!
isValid
	"form element (field) has a valid value"
	self adaptor isNil ifTrue: [^true].
	^self adaptor isValid! !

!WebFormElement methodsFor: 'attributes'!
max: aNumber
	"maximal value"
	^self attributesAt: #max put: aNumber printString! !

!WebFormElement methodsFor: 'attributes'!
min: aNumber
	"minimal value"
	^self attributesAt: #min put: aNumber printString! !

!WebFormElement methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
name
	^self attributesAt: #name! !

!WebFormElement methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
name: aString
	self attributesAt: #name put: aString! !

!WebFormElement methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
noTab
	"skip this form element when tabulating with TAB"
	"This attribute specifies the position of the current element in the tabbing order of that form"
	self tabIndex: 0.! !

!WebFormElement methodsFor: 'accessing'!
object
	^self adaptor subject! !

!WebFormElement methodsFor: 'events'!
onBlur: aJavascriptCode
	"when a form element loses focus either by mouse or tabulation"
	self attributesAt: #onBlur add: aJavascriptCode! !

!WebFormElement methodsFor: 'events-ajax'!
onBlurUpdate: anElement
	"after field looses focus, AJAX update anElement  "
	self onBlurUpdate: anElement with: nil.! !

!WebFormElement methodsFor: 'events-ajax'!
onBlurUpdate: anElement with: anArgObject
	"after field looses focus, update anElement by calling its creation method with an argument "
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	(self existScriptForEvent: #blur) ifFalse:
		[self onChange: (self scriptForEvent: #blur context: self context)].
	(self eventHandlerFor: #blur) 
		addUpdate: anElement with: anArgObject.! !

!WebFormElement methodsFor: 'events' stamp: ' 21/4/07 22:07'!
onChange: aJavascriptCode
	self attributesAt: #onChange add: aJavascriptCode! !

!WebFormElement methodsFor: 'private-events'!
onChangeAnnounce
	"field will be posted to server but not saved, just change will be announced to form"
	"Saved will be only if setSingleFieldPost was called before"
	(self existScriptForEvent: #change) ifFalse:
		[self onChange: (self scriptForEvent: #change context: self context)].
	(self eventHandlerFor: #change)
		addAcceptPostedInput! !

!WebFormElement methodsFor: 'events-ajax'!
onChangeClose
	"Current window (if popup) is closed after element change, its context also"
	(self existScriptForEvent: #change) ifFalse:
		[self onChange: (self scriptForEvent: #change context: self context)].
	(self eventHandlerFor: #change) 
		addCloseWindow.! !

!WebFormElement methodsFor: 'events-ajax'!
onChangePost
	"after field change immediatelly post its value to server and save it to 
	domain object, if field is valid and complete"
	self setSingleFieldPost.   "so that field will actually be saved, otherwise change will be just announced"
	self onChangeAnnounce.! !

!WebFormElement methodsFor: 'events-actions' stamp: 'janko 1/2/2012 15:53'!
onChangePostAndDo: aBlock
	"execute that block when this form field is changed"
	self onChangePost.	
	(self eventHandlerFor: #change) 
		addActionBlock: aBlock.! !

!WebFormElement methodsFor: 'events-ajax'!
onChangePostAndUpdate: anElement
	"after field change, post contents to server and AJAX update anElement  "
	self onChangePostAndUpdate: anElement with: nil! !

!WebFormElement methodsFor: 'events-ajax'!
onChangePostAndUpdate: anElement with: anArgObject
	"after field change, post contents to server and AJAX update anElement  with a parameter"
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	self onChangePost.	
	(self eventHandlerFor: #change)
		addUpdate: anElement with: anArgObject.! !

!WebFormElement methodsFor: 'events' stamp: 'np 10/20/2008 16:41'!
onChangeReload
	"reload current page on change off that form element"
	self onChange: 'window.location.reload()'.! !

!WebFormElement methodsFor: 'events-ajax'!
onChangeUpdate: anElement
	"after field change update anElement on browser  "
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	self onChange: 
		(self scriptForEvent: #change context: self context).
	(self eventHandlerFor: #change) 
		addUpdate: anElement with: nil.! !

!WebFormElement methodsFor: 'events'!
onEnterTabulate
	"Prototype specific"
	"It goes to the next element in tabulation order"
	"This allows ENTER key to be used for tabulation, like a TAB. "
	ScriptaculousLibrary ensurePrototype.
	self enterTabForm: self form. "to make tabulation script late, just before htmlPrint"! !

!WebFormElement methodsFor: 'events'!
onEnterTabulateIn: aWidgetOrApp
	"Prototype specific"
	"It goes to the next element in tabulation order"
	"This allows ENTER key to be used for tabulation, like a TAB. "
	"Because widgets are nested, you can specify more exactly in which widget's form to tabulate"
	ScriptaculousLibrary ensurePrototype.
	self enterTabForm: aWidgetOrApp form. "to make tabulation script late, just before htmlPrint"! !

!WebFormElement methodsFor: 'events'!
onFocus: aJavascriptCode
	"when a form element receives a focus either by mouse or tabulation"
	self attributesAt: #onFocus add: aJavascriptCode! !

!WebFormElement methodsFor: 'events-ajax'!
onFocusUpdate: anElement
	"after field gets focus, AJAX update anElement  "
	self onFocusUpdate: anElement with: nil! !

!WebFormElement methodsFor: 'events-ajax'!
onFocusUpdate: anElement with: anArgObject
	"after field gets focus, update anElement by calling its creation method with an argument "
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	self onFocus: 
		(self scriptForEvent: #focus context: self context).
	(self eventHandlerFor: #focus) 
		addUpdate: anElement with: anArgObject.! !

!WebFormElement methodsFor: 'events-ajax'!
onKeyPressPostAndUpdate: anElement
	"after any key press in a field, post input value to server and update anElement"
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	self setSingleFieldPost.   "so that field will actually be saved, otherwise change will be just announced"
	self onKeyPress: 
		(self scriptForEvent: #keypress context: self context).
	(self eventHandlerFor: #keypress)
		addAcceptPostedInput;
		addUpdate: anElement with: nil.! !

!WebFormElement methodsFor: 'events-ajax'!
onKeyUpPostAndUpdate: anElement
	"after  key up in a field, post input value to server and update anElement"
	anElement isNil ifTrue: [self error: 'no element to update!!'].
	anElement ensureId. 
	self setSingleFieldPost.   "so that field will actually be saved, otherwise change will be just announced"
	self onKeyUp: 
		(self scriptForEvent: #keyup context: self context).
	(self eventHandlerFor: #keyup)
		addAcceptPostedInput;
		addUpdate: anElement with: nil.! !

!WebFormElement methodsFor: 'events'!
onSelect: aJavascriptCode
	"when some text is selected in a form element"
	self attributesAt: #onSelect add: aJavascriptCode! !

!WebFormElement methodsFor: 'attributes' stamp: 'janko 7/10/2011 19:41'!
placeHolder: aString
	"a descriptive hint what to enter in this field"
	self attributesAt: #placeholder put: aString! !

!WebFormElement methodsFor: 'private-streaming'!
prepareToHtmlStreamingOn: aSession
	super prepareToHtmlStreamingOn: aSession.
	self addEnterTabScriptIfNessesary.! !

!WebFormElement methodsFor: 'private' stamp: 'janko 11/2/2011 21:01'!
printString
	"Squeak specific"
	^'a', self class printString, 
		(self id notNil ifTrue: 
			[(String with: Character cr), '     id: ', self id] ifFalse: ['']),
		((self attributesAt: #class)  notNil ifTrue: 
			[(String with: Character cr), '     class: ', (self attributesAt: #class) printString ] ifFalse: ['']),
		(self name notNil ifTrue: 
			[(String with: Character cr), '     name: ', self name] ifFalse: ['']),
		(String with: Character cr), '     value: ' , 
			(self value printString truncateWithElipsisTo:  30),  "Squeak specific"
		(String with: Character cr), '     buffered: ' , 
			(self adaptor buffer printString truncateWithElipsisTo: 30),  "Squeak specific"
		(String with: Character cr), '     changed: ', self adaptor changed printString,
		(String with: Character cr), '     valid: ', self isValid printString! !

!WebFormElement methodsFor: 'attributes'!
readOnly
	"this form element od read only, cam be tabed in but not changed"
	self attributesAt: #readonly put: nil "just attribute name, no value"! !

!WebFormElement methodsFor: 'validation'!
required
	"this input field is requied and must not stay empty"
	self otherAt: #name put: true! !

!WebFormElement methodsFor: 'model adapting'!
save
	"save value of this form element (field) to the domain model. Check with #isValid if value pass 
	validation othervise exception is raised!!"
	self shouldSanitize ifTrue: [self adaptor sanitize]. "remove <script> with possibly malicious code"
	^self adaptor save! !

!WebFormElement methodsFor: 'private-events'!
scriptForEvent: anEventSymbol context: aWebContext
	"send current value of this form element too"
	"delay sending for few ms so that value will actuall be set"
	^'setTimeout(function() {aidaEvent(''', anEventSymbol asString, ''',''', 
		(self ensureId; id) asString, ''',''', 
		aWebContext id asString, ''',',
		'document.getElementById(''', self id asString, ''').value);}, 100);'! !

!WebFormElement methodsFor: 'events'!
select
	"select a whole input. Be sure to focut it first!!"
	self ensureId.
	self scriptAfter: 'document.getElementById(''', self id, ''').select' 
"	self scriptAfter: 'Field.select(''', self id, ''')' "! !

!WebFormElement methodsFor: 'private-events'!
setSingleFieldPost
	"field is Ajax posted immediatelly after change, as single one, not entire form"
	^self otherAt: #singleFieldPost put: true! !

!WebFormElement methodsFor: 'private'!
setValue: aString
	"preset the value of this form element, without set aspect adaptor"
	self notYetImplemented. "obsolete, just to catch senders!!"! !

!WebFormElement methodsFor: 'private'!
shouldSanitize
	"sanitize input from <script> and similar input to prevent entering XSS and similar malicious code"
	(self adaptor buffer isKindOf: String) ifFalse: [^false].
	^(self otherAt: #NoSanitizing ifAbsent: [false]) not! !

!WebFormElement methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
tabIndex
	"This attribute specifies the position of the current element in the tabbing order of that form"
	^(self attributes at: #tabindex ifAbsent: [^nil]) asInteger! !

!WebFormElement methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
tabIndex: aNumber
	"This attribute specifies the position of the current element in the tabbing order 
	for the current document"
	self attributes at: #tabindex put: aNumber printString! !

!WebFormElement methodsFor: 'private'!
tag
	^self subclassResponsibility! !

!WebFormElement methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
type: aString
	"set the type of  this form element"
	self attributesAt: #type put: aString! !

!WebFormElement methodsFor: 'events-ajax'!
update
	"basic elements don't need to be recreated, just stream them to HTML with changed attributes again"
	self id isNil ifTrue: [self error: 'web element to update must have id in advance, use #ensureId !!'].
	self prepareToHtmlStreamingOn: self session. "to prepare again"
	self session queueUpdateElement: self. "send immediatelly via WebSocket if open, or in Ajax response"
	^self! !

!WebFormElement methodsFor: 'private-events'!
updateWith: anArgumentObject
	self error: 'cannot update basic web element with an argument'! !

!WebFormElement methodsFor: 'validation'!
validIfTrue: aBlock
	"set the validation block to this form element . It accepts a value as argument and It must return true if entered 
	value is regarded as valid"
	"example for month verification block: [:value | value asInteger between: 1 and: 12 ] "
	self adaptor validationBlock: aBlock! !

!WebFormElement methodsFor: 'accessing'!
value
	^self adaptor value! !

!WebFormElement methodsFor: 'accessing'!
value: aValue
	"set the value of this form element"
	self adaptor value:  aValue.! !

!WebFormElement class methodsFor: 'auto type converting'!
autoConvertAndEncodeQuotes: aValue
	"auto convertion, character entitites encoding (just quotes) for form elements"
	"while UTF-8 encoding is done in WebElement>>printAttribute:value:on:for: !! "
	| vlue |
	vlue := WebFormElement autoConvertToString: aValue. "dates, numbers etc."
	vlue := AIDASite encodeQuoteEntitiesIn: vlue.               "char entity encoding for double quote '' "
	^vlue! !

!WebFormElement class methodsFor: 'auto type converting'!
autoConvertAndEncodeValue: aValue
	"auto convertion, character entitites encoding for form elements"
	"while UTF-8 encoding is done in WebElement>>printAttribute:value:on:for: !! "
	| vlue |
	vlue := WebFormElement autoConvertToString: aValue. "dates, numbers etc."
	vlue := AIDASite encodeCharEntitiesIn: vlue.               "char entity encoding for < > & '' "
	^vlue! !

!WebFormElement class methodsFor: 'auto type converting' stamp: 'janko 8/3/2011 18:53'!
autoConvertString: aString toObject: anObject
	"try to convert string depending on object type"
	"Squeak specific"
	(anObject isKindOf: String) ifTrue: [^aString].
	(anObject isKindOf: Integer) ifTrue: [^aString asInteger].
	(anObject isKindOf: ScaledDecimal) ifTrue: [^aString asScaledDecimal: anObject scale].
	(anObject isKindOf: Date) ifTrue: [^Date readSloFrom: aString readStream].
	anObject isNil ifTrue: [^aString].
	^aString! !

!WebFormElement class methodsFor: 'auto type converting' stamp: 'jm 4/22/2009 23:38'!
autoConvertToString: anObject
	"try to convert object to string depending on object type"
	"Squeak specific!!"
	(anObject isKindOf: String) ifTrue: [^anObject].
	(anObject isKindOf: Integer) ifTrue: [^anObject printString].
	(anObject isKindOf: Point) ifTrue: [^anObject printDotString]. "???" "Squeak specific!!"
	(anObject isKindOf: Date) ifTrue: [^anObject shorterPrintSloString].
	anObject aidaIsAssociation ifTrue: [^anObject]. "multilingual"
	^anObject printString! !

!WebFormElement class methodsFor: 'instance creation' stamp: 'JM 4/25/2007 22:23'!
new
	^super basicNew initialize! !

!WebGeolocation methodsFor: 'accessing'!
accuracy
	"accuracy of latitude and longitude, in meters"
	^accuracy! !

!WebGeolocation methodsFor: 'private'!
accuracy: anInteger
	accuracy := anInteger! !

!WebGeolocation methodsFor: 'accessing-additional'!
altitude
	"the height of the user's location, in meter"
	^altitude! !

!WebGeolocation methodsFor: 'private'!
altitude: anInteger
	altitude := anInteger! !

!WebGeolocation methodsFor: 'accessing-additional'!
altitudeAccuracy
	"altitude accuracy in meters, nil if no altitude provided"
	^altitudeAccuracy! !

!WebGeolocation methodsFor: 'private'!
altitudeAccuracy: anInteger
	altitudeAccuracy := anInteger! !

!WebGeolocation methodsFor: 'accessing-additional'!
heading
	"direction of travel, in degrees relative to true north"
	^heading! !

!WebGeolocation methodsFor: 'private'!
heading: anInteger
	heading := anInteger! !

!WebGeolocation methodsFor: 'accessing'!
latitude
	 "distance north or south of equator, in decimal degrees"
	^latitude! !

!WebGeolocation methodsFor: 'private'!
latitude: aDouble
	latitude := aDouble! !

!WebGeolocation methodsFor: 'accessing'!
longitude
	^longitude! !

!WebGeolocation methodsFor: 'private'!
longitude: aDouble
	longitude := aDouble! !

!WebGeolocation methodsFor: 'accessing-additional'!
speed
	"ground speed in meters per second"
	^speed! !

!WebGeolocation methodsFor: 'private'!
speed: anInteger
	speed := anInteger! !

!WebGeolocation methodsFor: 'accessing'!
timestamp
	"timestamp of location"
	^timestamp! !

!WebGeolocation methodsFor: 'private'!
timestamp: aSpTimestamp
	timestamp := aSpTimestamp! !

!WebGeolocation class methodsFor: 'instance creation'!
newFromJSON: aString
	| html5Position coords location |
	html5Position := WebJSON parse: aString.
	coords := html5Position at: 'coords'.
	location := self new.
	location 
		latitude: (coords at: 'latitude');
		longitude: (coords at: 'longitude');
		accuracy: (coords at: 'accuracy');
		altitude: (coords at: 'altitude' ifAbsent: [nil]);
		altitudeAccuracy: (coords at: 'altitudeAccuracy' ifAbsent: [nil]);
		speed: (coords at: 'speed' ifAbsent: [nil]);
		heading: (coords at: 'heading' ifAbsent: [nil]);
		timestamp: SpTimestamp now "(SpTimestamp fromUTCString: (html5Position at: 'timestamp'))".
	^location! !

!WebGraph methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
data
	data isNil ifTrue: [data := #(120 200 500 230 90 80 200 100 40)].
	^data! !

!WebGraph methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
data: anArray 
	data := anArray! !

!WebGraph methodsFor: 'drawing' stamp: ' 21/4/07 22:07'!
displayOn: aGraphicsContext
	| rectangle |
	self initGraphics.
	rectangle := Rectangle origin: 2 @ 2 extent: (self width - 4) @ (self height - 4).
	self graphics add: rectangle asStroker.
	self drawAxle.
	self drawYPoints.
	self graph.
	self drawTitle.
	self graphics displayOn: aGraphicsContext.! !

!WebGraph methodsFor: 'constants' stamp: ' 21/4/07 22:07'!
distance
	^(self xRightPosition - self xLeftPosition) // self data size! !

!WebGraph methodsFor: 'drawing' stamp: ' 21/4/07 22:07'!
drawAxle
	| points yAxis xAxis z c a grayLine blackLine b |
	z := self xLeftPosition.
	c := self yBottomPosition.
	b := self yTopPosition.
	a := self xRightPosition.
	points := List new: 2.
	points add: z @ (self yTopPosition - 10);
		add: z @ (c + 5).
	yAxis := Spline controlPoints: points.
	points := List new: 2.
	points add: (z - 5) @ c;
		add: a @ c.
	xAxis := Spline controlPoints: points.
	graphics add: yAxis asStroker;
		add: xAxis asStroker.
	b to: c - ((c - b) // 5)
		by: (c - b) // 5
		do: 
			[:x | 
			points := List new: 2.
			points add: (z + 1) @ x;
				add: a @ x.
			grayLine := Spline controlPoints: points.
			graphics add: ((GraphicsAttributesWrapper on: grayLine asStroker)
						attributes: (GraphicsAttributes new paint: ColorValue veryLightGray)).
			points := List new: 2.
			points add: (z - 5) @ x;
				add: z @ x.
			blackLine := Spline controlPoints: points.
			graphics add: blackLine asStroker]! !

!WebGraph methodsFor: 'drawing' stamp: ' 21/4/07 22:07'!
drawGraphWindow
	"WebGraph new drawGraphWindow"
	| win rectangle |
	win := ScheduledWindow new.
	win label: 'Graf obiskov na spletno stran'.
	win minimumSize: self width @ self height.
	graphics := CompositePart new.
	rectangle := Rectangle origin: 2 @ 2 extent: (self width - 4) @ (self height - 4).
	graphics add: rectangle asStroker.
	self drawAxle.
	self drawYPoints.
	self graph.
	self drawTitle.
	win component: (BoundedWrapper on: graphics).
	win open! !

!WebGraph methodsFor: 'drawing' stamp: ' 21/4/07 22:07'!
drawTitle
	| aTitle |
	aTitle:= (self title asComposedText compositionWidth: (self width-40)) centered.
	self graphics add: aTitle at: 20@10! !

!WebGraph methodsFor: 'drawing' stamp: ' 21/4/07 22:07'!
drawYPoints
	| string c stepOne step mark b |
	c := self yBottomPosition.
	b := self yTopPosition.
	stepOne := 0.
	step :=self stepFor:(self getMax at: 1).
	c to: b
		by: (0-((c - b) // 5))
		do: 
			[:x | 
			string := stepOne printString.
			mark := (string asText emphasizeAllWith: #small) asComposedText.
			mark compositionWidth: 30.
			mark rightFlush.
			graphics add: mark at: (self xLeftPosition - 40) @ ( x -13).
			stepOne := stepOne + step]! !

!WebGraph methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
getMax
	| b max1 maxim maxAt |
	max1 := 0.
	b := self data size.
	1 to: b
		do: [:x | (data at: x) > max1 ifTrue: 
					[max1 := data at: x.
					maxAt := x]].
	maxim := max1.
	^Array with: maxim with: maxAt.! !

!WebGraph methodsFor: 'drawing' stamp: ' 21/4/07 22:07'!
graph
	"WebGraph new drawGraph"

	| aData aRectangle z c |
	z := self xLeftPosition + 1.
	c := self yBottomPosition.
	1 to: self data size
		do: 
			[:x | 
			aData := data at: x.
			aRectangle := Rectangle left: z
						right: z + self distance - 2
						top: c - (self heightInPixelsFor: aData)
						bottom: c.
			z := z + self distance.
			graphics add: ((GraphicsAttributesWrapper on: aRectangle asFiller)
						attributes: (GraphicsAttributes new paint: ColorValue blue))]! !

!WebGraph methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
graphics
	graphics isNil ifTrue: [self initGraphics].
	^graphics! !

!WebGraph methodsFor: 'constants' stamp: ' 21/4/07 22:07'!
height	
	^300! !

!WebGraph methodsFor: 'transformations' stamp: ' 21/4/07 22:07'!
heightInPixelsFor:  aNumber

	^(((self yBottomPosition - self yTopPosition) / self margin) * aNumber) truncated

"
|graf|
graf := WebGraf new.
graf data: #(10 20 30 40 50).
graf heightInPixelsFor: 15.
"! !

!WebGraph methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initGraphics
	graphics := CompositePart new! !

!WebGraph methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
margin
	margin isNil ifTrue: [self margin: (self marginFor: (self getMax at: 1))].
	^margin! !

!WebGraph methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
margin: aNumber

	margin := aNumber.! !

!WebGraph methodsFor: 'transformations' stamp: ' 21/4/07 22:07'!
marginFor:  aNumber

	| margin |
	aNumber < 10 ifTrue: [^10].
	margin := 10 ** ((aNumber log: 10) truncated + 1).
	margin = (aNumber * 10) ifTrue: [^margin / 10].
	aNumber > (margin / 2) ifTrue: [^margin].
	aNumber > (margin / 4) ifTrue: [^margin / 2].
	^margin / 4.

"WebGraf new marginFor: 1001"! !

!WebGraph methodsFor: 'transformations' stamp: ' 21/4/07 22:07'!
stepFor:  aNumber

	^(self marginFor: aNumber) / 5

"WebGraf new stepFor: 1001"! !

!WebGraph methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
title 
	title isNil ifTrue: [title := 'Here comes the title'].
	^title! !

!WebGraph methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
title: aString
	title:= aString! !

!WebGraph methodsFor: 'constants' stamp: ' 21/4/07 22:07'!
width
	^500! !

!WebGraph methodsFor: 'constants' stamp: ' 21/4/07 22:07'!
xLeftPosition
	^50! !

!WebGraph methodsFor: 'constants' stamp: ' 21/4/07 22:07'!
xRightPosition
	^self width - 20! !

!WebGraph methodsFor: 'constants' stamp: ' 21/4/07 22:07'!
yBottomPosition
	^self height - 30! !

!WebGraph methodsFor: 'constants' stamp: ' 21/4/07 22:07'!
yTopPosition
	^40! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
addNewColumn
	self columns add: ((WebGridColumn newOn: self) id: (self columns size + 1))! !

!WebGrid methodsFor: 'private' stamp: 'np 10/17/2008 17:40'!
aidaDeepCopyNotIn: aDict 
	^ nil! !

!WebGrid methodsFor: 'private-building'!
ajaxUpdateWith: aParmString
	| parm |
"	(aParmString isNil and: [self aspect isNil]) ifTrue:
		[self error: 'This WebGrid not updatable, set collection with collectionAspect:for: instead!!'].
"	(aParmString notNil and: ['sort-*' match: aParmString]) ifTrue: 
		[parm := aParmString readStream upTo: $-; upToEnd.
		(self columnWithId: parm asInteger) sort. "or toogle sort order"
		self page: 1]. "always back to first page after sort change"
	(aParmString notNil and: ['page-*' match: aParmString]) ifTrue: 
		[parm := aParmString readStream upTo: $-; upToEnd.
		self page: parm asInteger]. 
	^self  "actuall update happens in second, streaming phase"! !

!WebGrid methodsFor: 'private'!
aspect
	^aspect! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
buildPageSelectionRow
	| fullLength |
	self newRow. self row class: #tablePageSelection.
	self cell colspan: self columns size; align: #center.
	fullLength := self filtered size.
	1 to: (fullLength // self rowsOnPage) + 1 do: [:inx |
		inx = self page 
			ifTrue: [self cell addTextBold: inx printString]
			ifFalse: [self cell add: (self linkForPage: inx)].
		self cell addText: ' | '].! !

!WebGrid methodsFor: 'private-building'!
buildTable
	self form initElements. 
	self initTable. "here, not in form!! But it will be added to form too"
	self table class: self cssClass. 
	self width notNil ifTrue: [self table width: self width].
	self buildTableHeader.
	self setCollectionFromAspect. "if aspect set instead of colelction directly"
	self sortColumnsIfNessesary.
	self hasFilters 
		ifTrue: [self buildTableFilterRow. self filterRows]
		ifFalse: [self filtered removeAll; addAll: self collection]. "filtered is what is shown, not collection!!"
	self buildTableRows.
	self needsSummary ifTrue: [self buildTableSummaryRow].
	self hasPages ifTrue: [self buildPageSelectionRow].
	self registerFormElements.  "registrations of grid form elements"! !

!WebGrid methodsFor: 'private-building'!
buildTableFilterRow
	| field |
	self newRow.
	self columns do: [:each | 
		each align notNil ifTrue: [self cell align: each align].
		each filter notNil ifTrue: 
			[field := WebDelayedField aspect: #filter for: each size: 10.
			each filterWidth notNil ifTrue: [field size: each filterWidth].
			(self wasFilterChangedFor: each on: field) ifTrue: [field focus].
			field onChangePostAndUpdate: self.
			field blockEnterKey.
			self cell add: field].
		each ~= self columns last ifTrue: [self newCell] ].! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
buildTableHeader
	self columns do: [:each | 
		self cell setHeader.
		each align notNil ifTrue: [self cell align: each align].
		each name notNil ifTrue: [self cell add: (self sortLinkColumn: each)].
		each isSortedAscending ifTrue: [self cell addGif: #arrowOrangeUpGif].
		each isSortedDescending ifTrue: [self cell addGif: #arrowOrangeDownGif].
		each ~= self columns last ifTrue: [self newCell] ].! !

!WebGrid methodsFor: 'private-building'!
buildTableRows
	| inx objects pageLength |
	self collection notEmpty ifTrue: [self newRow].
	objects := self filtered.
	self resetSummary. inx := 0. objects do: [:object | inx := inx + 1. "summary in advance!!"
		self columns do: [:column | self summaryForColumn: column index: inx object: object]].
	inx := 1. pageLength := self hasPages ifTrue: [self rowsOnPage] ifFalse: [objects size]. 
	(self page-1) * pageLength > objects size ifTrue: [self page: 1]. 
	objects := objects 
		copyFrom: ((self page-1) * pageLength)+1 to: (self page * pageLength min: objects size).
	objects do: [:object |
		self setRowAttributesFor: self row object: object.
		self columns do: [:column |
			(inx = 1 and: [column width notNil]) ifTrue: [self cell width: column width].
			self printColumn: column index: inx object: object in: self cell.
			column ~= self columns last ifTrue: [self newCell] ].
		inx ~= objects size ifTrue: [self newRow].
		inx := inx + 1 ]! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
buildTableSummaryRow
	self newRow. self row class: #summary.
	self columns do: [:each | 
		each align notNil ifTrue: [self cell align: each align].
		each name notNil ifTrue: [self cell addText: each summaryValue].
		each ~= self columns last ifTrue: [self newCell] ].! !

!WebGrid methodsFor: 'private-building'!
canFilterObject: anObject onColumns: aColumnsToFilter
	aColumnsToFilter do: [:column || value |
		column aspect notNil ifTrue: 
			[value := anObject perform: column aspect].
		column addBlock notNil ifTrue:   "to filter addBlocks too!!"
			[value := (column addBlock value: anObject) asString].
		value notNil ifTrue: 
			[value := WebFormElement autoConvertToString: value.
			value notNil ifTrue:
				[((column filter, '*') match: value) ifFalse: [^false]]  ] ] .
	^true! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checkboxes
	"nil or column"
	^self settingsAt: #checkboxesColumn ifAbsent: [nil]! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checkboxes: aColumnId
	^self settingsAt: #checkboxesColumn put: aColumnId! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checkboxesCollection
	"collection of checked row objects"
	^self settingsAt: #checkboxesCollection ifAbsent: [nil]! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checkboxesCollection: aCollection
	^self settingsAt: #checkboxesCollection put: aCollection! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
checkboxesColumn: aColumnId collection: aCollection
	"this column will have checboxes. Checked row objects will be in aCollection.
	preselected rows are done from initial aCollection"
	self checkboxes: aColumnId.
	self checkboxesCollection: aCollection! !

!WebGrid methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
collection
	collection isNil ifTrue: [^#()].
	^collection! !

!WebGrid methodsFor: 'accessing'!
collection: aCollection
	"to be Ajax updatable with fresh content use #collectionAspect:for: instead!!"
	collection := aCollection! !

!WebGrid methodsFor: 'accessing'!
collectionAspect: aCollectionMethodSymbol for: anObject
	"Wse this way for updatable grids, instread of setting a collection directy!!"
	"When Ajax update request comes, aspect of this object is called to get a fresh collection"
	aspect := aCollectionMethodSymbol.
	object := anObject.! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
column: aColumnId addBlock: aBlock
	"this block will be called with current row object as an argument. 
	It must return kind of WebElement which will be added to the table cell"
	self columns size < aColumnId ifTrue: [self addNewColumn].
	(self columns at: aColumnId) addBlock: aBlock! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
column: aColumnId viewBlock: aBlock
	"this block will be called with current row object as an argument. It must return plain string!!"
	self columns size < aColumnId ifTrue: [self addNewColumn]. "?"
	(self columns at: aColumnId) viewBlock: aBlock! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
columnAlign: anArrayOfSymbols
	"#left #right #center, nil if default left is used"
	| inx |
	inx := 1.
	anArrayOfSymbols do: [:each |
		self columns size < inx ifTrue: [self addNewColumn].
		(self columns at: inx) align: each.
		inx := inx + 1]! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
columnAspects: anArrayOfSymbols
	"methods to be called for each column on every object in collection"
	| inx |
	inx := 1.
	anArrayOfSymbols do: [:each |
		self columns size < inx ifTrue: [self addNewColumn].
		(self columns at: inx) aspect: each.
		inx := inx + 1]! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
columnFilters: anArrayOfBooleanOrNumbers
	"row with filter input fields, put true or field width on a column to add filter"
	| inx |
	inx := 1.
	anArrayOfBooleanOrNumbers do: [:each |
		self columns size < inx ifTrue: [self addNewColumn].
		each notNil ifTrue: [(self columns at: inx) setFilter].
		(each notNil and: [each class ~= True "but number"])  
			ifTrue: [(self columns at: inx) filterWidth: each].
		inx := inx + 1]! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
columnLinkAspects: anArrayOfSymbols
	"url link to an aspects of an object. Specify views with separate columnLinkViews: method"
	| inx |
	inx := 1.
	anArrayOfSymbols do: [:each |
		self columns size < inx ifTrue: [self addNewColumn].
		(self columns at: inx) linkAspect:  each.
		inx := inx + 1]! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
columnLinkViews: anArrayOfSymbols
	"link to an aspect of object(if set with columnLinks:, otherwise to object itself) with a view 
	will be shown in thi column"
	| inx |
	inx := 1.
	anArrayOfSymbols do: [:each |
		self columns size < inx ifTrue: [self addNewColumn].
		(self columns at: inx) linkView:  each.
		inx := inx + 1]! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
columnNames: anArrayOfStrings
	"set names of columns to be shown in header of table"
	| inx |
	inx := 1.
	anArrayOfStrings do: [:each |
		self columns size < inx ifTrue: [self addNewColumn].
		(self columns at: inx) name: each.
		inx := inx + 1]! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
columnWidth: anArrayOfNumbers
	"width of column or nil."
	| inx |
	inx := 1.
	anArrayOfNumbers do: [:each |
		self columns size < inx ifTrue: [self addNewColumn].
		(self columns at: inx) width: each.
		inx := inx + 1]! !

!WebGrid methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
columnWithId: aNumber
	aNumber > self columns size ifTrue: [^nil].
	^self columns at: aNumber! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
columns
	columns isNil ifTrue: [self initColumns].
	^columns! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
cssClass
	^self settingsAt: #cssClass ifAbsent: [self defaultCssClass]! !

!WebGrid methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
defaultCssClass
	^#webGrid! !

!WebGrid methodsFor: 'accessing' stamp: 'np 5/7/2008 17:37'!
defaultWidth
	^1 "100%"! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
endTagFor: anObject
	(self rowBoldBlock notNil and: [self rowBoldBlock value: anObject]) ifTrue: [^'</b>'].
	^''! !

!WebGrid methodsFor: 'settings-row' stamp: ' 21/4/07 22:07'!
filterRow: anArrayOfBooleanOrNumbers
	"OBSOLETE!!"
	"row with filter input fields, put true or field width on a column to add filter"
	self columnFilters: anArrayOfBooleanOrNumbers! !

!WebGrid methodsFor: 'private-building'!
filterRows
	| columnsToFilter | 
	columnsToFilter := self columns select: [:each | each isFilterEntered]. 
	self filtered removeAll; addAll: 
		(columnsToFilter notEmpty
			ifTrue: [(self collection select: [:object | 
				self canFilterObject: object onColumns: columnsToFilter])] 
			ifFalse: [self collection])! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
filtered
	"objects which pass filter criteria. if nil, filters are not set"
	filtered isNil ifTrue: [self initFiltered].
	^filtered! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
filtered: aCollection
	filtered := aCollection! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
filteredCollection: aCollection
	"for external access to filtered rows only"
	filtered := aCollection! !

!WebGrid methodsFor: 'private-testing' stamp: ' 21/4/07 22:07'!
hasFilters
	"any column has a filter"
	^self columns contains: [:each | each filter notNil].! !

!WebGrid methodsFor: 'private-testing' stamp: ' 21/4/07 22:07'!
hasNoZeros
	"don't show zeros"
	^self settingsAt: #noZeros ifAbsent: [false]! !

!WebGrid methodsFor: 'private-testing' stamp: ' 21/4/07 22:07'!
hasPages
	^self rowsOnPage notNil and: [self collection size > self rowsOnPage].! !

!WebGrid methodsFor: 'private-testing' stamp: ' 21/4/07 22:07'!
hasShortDates
	"year in two digits only"
	^self settingsAt: #shortDates ifAbsent: [false]! !

!WebGrid methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initColumns
	columns := OrderedCollection new! !

!WebGrid methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initFiltered
	filtered isNil 
		ifTrue: [filtered := OrderedCollection new]
		ifFalse: [filtered removeAll]! !

!WebGrid methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initSettings
	settings := Dictionary new.! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
lastColumn
	^self columns notEmpty ifTrue: [self columns last] ifFalse: [nil].! !

!WebGrid methodsFor: 'private-building'!
linkForPage: aNumber
	| app linkTarget dummyLink |
	app := self app.
	linkTarget := app isStandaloneApp ifTrue: [app class] ifFalse: [app observee].
	dummyLink := WebLink text: aNumber printString linkTo: (Array with: linkTarget with: '-').
	app inDefaultView ifFalse: [dummyLink view: app view].
	dummyLink onClickUpdate: self with: 'page-', aNumber printString.
	^dummyLink! !

!WebGrid methodsFor: 'private-testing' stamp: ' 21/4/07 22:07'!
needsSummary
	"summary row needed or not"
	^self columns contains: [:each | each needsSummary].! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
noZeros
	"don't show if value is zero"
	^self settingsAt: #noZeros put: true! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
numbering
	"false or column"
	^self settingsAt: #numberingColumn ifAbsent: [nil]! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
numbering: aColumnId
	"false or column"
	^self settingsAt: #numberingColumn put: aColumnId! !

!WebGrid methodsFor: 'private'!
object
	^object! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
page
	"number of a page currently shown"
	page isNil ifTrue: [self page: 1].
	^page! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
page: aNumber
	page := aNumber! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
parent: aWebElement
	"self buildTable." "build just before rendering!!"
	^super parent: aWebElement! !

!WebGrid methodsFor: 'private-building'!
prepareToHtmlStreamingOn: aSession
	super prepareToHtmlStreamingOn: aSession.
	self buildTable! !

!WebGrid methodsFor: 'private-building'!
printCheckboxIndex: aNumber object: anObject in: anElement
	| field |
	field := WebCheckBox newForObject: anObject from: self checkboxesCollection.
"	self app form registerFormElementsIn: field.  "
	anElement add: field.! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
printColumn: aColumn index: aNumber object: anObject in: anElement
	| start |
	aColumn align notNil ifTrue: [anElement align: aColumn align].
	aColumn isNumbered  ifTrue: 
		[start := self hasPages ifTrue: [(self page-1) * self rowsOnPage] ifFalse: [0].
		^self printNumber: start+aNumber object: anObject in: anElement].
	aColumn isCheckboxed  ifTrue: [^self printCheckboxIndex: aNumber object: anObject in: anElement].
	aColumn hasLink ifTrue: [^self printLinkTo: anObject column: aColumn in: anElement]. 
	aColumn hasAddBlock ifTrue: [^anElement add: (aColumn addBlock value: anObject)].
	anElement addText: 
		(self startTagFor: anObject), (aColumn viewBlock value: anObject), (self endTagFor: anObject)! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
printLinkTo: anObject column: aColumn in: anElement
	| view object linkText |
	view := aColumn linkView notNil ifTrue: [aColumn linkView] ifFalse: [#main].
	object := aColumn linkAspect notNil 
		ifTrue: [anObject perform: aColumn linkAspect] ifFalse: [anObject].
	linkText := (self startTagFor: anObject), (aColumn viewBlock value: anObject), 
		(self endTagFor: anObject).
	object notNil
		ifTrue: [anElement addLinkTo: object text: linkText view: view]
		ifFalse: [anElement addText: linkText]! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
printNumber: aNumber object: anObject in: anElement
	anElement addText: 
		(self startTagFor: anObject), aNumber printDotString, '.', (self endTagFor: anObject)! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
removeLastColumn
	self columns notEmpty ifTrue: [self columns remove: self lastColumn].! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
representBinaryOn: writer
	^0! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
resetSummary
	self columns do: [:each | each resetSummary].! !

!WebGrid methodsFor: 'private-row blocks'!
rowBlueBlock
	^self settingsAt: #rowBlueBlock! !

!WebGrid methodsFor: 'settings-row' stamp: ' 21/4/07 22:07'!
rowBlueIfTrue: aBlock
	^self settingsAt: #rowBlueBlock put: aBlock! !

!WebGrid methodsFor: 'private-row blocks'!
rowBoldBlock
	^self settingsAt: #rowBoldBlock! !

!WebGrid methodsFor: 'settings-row' stamp: ' 21/4/07 22:07'!
rowBoldIfTrue: aBlock
	^self settingsAt: #rowBoldBlock put: aBlock! !

!WebGrid methodsFor: 'private-row blocks'!
rowGrayBlock
	^self settingsAt: #rowGrayBlock! !

!WebGrid methodsFor: 'settings-row' stamp: ' 21/4/07 22:07'!
rowGrayIfTrue: aBlock
	^self settingsAt: #rowGrayBlock put: aBlock! !

!WebGrid methodsFor: 'private-row blocks'!
rowGreenBlock
	^self settingsAt: #rowGreenBlock! !

!WebGrid methodsFor: 'settings-row' stamp: ' 21/4/07 22:07'!
rowGreenIfTrue: aBlock
	^self settingsAt: #rowGreenBlock put: aBlock! !

!WebGrid methodsFor: 'private-row blocks'!
rowRedBlock
	^self settingsAt: #rowRedBlock! !

!WebGrid methodsFor: 'settings-row' stamp: ' 21/4/07 22:07'!
rowRedIfTrue: aBlock
	^self settingsAt: #rowRedBlock put: aBlock! !

!WebGrid methodsFor: 'private-row blocks'!
rowYellowBlock
	^self settingsAt: #rowYellowBlock! !

!WebGrid methodsFor: 'settings-row' stamp: ' 21/4/07 22:07'!
rowYellowIfTrue: aBlock
	^self settingsAt: #rowYellowBlock put: aBlock! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
rowsOnPage
	^self settingsAt: #rowsOnPage! !

!WebGrid methodsFor: 'settings-row'!
rowsOnPage: anInteger
	"enables pagination of a table"
	^self settingsAt: #rowsOnPage put: anInteger! !

!WebGrid methodsFor: 'private-building'!
setCollectionFromAspect
	"if aspect set instead of colelction directly"
	self aspect isNil ifTrue: [^nil].
	self collection: (self object perform: self aspect)! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
setNumbering
	"in first column a sequential nr. of this row will be shown"
	self setNumberingOn: 1! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
setNumberingOn: aColumnId
	"in this column a sequential nr. of this row will be shown"
	self numbering: aColumnId! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
setRowAttributesFor: aWebRow object: anObject
	(self rowRedBlock notNil and: [self rowRedBlock value: anObject]) 
		ifTrue: [^aWebRow class: #red].
	(self rowGreenBlock notNil and: [self rowGreenBlock value: anObject]) 
		ifTrue: [^aWebRow class: #green].
	(self rowBlueBlock notNil and: [self rowBlueBlock value: anObject]) 
		ifTrue: [^aWebRow class: #blue].
	(self rowYellowBlock notNil and: [self rowYellowBlock value: anObject]) 
		ifTrue: [^aWebRow class: #yellow].
	(self rowGrayBlock notNil and: [self rowGrayBlock value: anObject]) 
		ifTrue: [^aWebRow class: #gray].! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
settings
	settings isNil ifTrue: [self initSettings].
	^settings! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
settingsAt: aSymbol
	^self settingsAt: aSymbol ifAbsent: [nil]! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
settingsAt: aSymbol ifAbsent: aBlock
	^self settings at: aSymbol ifAbsent: aBlock! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
settingsAt: aSymbol put: aValue
	self settings at: aSymbol put: aValue! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
shortDates
	"year in two digits only"
	^self settingsAt: #shortDates put: true! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
sortAscendingOn: aColumnId
	"this column will be sorted ascending"
	self sortColumn: aColumnId.
	self sortOrder: #ascending! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
sortColumn
	"false or column"
	^self settingsAt: #sortColumn ifAbsent: [nil]! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
sortColumn: aColumnId
	"false or column"
	^self settingsAt: #sortColumn put: aColumnId! !

!WebGrid methodsFor: 'private-building' stamp: 'np 9/29/2008 17:42'!
sortColumnsIfNessesary
	| column sortBlock | 
	 self sortColumn isNil ifTrue: [^nil].
	column := self columns at: self sortColumn.
	sortBlock := (self sortOrder = #ascending)
		ifTrue: [ [:a :b | (a perform: column aspect) < (b perform: column aspect)] ]
		ifFalse: [ [:a :b | (a perform: column aspect) > (b perform: column aspect)] ].
	self collection: (SortedCollection withAll: self collection sortBlock: sortBlock).! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
sortDescendingOn: aColumnId
	"this column will be sorted ascending"
	self sortColumn: aColumnId.
	self sortOrder: #descending! !

!WebGrid methodsFor: 'private-building'!
sortLinkColumn: aWebGridColumn
	| app linkTarget dummyLink |
	"Cannot sort a column which has an addBlock or is numbered"
	aWebGridColumn hasAddBlock ifTrue: [^WebText text: aWebGridColumn name].
	aWebGridColumn isNumbered ifTrue: [^WebText text: aWebGridColumn name].
	app := self app.
	linkTarget := app isStandaloneApp ifTrue: [app class] ifFalse: [app observee].
	dummyLink := WebLink text: aWebGridColumn name linkTo: (Array with: linkTarget with: '-').
	app inDefaultView ifFalse: [dummyLink view: app view].
	dummyLink onClickUpdate: self with: 'sort-', aWebGridColumn id printString.
	^dummyLink! !

!WebGrid methodsFor: 'settings-column' stamp: ' 21/4/07 22:07'!
sortOn: aColumnId
	"this column will be sorted ascending"
	self sortAscendingOn: aColumnId! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
sortOrder
	^self settingsAt: #sortOrder ifAbsent: [#ascending]! !

!WebGrid methodsFor: 'private' stamp: ' 21/4/07 22:07'!
sortOrder: aSymbol
	"#ascending or #descending"
	^self settingsAt: #sortOrder put: aSymbol! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
startTagFor: anObject
	(self rowBoldBlock notNil and: [self rowBoldBlock value: anObject]) ifTrue: [^'<b>'].
	^''! !

!WebGrid methodsFor: 'private-building'!
streamHtmlTo: aStream for: aRequest on: aSession
	"self buildTable." "not so late, build imediately after adding to some parent!!"
	self prepareToHtmlStreamingOn: aSession. "buildTable"
	aStream nextPutAll: self ident, '<div'. self streamAttributesTo: aStream for: aSession. 
	aStream nextPutAll: '>', self eol.
	elements notNil ifTrue: [elements do: [:element | 
		element notNil ifTrue: [element streamHtmlTo: aStream for: aRequest on: aSession] ] ].
	aStream nextPutAll: self ident, '</div>', self eol.! !

!WebGrid methodsFor: 'private-building' stamp: ' 21/4/07 22:07'!
summaryForColumn: aColumn index: aNumber object: anObject
	aColumn needsSummary ifFalse: [^nil].
	aColumn addToSummary: anObject.! !

!WebGrid methodsFor: 'settings-row' stamp: ' 21/4/07 22:07'!
summaryRow: anArrayOfSymbolsOrStrings
	"if you want a summary row, define for desired column: #sum, #count or 'some text' "
	| inx |
	inx := 1.
	anArrayOfSymbolsOrStrings do: [:each |
		self columns size < inx ifTrue: [self addNewColumn].
		(self columns at: inx) summaryType:  each.
		inx := inx + 1]! !

!WebGrid methodsFor: 'private-testing' stamp: ' 21/4/07 22:07'!
wasFilterChangedFor: aWebGridColumn on: anInputField
	| request vlue |
	request := self app session lastRequest.
	(request isAjaxRequest and: [request isPost]) ifFalse: [^false].
	request postKeysAndValuesDo: [:key :value |
		(('field', '*') match: key) ifTrue: [vlue := value] ].
	^vlue = aWebGridColumn filter! !

!WebGrid methodsFor: 'accessing' stamp: 'np 5/7/2008 17:37'!
width
	^self settingsAt: #width ifAbsent: [self defaultWidth]! !

!WebGrid methodsFor: 'accessing' stamp: 'np 5/7/2008 17:38'!
width: anInteger
	self settingsAt: #width put: anInteger! !

!WebGrid class methodsFor: 'instance creation' stamp: 'janko 11/21/2011 13:59'!
new
	^super basicNew
		initialize; "also build"
		creationMethod: #ajaxUpdateWith:  "this method will be called after ajax update"! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
addBlock
	^addBlock! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
addBlock: aBlock
	"result must be kind of WebElement which will be added to table cell"
	"block needs a row object as an argument"
	addBlock := aBlock! !

!WebGridColumn methodsFor: 'private' stamp: ' 21/4/07 22:07'!
addToSummary: anObject
	self summaryType = #count ifTrue: [^self summary: self summary + 1].
	self summaryType = #sum ifTrue:
		[^self summary: self summary + (anObject perform: self aspect)]! !

!WebGridColumn methodsFor: 'private' stamp: 'np 10/17/2008 17:40'!
aidaDeepCopyNotIn: aDict 
	^ nil! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
align
	^align! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
align: aSymbol
	align := aSymbol! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
aspect
	^aspect! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
aspect: aSymbol
	"a method to be called for this column on objects of current row in a collection"
	aspect := aSymbol! !

!WebGridColumn methodsFor: 'private' stamp: 'janko 8/8/2011 20:28'!
autoConvert: anObject
	(anObject class == Date and: [self parent hasShortDates]) 
		ifTrue: [^anObject shorterPrintSloString].
	(anObject class == SpDate) "Sport portable date"
		ifTrue: [^anObject shorterPrintSloString].
	(anObject class == SpTimestamp) "Sport portable timestamp"
		ifTrue: [^anObject printString].
	(anObject = 0 and: [self parent hasNoZeros]) ifTrue: [^''].
	^WebFormElement autoConvertToString: anObject! !

!WebGridColumn methodsFor: 'private' stamp: ' 21/4/07 22:07'!
defaultViewBlock
	^[:object | 
		self aspect isNil ifTrue: [''] ifFalse: [self autoConvert: (object perform: self aspect) ] ]! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
filter
	^filter! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
filter: aString
	"show only rows with value starting with aString"
	filter := aString.
	self parent page: 1 "always to the first page after filter change!!"! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
filterWidth
	"filter input field width"
	^filterWidth! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
filterWidth: aNumber
	"filter input field width"
	filterWidth := aNumber! !

!WebGridColumn methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
hasAddBlock
	^self addBlock notNil! !

!WebGridColumn methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
hasLink
	^self linkAspect notNil | self linkView notNil! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
id
	^id! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
id: aSymbolOrNumber
	"by default it is a position (1st, 2nd etc.)"
	id := aSymbolOrNumber! !

!WebGridColumn methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize! !

!WebGridColumn methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isCheckboxed
	self parent checkboxes isNil ifTrue: [^false].
	^self parent checkboxes = self id! !

!WebGridColumn methodsFor: 'testing'!
isFilterEntered
	"filter criteria is entered"
	^self filter notNil and: [self filter trimBlanks notEmpty].! !

!WebGridColumn methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isNumbered
	self parent numbering isNil ifTrue: [^false].
	^self parent numbering = self id! !

!WebGridColumn methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isSortedAscending
	^(self parent sortColumn = self id) and: [self parent sortOrder = #ascending]! !

!WebGridColumn methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isSortedDescending
	^(self parent sortColumn = self id) and: [self parent sortOrder = #descending]! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
linkAspect
	^linkAspect! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
linkAspect: aSymbol
	"if set, a link to aspect of  row object will be made"
	linkAspect := aSymbol.! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
linkView
	^linkView! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
linkView: aSymbol
	"if set, a link to aspect of  row object (spesified with linkAspect:) with that view will be shown"
	linkView := aSymbol.! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
name
	^name! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
name: aString
	"header name for that column"
	name := aString! !

!WebGridColumn methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
needsSummary
	"summary row is needed"
	^self summaryType notNil! !

!WebGridColumn methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
needsSummaryCount
	^self summaryType notNil and: [self summaryType = #count]! !

!WebGridColumn methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
needsSummarySum
	^self summaryType notNil and: [self summaryType = #sum]! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
parent
	^parent! !

!WebGridColumn methodsFor: 'private' stamp: ' 21/4/07 22:07'!
parent: anObject
	parent := anObject! !

!WebGridColumn methodsFor: 'private' stamp: ' 21/4/07 22:07'!
printString
	^'aWebGridColumn id: ', self id printString! !

!WebGridColumn methodsFor: 'private' stamp: ' 21/4/07 22:07'!
representBinaryOn: writer
	^0! !

!WebGridColumn methodsFor: 'private' stamp: ' 21/4/07 22:07'!
resetSummary
	(self summary notNil and: [self summary isKindOf: Number]) 
		ifTrue: [self summary: 0].! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
setFilter
	"this column will have a filter input field in a row below header"
	self filter: ''! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
sort
	self parent sortColumn == self id
		ifTrue: [self toggleSortOrder]
		ifFalse: [self sortAscending]! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
sortAscending
	self parent sortAscendingOn: self id! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
sortDescending
	self parent sortDescendingOn: self id! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
sorted
	^sorted! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
sorted: aSymbol
	"nil #ascending #descending"
	sorted := aSymbol! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
summary
	"here summary of all rows is acumulated, depending on summaryType"
	^summary! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
summary: aNumber
	"see comment in method #summary"
	summary := aNumber! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
summaryType
	"summary row is added with appropriate value, which can be:
	- #sum : sum of all cels in that column
	- #count : number of all rows, without heading and summary
	- 'some text' to be shown in this summary cell"
	^summaryType! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
summaryType: aSymbolOrString
	"see comment in method #summary"
	summaryType := aSymbolOrString.
	(aSymbolOrString = #count) | (aSymbolOrString = #sum)
		ifTrue: [self summary: 0]
		ifFalse: [self summary: aSymbolOrString].! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
summaryValue
	"for adding to a table"
	self summary isNil ifTrue: [^''].
	(self summary isKindOf: Number) ifTrue: [^self summary printDotString].
	^self summary "as text"! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
toggleSortOrder
	self parent sortColumn == self id
		ifTrue: [self parent sortOrder == #descending
			ifTrue: [self sortAscending]
			ifFalse: [self sortDescending]]
		ifFalse: [self sortAscending]! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
viewBlock
	viewBlock isNil ifTrue: [self viewBlock: self defaultViewBlock].
	^viewBlock! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
viewBlock: aBlock
	"how to show this column from collection. There is a default"
	"block needs a row object as an argument"
	viewBlock := aBlock! !

!WebGridColumn methodsFor: 'private-accessing' stamp: ' 21/4/07 22:07'!
width
	^width! !

!WebGridColumn methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
width: aNumber
	width := aNumber! !

!WebGridColumn class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newOn: aWebGrid
	^super new initialize parent: aWebGrid! !

!WebIFrame methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
frameBorder: aNumber
	"1 yes (default), 0 no"
	self attributesAt: #frameborder put: aNumber! !

!WebIFrame methodsFor: 'private'!
hasTag
	^true! !

!WebIFrame methodsFor: 'attributes' stamp: 'mivsek 1/10/2008 22:20'!
height: aNumber
	self attributesAt: #height put: aNumber printString! !

!WebIFrame methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
scrolling: aSymbol
	"#yes #no #auto (default)"
	self attributesAt: #scrolling put: aSymbol! !

!WebIFrame methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
size: aPoint
	"set the size of frame area in format width@height pixels"
	self width: aPoint x.
	self height: aPoint y.! !

!WebIFrame methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
src: anUrlString
	self attributesAt: #src put: anUrlString! !

!WebIFrame methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession. 
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	aStream nextPutAll: self ident, '<iframe'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '>'.
	aStream nextPutAll: '</iframe>'.
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebIFrame methodsFor: 'attributes' stamp: 'mivsek 1/10/2008 22:21'!
width: aNumber
	self attributesAt: #width put: aNumber printString! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
alt: aString
	self attributes at: #alt put: aString! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
border: aNumber
	self attributesAt: #border put: aNumber printString! !

!WebImage methodsFor: 'private'!
hasTag
	^true! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
height: aNumber
	self attributesAt: #height put: aNumber printString! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
hspace: aNumber
	self attributesAt: #hspace put: aNumber printString! !

!WebImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
image
	^image! !

!WebImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
image: anImage
	"set the image object of WebImage. 
	If nil, then urlreference should exist for image somewhere else"
	image := anImage.! !

!WebImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
image: anImage align: aSymbol
	"set the image object of WebImage. and aligment"
	self image: anImage.
	self align: aSymbol! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
imageAlign: aSymbol
	"#left #center #right"
	self attributesAt: #align put: aSymbol asString! !

!WebImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
imageMap
	^imageMap! !

!WebImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
imageMap: anImageMap
	imageMap := anImageMap! !

!WebImage methodsFor: 'initialize-release' stamp: 'janko 3/21/2008 16:23'!
initialize
	self border: 0.
	self alt: ''.! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
name: aString
	self attributesAt: #name put: aString! !

!WebImage methodsFor: 'private' stamp: 'janko 9/19/2011 14:30'!
prepareAttributesToPrintOn: aSession
	super prepareAttributesToPrintOn: aSession.
	self src: (self urlOnSession: aSession).
	self imageMap notNil ifTrue: [self usemap: self imageMap name].! !

!WebImage methodsFor: 'private'!
prepareAttributesToStreamOn: aSession
	super prepareAttributesToStreamOn: aSession.
	(self attributesAt: #src) notNil  "image source already set"
		ifFalse: [self src: (self urlOnSession: aSession)].
	self imageMap notNil ifTrue: [self usemap: self imageMap name].! !

!WebImage methodsFor: 'private'!
shouldIdent
	^false! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
size: aPoint
	"set the size of an image in format width@height"
	self width: aPoint x.
	self height: aPoint y.! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
src: aString
	self attributesAt: #src put: aString! !

!WebImage methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession. 
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	aStream nextPutAll: self ident, '<img'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: self tagClosing.
	self imageMap notNil ifTrue: 
		[imageMap streamHtmlTo: aStream for: aRequest on: aSession].
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebImage methodsFor: 'private'!
urlForLiveImageOn: aSession
	 ^aSession site urlResolver halfUrlFor: self image! !

!WebImage methodsFor: 'private'!
urlForMethodImageOn: aSession
	 ^aSession site urlResolver halfUrlFor: self image! !

!WebImage methodsFor: 'private'!
urlOnSession: aSession
	self image isNil ifTrue: [^''].
	self image isString ifTrue: [^self image].
	(self image isKindOf: WebLiveImage) ifTrue: [^self urlForLiveImageOn: aSession].
	(self image isKindOf: WebMethodImage) ifTrue: [^self urlForMethodImageOn: aSession].
	^aSession site urlResolver halfUrlFor: self image.! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
usemap: aString
	self attributesAt: #usemap put: aString! !

!WebImage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
width: aNumber
	self attributesAt: #width put: aNumber printString! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
gif: aSymbol
	"this method will be called in your webStyle and this method 
	should return a gif in byte array format"
	| methodImage image |
	image := self new.
	methodImage := WebMethodImage
		fromMethod: aSymbol 
		on: image style 
		contentType: 'image/gif' 
		site: image site.
	^image image: methodImage! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
gif: aSymbol  size: aPoint
	"this method will be called in your webStyle and this method 
	should return a gif in byte array format"
	| methodImage image |
	image := self new.
	methodImage := WebMethodImage
		fromMethod: aSymbol 
		on: image style 
		contentType: 'image/gif' 
		site: image site.
	^image image: methodImage;  size: aPoint! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
image: anImage
	^self new image: anImage! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
image: anImage align: aSymbol
	^self new image: anImage align: aSymbol! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
image: anImage size: aPoint
	^self new image: anImage; size: aPoint! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
jpeg: aSymbol
	"this method will be called in your webStyle and this method 
	should return a jpeg in byte array format"
	| methodImage image |
	image := self new.
	methodImage := WebMethodImage
		fromMethod: aSymbol 
		on: image style 
		contentType: 'image/jpeg' 
		site: image site.
	^image image: methodImage! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
jpeg: aSymbol  size: aPoint
	"this method will be called in your webStyle and this method 
	should return a jpeg in byte array format"
	| methodImage image |
	image := self new.
	methodImage := WebMethodImage
		fromMethod: aSymbol 
		on: image style 
		contentType: 'image/jpeg' 
		site: image site.
	^image image: methodImage;  size: aPoint! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
png: aSymbol
	"this method will be called in your webStyle and this method 
	should return a png in byte array format"
	| methodImage image |
	image := self new.
	methodImage := WebMethodImage
		fromMethod: aSymbol 
		on: image style 
		contentType: 'image/png' 
		site: image site.
	^image image: methodImage! !

!WebImage class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
png: aSymbol  size: aPoint
	"this method will be called in your webStyle and this method 
	should return a jpeg in byte array format"
	| methodImage image |
	image := self new.
	methodImage := WebMethodImage
		fromMethod: aSymbol 
		on: image style 
		contentType: 'image/png' 
		site: image site.
	^image image: methodImage;  size: aPoint! !

!WebImageMap methodsFor: 'adding areas' stamp: ' 21/4/07 22:07'!
addCirclePos: aPositionPoint diameter: aNumber  link: aWebLink

	| coords |
	coords := Array
		with: aPositionPoint x
		with: aPositionPoint y
		with: aNumber.
	self addShape: #circle coordinates: coords link: aWebLink! !

!WebImageMap methodsFor: 'adding areas' stamp: ' 21/4/07 22:07'!
addRectanglePos: aPositionPoint size: aSizePoint  link: aWebLink

	| coords |
	coords := Array
		with: aPositionPoint x
		with: aPositionPoint y
		with: (aPositionPoint + aSizePoint) x
		with: (aPositionPoint + aSizePoint) y.
	self addShape: #rect coordinates: coords link: aWebLink! !

!WebImageMap methodsFor: 'adding areas' stamp: ' 21/4/07 22:07'!
addShape: aShapeSymbol coordinates: anArray link: aWebLink

	self areas add: 
		(Array with: aShapeSymbol with: anArray with: aWebLink)! !

!WebImageMap methodsFor: 'private' stamp: ' 21/4/07 22:07'!
areas
	areas isNil ifTrue: [self initAreas].
	^areas! !

!WebImageMap methodsFor: 'private'!
hasTag
	^true! !

!WebImageMap methodsFor: 'initialize - release' stamp: ' 21/4/07 22:07'!
initAreas
	areas := OrderedCollection new.! !

!WebImageMap methodsFor: 'initialize - release' stamp: ' 21/4/07 22:07'!
initialize
	self name: self randomName.! !

!WebImageMap methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
name
	^self attributesAt: #name! !

!WebImageMap methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
name: aString
	self attributesAt: #name put: aString.! !

!WebImageMap methodsFor: 'private' stamp: 'np 10/18/2008 13:15'!
randomName

	^'map', ((AIDASite random next * 100) truncated) printString! !

!WebImageMap methodsFor: 'private' stamp: ' 21/4/07 22:07'!
shouldIdent
	^true! !

!WebImageMap methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession 
	| link |
	self prepareToHtmlStreamingOn: aSession.
	aStream nextPutAll: self ident , '<map'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '"> ' , self eol.
	self areas do: 
			[:area | 
			aStream
				nextPutAll: self identMore , '<area shape="';
				nextPutAll: (area at: 1) asString;
				nextPutAll: '" coords="'.
			1 to: (area at: 2) size
				do: 
					[:inx | 
					inx > 1 ifTrue: [aStream nextPutAll: ','].
					aStream nextPutAll: ((area at: 2) at: inx) printString].
			link := area at: 3.
			link prepareAttributesToStreamOn: aSession.
			link streamAttributesTo: aStream for: aSession.
			aStream nextPutAll: '"> ' , self eol].
	aStream nextPutAll: self ident , '</map>' , self eol! !

!WebImageMap class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebInPlaceEditable2Text methodsFor: 'private-streaming'!
addSetupScript
	"jQuery specific"
self scriptBefore: '
$(function() {
	var $log = $( "#log" );
	function log( text ) {
		$log.append( text + "<br/>" );
	}
	$( "#', self id asString, '" )
		.bind( "editsave", function( ev, ui ) {
			log( "save: " + ui.value );
		})
		.bind( "editchange", function( ev, ui ) {
			log( "change: " + ui.value );
		})
		.bind( "editcancel", function() {
			log( "cancel" );
	})
	.editable();
}); 
'! !

!WebInPlaceEditable2Text methodsFor: 'accessing'!
allow
	"is edit allowed at all?"
	allow isNil ifTrue: [^true].
	^allow! !

!WebInPlaceEditable2Text methodsFor: 'private'!
allow: aBoolean
	allow := aBoolean! !

!WebInPlaceEditable2Text methodsFor: 'private'!
attribute
	"<b> etc"
	attribute isNil ifTrue: [^''].
	^attribute! !

!WebInPlaceEditable2Text methodsFor: 'private'!
attribute: aString
	attribute := aString! !

!WebInPlaceEditable2Text methodsFor: 'accessing'!
bold
	self attribute: '<b>'! !

!WebInPlaceEditable2Text methodsFor: 'settings'!
cancelText
	^'Preklic^i'  convertToSloveneChars! !

!WebInPlaceEditable2Text methodsFor: 'settings'!
columns
	"length of edit field or textarea"
	self size isNil ifTrue: [^20].
	self size class == Point ifTrue: [^self size x].
	^self size! !

!WebInPlaceEditable2Text methodsFor: 'private'!
endAttributeTag
	self attribute isEmpty ifTrue: [^''].
	^'</', self attribute copyFrom: 3 to: 5! !

!WebInPlaceEditable2Text methodsFor: 'private'!
externalControl
	"Scriptaculous specific"
	| idSymbol |
	self triggerElement isNil ifTrue: [^''].
	idSymbol := self triggerElement isSymbol 
		ifTrue: [self triggerElement] ifFalse: [self triggerElement ensureId. self triggerElement id].
	^', externalControl:''', idSymbol asString, ''''! !

!WebInPlaceEditable2Text methodsFor: 'initialize-release'!
initialize
	"jQuery specific"
	super initialize.
	JQueryLibrary ensureUI "in page header"! !

!WebInPlaceEditable2Text methodsFor: 'private'!
isFormated
	^formated notNil and: [formated]! !

!WebInPlaceEditable2Text methodsFor: 'settings'!
okText
	^'Zapis^i'  convertToSloveneChars! !

!WebInPlaceEditable2Text methodsFor: 'private-streaming'!
prepareClassAttribute
	self class: #( #'ui-editable' #'ui-widget')! !

!WebInPlaceEditable2Text methodsFor: 'private-streaming'!
properlyFormatedValueOn: aSession
	| vlue |
	vlue := self value.
	vlue isNil ifTrue: [^''].
	self isFormated ifTrue: [vlue := vlue asWikiHtml].
	^AIDASite convertToWeb: "UTF8 encoding"
		(WebFormElement autoConvertAndEncodeQuotes: vlue) on: aSession! !

!WebInPlaceEditable2Text methodsFor: 'settings'!
rows
	"number of lines in edit area"
	self size isNil ifTrue: [^1].
	self size class == Point ifTrue: [^self size y].
	^1! !

!WebInPlaceEditable2Text methodsFor: 'private'!
rowsCols
	^'rows:', self rows printString, ',cols:', self columns printString! !

!WebInPlaceEditable2Text methodsFor: 'settings'!
savingText
	^'...'! !

!WebInPlaceEditable2Text methodsFor: 'private'!
size
	"if number, then editor is one line, if point, it is text area!!"
	^size! !

!WebInPlaceEditable2Text methodsFor: 'accessing'!
size: aNumberOrPoint
	"if number, then editor is one line, if point, it is text area!!"
	size := aNumberOrPoint! !

!WebInPlaceEditable2Text methodsFor: 'private'!
startAttributeTag
	^self attribute! !

!WebInPlaceEditable2Text methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	self ensureId. 
	self prepareClassAttribute.
	self prepareToHtmlStreamingOn: aSession.
	self allow ifTrue: [self addSetupScript].
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	aStream nextPutAll: self startAttributeTag.
	aStream nextPutAll: '<span '. self streamAttributesTo: aStream for: aSession. aStream nextPut: $>. 
	aStream nextPutAll: (self properlyFormatedValueOn: aSession).
	aStream nextPutAll: '</span>', self endAttributeTag.
	(self allow and: [self triggerElement isKindOf: WebElement])
		ifTrue: [self triggerElement streamHtmlTo: aStream for: aRequest on: aSession].
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebInPlaceEditable2Text methodsFor: 'private'!
textOptions
	"Scriptaculous specific"
	| text |
	text := ', okText:''', self okText, ''', cancelText:''', self cancelText, ''', savingText:''', self savingText, ''''.
	^AIDASite convertToWeb: text on: self app session! !

!WebInPlaceEditable2Text methodsFor: 'accessing'!
triggerElement
	"element which triggers edit mode. If it is real element and not only id, it will be 
       added after editable text, "
	^triggerElement! !

!WebInPlaceEditable2Text methodsFor: 'accessing'!
triggerElement: aWebElementOrId
	triggerElement := aWebElementOrId! !

!WebInPlaceEditable2Text methodsFor: 'accessing'!
wikiFormated
	"source text is formated in wiki format"
	formated := true! !

!WebInPlaceEditable2Text class methodsFor: 'instance creation'!
aspect: aSymbol for: anObject
	^self new aspect: aSymbol for: anObject! !

!WebInPlaceEditable2Text class methodsFor: 'instance creation'!
aspect: aSymbol for: anObject size: aNumberOrPoint
	^self new aspect: aSymbol for: anObject; size: aNumberOrPoint! !

!WebInPlaceEditable2Text class methodsFor: 'instance creation'!
aspect: aSymbol for: anObject size: aNumberOrPoint allow: aBoolean
	^self new aspect: aSymbol for: anObject; 
		size: aNumberOrPoint;
		allow: aBoolean	"is edit allowed at all?"! !

!WebInPlaceEditableText methodsFor: 'private'!
addSetupScript
	"Scriptaculous specific"
	| url urlFormated |
	url := self ajaxCallUrl, '?', (self ajaxCallUrlParametersFor: self context: self context), '&ajaxInPlaceEditing'.
	urlFormated := self isFormated ifTrue: [url, '&wikiFormated'] ifFalse: [url].
	self scriptAfter: 'new Ajax.InPlaceEditor(''', self id asString, 
		''', ''', urlFormated, ''', {', self rowsCols, self textOptions, self externalControl, 
		(self isFormated ifTrue: [',loadTextURL:''', url, ''''] ifFalse: ['']), '})'! !

!WebInPlaceEditableText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allow
	"is edit allowed at all?"
	allow isNil ifTrue: [^true].
	^allow! !

!WebInPlaceEditableText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
allow: aBoolean
	allow := aBoolean! !

!WebInPlaceEditableText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
attribute
	"<b> etc"
	attribute isNil ifTrue: [^''].
	^attribute! !

!WebInPlaceEditableText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
attribute: aString
	attribute := aString! !

!WebInPlaceEditableText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
bold
	self attribute: '<b>'! !

!WebInPlaceEditableText methodsFor: 'settings' stamp: 'mivsek 1/10/2008 22:37'!
cancelText
	| app |
	app := self app.
	^app notNil 
		ifTrue: [self app style inPlaceCancelText]
		ifFalse: ['Cancel']! !

!WebInPlaceEditableText methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
columns
	"length of edit field or textarea"
	self size isNil ifTrue: [^20].
	self size class == Point ifTrue: [^self size x].
	^self size! !

!WebInPlaceEditableText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
endAttributeTag
	self attribute isEmpty ifTrue: [^''].
	^'</', self attribute copyFrom: 3 to: 5! !

!WebInPlaceEditableText methodsFor: 'private'!
externalControl
	"Scriptaculous specific"
	| idSymbol |
	self triggerElement isNil ifTrue: [^''].
	idSymbol := self triggerElement isSymbol 
		ifTrue: [self triggerElement] ifFalse: [self triggerElement ensureId. self triggerElement id].
	^', externalControl:''', idSymbol asString, ''''! !

!WebInPlaceEditableText methodsFor: 'initialize-release'!
initialize
	"Scriptaculous specific"
	super initialize.
	ScriptaculousLibrary ensureScriptaculous.! !

!WebInPlaceEditableText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
isFormated
	^formated notNil and: [formated]! !

!WebInPlaceEditableText methodsFor: 'settings' stamp: 'mivsek 1/10/2008 22:37'!
okText
	| app |
	app := self app.
	^app notNil 
		ifTrue: [self app style inPlaceOkText]
		ifFalse: ['Ok']! !

!WebInPlaceEditableText methodsFor: 'private-streaming'!
properlyFormatedValueOn: aSession
	| vlue |
	vlue := self value.
	vlue isNil ifTrue: [^''].
	self isFormated ifTrue: [vlue := vlue asWikiHtml].
	^AIDASite convertToWeb: "UTF8 encoding"
		(WebFormElement autoConvertAndEncodeQuotes: vlue) on: aSession! !

!WebInPlaceEditableText methodsFor: 'settings' stamp: ' 21/4/07 22:07'!
rows
	"number of lines in edit area"
	self size isNil ifTrue: [^1].
	self size class == Point ifTrue: [^self size y].
	^1! !

!WebInPlaceEditableText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
rowsCols
	^'rows:', self rows printString, ',cols:', self columns printString! !

!WebInPlaceEditableText methodsFor: 'settings' stamp: 'mivsek 1/10/2008 22:37'!
savingText
	^'...'! !

!WebInPlaceEditableText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
size
	"if number, then editor is one line, if point, it is text area!!"
	^size! !

!WebInPlaceEditableText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
size: aNumberOrPoint
	"if number, then editor is one line, if point, it is text area!!"
	size := aNumberOrPoint! !

!WebInPlaceEditableText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
startAttributeTag
	^self attribute! !

!WebInPlaceEditableText methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	self ensureId. 
	self prepareToHtmlStreamingOn: aSession.
	self allow ifTrue: [self addSetupScript].
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	aStream nextPutAll: self startAttributeTag.
	aStream nextPutAll: '<span '. self streamAttributesTo: aStream for: aSession. aStream nextPut: $>. 
	aStream nextPutAll: (self properlyFormatedValueOn: aSession).
	aStream nextPutAll: '</span>', self endAttributeTag.
	(self allow and: [self triggerElement isKindOf: WebElement])
		ifTrue: [self triggerElement streamHtmlTo: aStream for: aRequest on: aSession].
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebInPlaceEditableText methodsFor: 'private'!
textOptions
	"Scriptaculous specific"
	| text |
	text := ', okText:''', self okText, ''', cancelText:''', self cancelText, ''', savingText:''', self savingText, ''''.
	^AIDASite convertToWeb: text on: self app session! !

!WebInPlaceEditableText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
triggerElement
	"element which triggers edit mode. If it is real element and not only id, it will be 
       added after editable text, "
	^triggerElement! !

!WebInPlaceEditableText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
triggerElement: aWebElementOrId
	triggerElement := aWebElementOrId! !

!WebInPlaceEditableText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
wikiFormated
	"source text is formated in wiki format"
	formated := true! !

!WebInPlaceEditableText class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject
	^self new aspect: aSymbol for: anObject! !

!WebInPlaceEditableText class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject size: aNumberOrPoint
	^self new aspect: aSymbol for: anObject; size: aNumberOrPoint! !

!WebInPlaceEditableText class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject size: aNumberOrPoint allow: aBoolean
	^self new aspect: aSymbol for: anObject; 
		size: aNumberOrPoint;
		allow: aBoolean	"is edit allowed at all?"! !

!WebIndex methodsFor: 'searching' stamp: ' 21/8/07 09:38'!
addFreshnessRelevance: aDictionary
	"objects with newer modified date are more relevant"
	| weight |
	aDictionary keysDo: [:object |
		(object class selectors includes: #modified) ifTrue:
			[weight := 1000 - (Date today subtractDate: object modified) max: 0.
			aDictionary at: object put:  (aDictionary at: object) + weight] ]! !

!WebIndex methodsFor: 'searching' stamp: ' 21/8/07 09:38'!
addVisitsRelevance: aDictionary
	"objects with more visits are more relevant"
	| weight |
	aDictionary keysDo: [:object |
		(object class selectors includes: #modified) ifTrue:
			[weight := 1000 - (Date today subtractDate: object modified) max: 0.
			aDictionary at: object put:  (aDictionary at: object) + weight] ]! !

!WebIndex methodsFor: 'popular words' stamp: ' 21/8/07 09:38'!
allPopularWordsAndCounts
	"return a collection of words and their total counts, most popular first"
	| collection |
	collection := OrderedCollection new.
	self popularWords keysAndValuesDo: [:word :counter |  
		collection add: (Array with: word with: counter total)].
	^SortedCollection
		withAll: collection
		sortBlock: [:a :b | (a at: 2) > (b at: 2)].! !

!WebIndex methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
allWordsAndWeights
	"return sorted collection of all words and sum of weights, biggeest weight first"
	| collection weight |
	collection := OrderedCollection new.
	self index keysDo: [:halfWord |
		(self index at: halfWord) keysDo: [:restWord |
			weight := ((self index at: halfWord) at: restWord) inject: 0 into: 
				[:sum :thirdDictWeight | sum + (thirdDictWeight)].
			collection add: (Array with: halfWord, restWord with: weight) ] ].
	^SortedCollection 
		withAll: collection
		sortBlock: [:a :b | (a at: 2) > (b at: 2)].

" WebIndex default allWordsAndWeights "! !

!WebIndex methodsFor: 'popular words' stamp: ' 21/8/07 09:38'!
countPopularWords: anArray
	anArray do: [:word |
		(self popularWords includesKey: word) ifFalse: [self openPopularWord: word].
		(self popularWords at: word) incCounter].! !

!WebIndex methodsFor: 'private' stamp: ' 21/8/07 09:38'!
halfWordFrom: aString
	"prepare first three letters, lowercase (also slovene chars)"
	^AIDASite sloveneLowercase: (aString copyFrom: 1 to: 3).! !

!WebIndex methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
index
	"index is a dictionary with first three lowercase letters of each indexed world as key and
	another dictionary for remaining letters as value. The second dictionary has remaining letters for key
      and dictionary with objects, where this word occured, as key and number of occurences as value"
	index isNil ifTrue: [self initIndex].
	^index! !

!WebIndex methodsFor: 'indexing' stamp: ' 21/8/07 09:38'!
indexObject: anObject
	"if anObject responds to a message indexText, then index all its world in index.
	 However, first 	remove indexing for that object if already exist (so, for reindexing  
	objects, use this method also). For performance reasons indexing is done in background"
	self workQueue nextPut: anObject.

"WebIndex default indexObject: WebIndex default"! !

!WebIndex methodsFor: 'indexing' stamp: ' 21/4/07 22:07'!
indexObjects: aCollection
	aCollection do: [:each | self indexObject: each].! !

!WebIndex methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
indexText
	^'Search engine iskanje rezultati iskanja iskalnik'! !

!WebIndex methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
indexTitle
	^'Iskalnik'! !

!WebIndex methodsFor: 'indexing' stamp: ' 21/8/07 09:38'!
indexWord: aString inObject: anObject
	"put a word in that object in index if word is valid one for indexing"
	self indexWord: aString occurences: 1 inObject: anObject! !

!WebIndex methodsFor: 'private-indexing'!
indexWord: aString occurences: aNumber inObject: anObject
	"put a aNumber occurences of a word in that object in index if word is valid one for indexing"
	| halfWord restWord secDic thirdDic num |
	(self isValidWord: aString) ifFalse: [^self].
	"put an object in indexed object, if not already exist"
	(self indexedObjects includesKey: anObject) ifFalse:
		[self indexedObjects at: anObject put: IdentitySet new].
	"prepare two parts of a words, first three letters and rest"
	halfWord := self halfWordFrom: aString.
	restWord := self restWordFrom: aString.
	"find or create a second level dictionary from first level one"
	secDic := self index at: halfWord 
		ifAbsent: [self index at: halfWord put: Dictionary new].
	"find or create last level dictionary from second level one"
	thirdDic := secDic at: restWord 
		ifAbsent: [secDic at: restWord put: Dictionary new].
	"put an object to third level dictionary and increment nr of worlds if not already exist"
	num := thirdDic at: anObject ifAbsent: [thirdDic at: anObject put: 0].
	thirdDic at: anObject put: num + aNumber.
	"make reference to the third level dictionary for a indexed word"
	(self indexedObjects at: anObject) add: thirdDic.! !

!WebIndex methodsFor: 'private-indexing'!
indexWords: aWordDictionary inObject: anObject
	self removeObject: anObject.  "if exist"
	aWordDictionary keysAndValuesDo: [:key :value | 
		self indexWord: key occurences: value inObject: anObject].! !

!WebIndex methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
indexedObjects
	"return a dictionary with objects which worlds are in index as keys and a set of pointers to third 
       level dictionary in index as values"
	indexedObjects isNil ifTrue: [self initIndexedObjects].
	^indexedObjects! !

!WebIndex methodsFor: 'private' stamp: 'mivsek 6/13/2007 16:25'!
indexer
	"indexing process"
	^indexer! !

!WebIndex methodsFor: 'private' stamp: 'mivsek 6/13/2007 16:26'!
indexerProcess
	"this background process wait for objects to be indexed in workQueue and
	index them without disturbing others."
	| object |
	[true] whileTrue: 
		[object := self workQueue next.
		self privIndexObject: object.
		self reportIndexingOf: object].! !

!WebIndex methodsFor: 'initialize-release' stamp: ' 21/8/07 09:38'!
initIndex
	index := Dictionary new.! !

!WebIndex methodsFor: 'initialize-release' stamp: ' 21/8/07 09:38'!
initIndexedObjects
	indexedObjects := IdentityDictionary new.! !

!WebIndex methodsFor: 'initialize-release' stamp: ' 21/8/07 09:38'!
initPopularWords
	popularWords := Dictionary new.! !

!WebIndex methodsFor: 'initialize-release' stamp: 'mivsek 6/13/2007 16:26'!
initialize
	self initIndex.
	self initIndexedObjects.
	self initPopularWords.
	workQueue := nil.
	self start.

"WebIndex default initialize"! !

!WebIndex methodsFor: 'testing'!
isValidWord: aString
	"a valid word for indexing has three or more letters, can have also numbers "
	(aString size >= 3) ifFalse: [^false].
"	aString do:[:chr | chr isDigit ifTrue: [^false] ]. " "no more!!"
	^true! !

!WebIndex methodsFor: 'searching'!
objectsForWord: aString
	"find all objects, which include this word. Return a dictionary with objects as 
       keys and weights as values" 
	"only current versions of versioned object like documents!!"
	| objDict |
	objDict := self privObjectsForWord: aString.
	objDict := objDict keysDo: [:object | 
		((object isKindOf: VersionedObject) and: [object isCurrentVersion not])
			ifTrue: [objDict removeKey: object] ].
	^objDict

"(WebIndex default objectsForWord: 'knjiga') keys "! !

!WebIndex methodsFor: 'searching' stamp: ' 21/8/07 09:38'!
objectsForWords: aString
	"find all objects, which include one or more specified words. return a sorted collection 
	of associations with found objects as keys an relevance of them as values. Most relevant 
	objects are first. Relevance means: 
		nr. of words found * 1000 + occurences of each word"
	| words hits newHits foundWords |
	Transcript show: ' search.'.
	words := (self wordsInText: aString) keys.
	words := words select: [:word | self isValidWord: word].
	hits := IdentityDictionary new.
	foundWords := OrderedCollection new. 
	words do: [:word | 
		newHits := self objectsForWord: word.
		newHits notEmpty ifTrue: [foundWords add: word].
		newHits keysAndValuesDo: [:key :value |
			(hits includesKey: key)
				ifTrue: [hits at: key put: (hits at: key)+1000]
				ifFalse: [hits at: key put: 1000+value] ] ].
	self countPopularWords: foundWords.  "count as popular only words, which exist in objects"
	self addFreshnessRelevance: hits.
	Transcript show: '.ok '.
	^SortedCollection withAll: hits associations sortBlock: [:first : second | first value > second value].

"
WebIndex instance objectsForWords: 'ljub'
"! !

!WebIndex methodsFor: 'popular words' stamp: ' 21/4/07 22:07'!
openPopularWord: aString
	self popularWords at: aString put: WebCounter new.! !

!WebIndex methodsFor: 'accessing' stamp: ' 21/8/07 09:38'!
popularWords
	"return a dictionary of words as keys and aWebCounters as values"
	popularWords isNil ifTrue: [self initPopularWords].
	^popularWords! !

!WebIndex methodsFor: 'private-indexing'!
prepareWord: aString
	"cut last char if vowel. Used for simple declension of slovene words"
	aString last isVowel 
		ifTrue: [aString size > 3
			ifTrue: [^aString copyFrom: 1 to: (aString size - 1)] ].
	^aString.

"
WebIndex new prepareWord: 'knjiga'
"! !

!WebIndex methodsFor: 'private-indexing'!
privIndexObject: anObject
	"index all words in text. Index title with weight 100 as well"
	| textDict titleDict |
	(anObject class canUnderstand: #indexText) ifTrue:
		[textDict := self wordsInText: anObject indexText.
	(anObject class canUnderstand: #indexTitle) ifTrue:
		[titleDict := self wordsInText: anObject indexTitle].
		titleDict keysDo: [:word | titleDict at: word put: (titleDict at: word)*100]. "weight words in title 100x"	
		titleDict keysDo: [:word | 
			(textDict includesKey: word) 
				ifFalse: [textDict at: word put: (titleDict at: word)]
				ifTrue: [textDict at: word put: (textDict at: word) + (titleDict at: word)] ] ].	
	self indexWords: textDict inObject: anObject! !

!WebIndex methodsFor: 'private-searching'!
privObjectsForWord: aString
	"find all objects, which include this word. Return more important objects first (more 
	occurences of worlds etc.)"
	| hits secDic searchWord keys word |
	(self isValidWord: aString) ifTrue:
		[hits := IdentityDictionary new.
		word := self prepareWord: aString.
		searchWord := (self restWordFrom: word), '*'.
		secDic := self index at: (self halfWordFrom: word) ifAbsent: [^hits].
		keys := secDic keys select: [:fkey | searchWord match: fkey].
		keys do: [:skey | 
       		(secDic at: skey) keysAndValuesDo: [:tkey :tvalue | 
				(hits includesKey: tkey) ifFalse: [hits at: tkey put: 0].
				hits at: tkey put: (hits at: tkey)+tvalue] ].
		^hits.
		] ifFalse: [^nil].

"(WebIndex default objectsForWord: 'knjiga') keys "! !

!WebIndex methodsFor: 'indexing' stamp: ' 21/8/07 09:38'!
removeObject: anObject
	"remove object from all word pointers in index"
	(self indexedObjects at: anObject ifAbsent: [^nil]) do:
		[:each | each removeKey: anObject ifAbsent: [] ].
	self indexedObjects removeKey: anObject.! !

!WebIndex methodsFor: 'private-indexing'!
reportIndexingOf: anObject
	| text site |
	[text := anObject class name.
	site := [anObject repository site name] on: Error do: [:ex | ''].
	(anObject isKindOf: Document) ifTrue: 
		[text := text, ' "', anObject title asSloveneWithoutCircumflexes,  '" on ', site.
		anObject modifiedBy notNil ifTrue:
			[text := text, ' by ', anObject modifiedBy nameSurname asSloveneWithoutCircumflexes] ].
	(anObject isKindOf: FileProxy) ifTrue: 
		[text := text, ' "', anObject filename asString, '" on ', anObject site name].
	Transcript cr; show: '(indexing  ', text, ')']
		fork. "to prevent stoping indexer in case of error"! !

!WebIndex methodsFor: 'private-indexing'!
restWordFrom: aString
	"preparerest of the word, lowercase (also slovene chars)"
	^AIDASite sloveneLowercase: (aString copyFrom: 4 to: aString size)! !

!WebIndex methodsFor: 'initialize-release' stamp: 'mivsek 6/13/2007 16:30'!
start
	self stop.
	indexer := [self indexerProcess] forkAt: Processor userBackgroundPriority.! !

!WebIndex methodsFor: 'initialize-release' stamp: 'mivsek 6/13/2007 16:30'!
stop
	self indexer notNil ifTrue: [self indexer terminate. indexer := nil].! !

!WebIndex methodsFor: 'indexing'!
wordsInText: aString
	"return a dictionary with all words as keys and number of occurences as values"
	| lastInx currInx word words |
	lastInx := 1. currInx := 1. words := Dictionary new. 
	aString do: [:chr | 
		(chr isAlphaNumeric or: [AIDASite isSloveneCharacter: chr]) ifFalse: 
			[word := aString copyFrom: lastInx to: currInx-1.
			lastInx := currInx+1.
			word := AIDASite sloveneLowercase: word.
			word notEmpty ifTrue: 
				[(words includesKey: word) ifFalse: [words at: word put: 0].
				words at: word put: (words at: word) + 1] ].
		currInx := currInx + 1].
	word := aString copyFrom: lastInx to: currInx-1.
	word := AIDASite sloveneLowercase: word.
	word notEmpty ifTrue: 
		[(words includesKey: word) ifFalse: [words at: word put: 0].
		words at: word put: (words at: word) + 1].
	^words

"
WebIndex default wordsInText: 'erot ljub'
"! !

!WebIndex methodsFor: 'private' stamp: 'mivsek 6/13/2007 16:31'!
workQueue
	"all object to be indexed goes in this queue. An indexer process (which is started first time
	someone requests indexing) then index an object in background"

	workQueue isNil ifTrue: 
		[workQueue := SharedQueue new.
		self indexer isNil ifTrue: [self start] ].
	^workQueue.! !

!WebIndex class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
default
	^AIDASite default index! !

!WebIndex class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
instVarMap
	"Gemstone"

	^super instVarMap,
		#( 	(workQueue nil) )! !

!WebIndex class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize.

"WebIndex new"! !

!WebIndex class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
replicationSpec

	^super replicationSpec, 
		#(  	(index forwarder)
			(indexedObjects forwarder) 
			(popularWords forwarder)  	)! !

!WebInputField methodsFor: 'private'!
acceptInputFromValue: aString
	| vlue |
	aString isNil ifTrue: [^nil].  "error?"
	vlue :=  AIDASite convertFromWeb: aString on: self session. "ensure unicode!!"
	vlue := (WebFormElement autoConvertString:  vlue toObject: self value).
	self value: vlue.! !

!WebInputField methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject size: aNumber
	^self aspect: aSymbol for: anObject; size: aNumber! !

!WebInputField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
hidden
	^self type = 'hidden'! !

!WebInputField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
hidden: aBoolean
	"make this input field hidden one"
	aBoolean ifTrue: [self type: 'hidden']! !

!WebInputField methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	super initialize.
	self type: 'text'.! !

!WebInputField methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isHidden
	^self type = 'hidden'! !

!WebInputField methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isInputField
	^true! !

!WebInputField methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isPassword
	^self type = 'password'! !

!WebInputField methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
maxLength: aNumber
	"maximum number of characters allowed in this input field"
	self attributesAt: #maxlength put: aNumber printString! !

!WebInputField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
password
	^self type = 'password'! !

!WebInputField methodsFor: 'private' stamp: ' 21/4/07 22:07'!
password: aBoolean
	"if true, then value will not be shown in input field"
	self type: 'password'.! !

!WebInputField methodsFor: 'private-streaming' stamp: 'janko 9/19/2011 14:30'!
prepareAttributesToPrintOn: aSession
	super prepareAttributesToPrintOn: aSession.
	self value notNil ifTrue:
		[self attributesAt: #value put: 
			(WebFormElement autoConvertAndEncodeValue: self value)]! !

!WebInputField methodsFor: 'private-streaming'!
prepareAttributesToStreamOn: aSession
	super prepareAttributesToStreamOn: aSession.
	self value isNil ifTrue: [^nil].
	self attributesAt: #value put:  
		(self adaptor format notNil
			ifTrue: [self adaptor convertedAndEncodedValue]
			ifFalse: [WebFormElement autoConvertAndEncodeValue: self adaptor value])! !

!WebInputField methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
resetHidden
	self hidden: false! !

!WebInputField methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
resetPassword
	self password: false! !

!WebInputField methodsFor: 'private' stamp: 'np 10/20/2008 13:29'!
saveThroughAdapterValue: aValueString
	| vlue |
	aValueString isNil ifTrue: [^nil].  "error?"
	vlue :=  AIDASite convertFromWeb: aValueString on: self session. "ensure unicode!!"
	vlue := (WebFormElement autoConvertString:  vlue toObject: self value).
	self value: vlue.! !

!WebInputField methodsFor: 'attributes-types'!
setColor
	self type: 'color'! !

!WebInputField methodsFor: 'attributes-types'!
setDate
	self type: 'date'! !

!WebInputField methodsFor: 'attributes-types'!
setDateTime
	self type: 'datetime'! !

!WebInputField methodsFor: 'attributes-types'!
setEmail
	self type: 'email'! !

!WebInputField methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
setHidden
	self hidden: true! !

!WebInputField methodsFor: 'attributes-types'!
setMonth
	self type: 'month'! !

!WebInputField methodsFor: 'attributes-types'!
setNumber
	self type: 'number'! !

!WebInputField methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
setPassword
	self password: true! !

!WebInputField methodsFor: 'attributes-types'!
setRange
	"HTML slider input field" 
	self type: 'range'! !

!WebInputField methodsFor: 'attributes-types'!
setSearch
	self type: 'search'! !

!WebInputField methodsFor: 'attributes-types'!
setTel
	"phone number"
	self type: 'tel'! !

!WebInputField methodsFor: 'attributes-types'!
setTime
	self type: 'time'! !

!WebInputField methodsFor: 'attributes-types'!
setUrl
	self type: 'url'! !

!WebInputField methodsFor: 'attributes-types'!
setWeek
	self type: 'week'! !

!WebInputField methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebInputField methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
size: aNumber
	"number of characters displayed in this input field"
	self attributesAt: #size put: aNumber printString! !

!WebInputField methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession.
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession.].
	aStream nextPutAll: self ident, '<input'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: self tagClosing.
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebInputField class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
adaptIndex: aNumber ofCollection: aCollection

	^self new aspect: aNumber for: aCollection! !

!WebInputField class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject
	^self new aspect: aSymbol for: anObject! !

!WebInputField class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject size: aNumber
	^self new aspect: aSymbol for: anObject size: aNumber! !

!WebInputField class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
size: aNumber aspect: aSymbol forObject: anObject
	"OBSOLETE!!"
	^self new size: aNumber; aspect: aSymbol for: anObject! !

!WebJSON methodsFor: 'private-parsing'!
consume: aString returning: anObject
	aString do: [:c | self next == c ifFalse: [self error: 'Expected ''', aString, ''''] ].
	^ anObject! !

!WebJSON methodsFor: 'accessing'!
ctorMap
	^ctorMap! !

!WebJSON methodsFor: 'accessing'!
ctorMap: m
	ctorMap := m! !

!WebJSON methodsFor: 'private-parsing' stamp: 'jm 12/15/2010 00:06'!
interpretStringEscape
	| c |
	c := self next.
	c == $b ifTrue: [^ Character backspace].
	c == $n ifTrue: [^ Character lf].
	c == $f ifTrue: [^ Character newPage].
	c == $r ifTrue: [^ Character cr].
	c == $t ifTrue: [^ Character tab].
	^ c.! !

!WebJSON methodsFor: 'private-serializing'!
jsonCollection: aCollection on: aStream
	| needComma |
	needComma := false.
	aStream nextPut: $[.
	aCollection do: [:element |
		needComma
			ifTrue: [ aStream nextPutAll: ', ' ]
			ifFalse: [ needComma := true ].
		self jsonObject: element on: aStream].
	aStream nextPut: $].! !

!WebJSON methodsFor: 'private-serializing'!
jsonDictionary: aDictionary  on: aStream
	| needComma |
	needComma := false.
	aStream nextPut: ${.
	aDictionary keysAndValuesDo: [:key :value |
		needComma
			ifTrue: [ aStream nextPutAll: ', ' ]
			ifFalse: [ needComma := true ].
		self jsonString: key asString on: aStream.
		aStream nextPutAll: ': '.
		self jsonObject: value on: aStream].
	aStream nextPut: $}.! !

!WebJSON methodsFor: 'private-serializing'!
jsonFalseOn: aStream
	aStream nextPutAll: 'false'! !

!WebJSON methodsFor: 'private-serializing'!
jsonNilOn: aStream
	aStream nextPutAll: 'null'! !

!WebJSON methodsFor: 'private-serializing'!
jsonNumber: aNumber on: aWriteStream 
	aWriteStream nextPutAll: aNumber asString.! !

!WebJSON methodsFor: 'private-serializing'!
jsonObject: anObject on: aStream
	(anObject isKindOf: String) ifTrue: [^self jsonString: anObject on: aStream].
	(anObject isKindOf: Number) ifTrue: [^self jsonNumber: anObject on: aStream].
	(anObject isKindOf: Dictionary) ifTrue: [^self jsonDictionary: anObject on: aStream].
	(anObject isKindOf: Collection) ifTrue: [^self jsonCollection: anObject on: aStream].
	anObject isNil ifTrue: [^self jsonNilOn: aStream].
	anObject = true ifTrue: [^self jsonTrueOn: aStream].
	anObject = false ifTrue: [^self jsonFalseOn: aStream].! !

!WebJSON methodsFor: 'private-serializing'!
jsonString: aString on: aStream
	| replacement |
	aStream nextPut: $".
	aString do: [:ch |
		replacement := self class escapeForCharacter: ch.
		replacement
			ifNil: [ aStream nextPut: ch ]
			ifNotNil: [ aStream nextPut: $\; nextPut: replacement ] ].
	aStream nextPut: $".! !

!WebJSON methodsFor: 'private-serializing'!
jsonTrueOn: aStream
	aStream nextPutAll: 'true'! !

!WebJSON methodsFor: 'private-parsing'!
next
	^ self stream next! !

!WebJSON methodsFor: 'private-parsing'!
numberFrom: aString
	"Integer, Float or Double"
	"WebJSON new numberFrom: '14.49156' "
	| nrDecimals clean pos exponent result sign |
	(aString includes: $. ) ifFalse: [^aString asNumber].
	nrDecimals := aString size - (aString indexOf: $. ).
	sign := aString detect: [:ch | ch = $- | ch isDigit].
	sign = $- ifTrue: [sign := -1] ifFalse: [sign := 1].
	clean := aString select: [:ch | ch isDigit | (ch = $. )].
	pos := clean indexOf: $. .
	pos = 0 
		ifTrue: [result := clean asInteger asFloat]
		ifFalse: 
			[exponent := pos - 2.
			clean := clean select: [:ch | ch isDigit].
			result := nrDecimals <= 4 ifTrue: [0.0] ifFalse: [0.0d].
			clean do: [:digit | 
				result := result + ((digit asInteger - $0 asInteger) * (10**exponent)).
				exponent := exponent - 1]].
	^result * sign! !

!WebJSON methodsFor: 'parsing'!
parseAny
	"This is the main entry point for the JSON parser. See also readFrom: on the class side."
	| c |
	self skipWhitespace.
	c := self peek asLowercase.
	c == ${ ifTrue: [self next. ^ self readDictionary].
	c == $[ ifTrue: [self next. ^ self readArray].
	c == $" ifTrue: [self next. ^ self readString].
	c == $t ifTrue: [^ self consume: 'true' returning: true].
	c == $f ifTrue: [^ self consume: 'false' returning: false].
	c == $n ifTrue: [^ self consume: 'null' returning: nil].
	c == $@ ifTrue: [self next. ^ self readConstructor].
	(WebJSON numbersMayContain: c) ifTrue: [^ self readNumber].
	self error: 'Unknown Json input'! !

!WebJSON methodsFor: 'parsing'!
parseFrom: aStream
	self stream: aStream.
	^ self parseAny! !

!WebJSON methodsFor: 'private-parsing'!
peek
	^ self stream peek! !

!WebJSON methodsFor: 'private-parsing'!
readArray
	| a needComma |
	a := OrderedCollection new.
	needComma := false.
	[
		self skipWhitespace.
		self peek == $] ifTrue: [self next. ^ a asArray].
		needComma
			ifTrue: [self peek == $, ifFalse: [ILJsonSyntaxError signal: 'Missing comma'].
					self next.]
			ifFalse: [needComma := true]. 
		a add: self parseAny.
	] repeat.! !

!WebJSON methodsFor: 'private-parsing'!
readConstructor
	| s c v ctor |
	s := WriteStream on: ''.
	[
		c := self peek.
		c ifNil: [ILJsonSyntaxError signal: 'Premature EOF reading constructor name'].
		((c == $.) or: [c isLetter])
			ifTrue: [s nextPut: c. self next]
			ifFalse: [
				v := self parseAny.
				s := s contents.
				ctor := ctorMap ifNotNil: [ctor := ctorMap at: s ifAbsent: [nil]].
				ctor ifNil: [ILJsonSyntaxError signal: 'Unknown ctor ', s].
				^ ctor constructFromJson: v]
	] repeat.! !

!WebJSON methodsFor: 'private-parsing'!
readDictionary
	| m k v needComma |
	m := Dictionary new.
	needComma := false.
	[
		self skipWhitespace.
		self peek == $} ifTrue: [self next. ^ m].
		needComma
			ifTrue: [self peek == $, ifFalse: [ILJsonSyntaxError signal: 'Missing comma'].
					self next. self skipWhitespace]
			ifFalse: [needComma := true.].
		self next == $" ifFalse: [ILJsonSyntaxError signal: 'Key in dictionary must be string'].
		k := self readString.
		self skipWhitespace.
		self peek == $: ifFalse: [ILJsonSyntaxError signal: 'Missing colon'].
		self next.
		v := self parseAny.
		m at: k put: v.
	] repeat.! !

!WebJSON methodsFor: 'private-parsing'!
readNumber
	| str ch |
	str := WriteStream on: String new.
	[
		ch := self peek.
		(ch isNil not and: [self class numbersMayContain: ch]) ifFalse: [
			[^self numberFrom: str contents] on: Error do: [self error: 'Invalid number']].
		str nextPut: ch.
		self next.
	] repeat.! !

!WebJSON methodsFor: 'private-parsing'!
readString
	| str ch |
	str := WriteStream on: String new.
	[
		ch := self next.
		ch == $\
			ifTrue: [str nextPut: self interpretStringEscape.]
			ifFalse: [ch == $" ifTrue: [^ str contents.].
					str nextPut: ch]
	] repeat.! !

!WebJSON methodsFor: 'private-parsing'!
skipComment
	self peek == $/ ifTrue: [
		self next.
		self peek == $/
			ifTrue: [self skipToEndOfLine]
			ifFalse: [self peek == $*
						ifTrue: [self next. self skipCommentBody]
						ifFalse: [ILJsonSyntaxError signal: 'Invalid comment syntax']]]! !

!WebJSON methodsFor: 'private-parsing'!
skipCommentBody
	[
		[self next == $*] whileFalse.
		self peek == $/
	] whileFalse.
	self next. "skip that last slash"
	self skipWhitespace.! !

!WebJSON methodsFor: 'private-parsing'!
skipToEndOfLine
	[self peek == Character cr or: [self peek == Character lf]] whileFalse: [self next].
	self skipWhitespace! !

!WebJSON methodsFor: 'private-parsing'!
skipWhitespace
	[self peek isSeparator] whileTrue: [self next].
	self skipComment.! !

!WebJSON methodsFor: 'accessing'!
stream
	"Answer the value of stream"

	^ stream! !

!WebJSON methodsFor: 'accessing'!
stream: anObject
	"Set the value of stream"

	stream := anObject! !

!WebJSON class methodsFor: 'private'!
characterEscapeMap
	"WebJSON initCharacterEscapeMap"
	CharacterEscapeMap isNil ifTrue: [self initCharacterEscapeMap].
	^CharacterEscapeMap! !

!WebJSON class methodsFor: 'private'!
escapeForCharacter: c
	^ self characterEscapeMap at: c ifAbsent: [nil]! !

!WebJSON class methodsFor: 'private'!
initCharacterEscapeMap
	"WebJSON initCharacterEscapeMap"
	CharacterEscapeMap := Dictionary new
		add: $" -> $";
		add: $\ -> $\;
		add: Character backspace -> $b;
		add: Character lf -> $n;
		add: Character newPage -> $f;
		add: Character cr -> $r;
		add: Character tab -> $t;
		yourself.! !

!WebJSON class methodsFor: 'private'!
mimeType
	^'application/json'! !

!WebJSON class methodsFor: 'private'!
newWithConstructors: aCollection
	| m |
	m := Dictionary new.
	aCollection do: [:each |
		(each isKindOf: Association)
			ifTrue: [m add: each]
			ifFalse: [m at: each name greaseString put: each]].
	^ self new ctorMap: m; yourself.! !

!WebJSON class methodsFor: 'private'!
numbersMayContain: aChar
	^ aChar isDigit or: [#($- $+ $. $e $E) includes: aChar]! !

!WebJSON class methodsFor: 'parsing'!
parse: aString
	^self parseFrom: aString readStream! !

!WebJSON class methodsFor: 'parsing'!
parseFrom: aStream
	^self new parseFrom: aStream! !

!WebJSON class methodsFor: 'serializing'!
stringify: anObject
	| stream |
	stream := WriteStream on: String new.
	self new jsonObject: anObject on: stream.
	^stream contents.! !

!WebJSONPresenter methodsFor: 'accessing'!
aidaContentType
	^'application/json'! !

!WebJSONPresenter methodsFor: 'private' stamp: 'janko 4/25/2012 10:59'!
aidaIsRespondingStreamed
	^false! !

!WebJSONPresenter methodsFor: 'initialize-release'!
initDefaultPresenterBlock
	self presenterBlock: 
		[self observee asJson]! !

!WebJSONPresenter methodsFor: 'accessing'!
observee
	"return reference to an object, for which this app acts as an observer - to make an user interface
	of them"
	^observee! !

!WebJSONPresenter methodsFor: 'private'!
observee: anObject
	"set the reference to an object, for which this app acts as an observer - to make an user interface
	of them"
	observee := anObject! !

!WebJSONPresenter methodsFor: 'accessing'!
presenterBlock
	"this block will be executed in streaming phase. [self observee asJson] is default"
	presenterBlock ifNil: [self initDefaultPresenterBlock].
	^presenterBlock! !

!WebJSONPresenter methodsFor: 'accessing'!
presenterBlock: aBlock
	presenterBlock := aBlock! !

!WebJSONPresenter methodsFor: 'accessing'!
session
	"on which this App represent the observed domain object"
	^session! !

!WebJSONPresenter methodsFor: 'private'!
session: aWebSession
	"on which this App represent the observed domain object"
	session := aWebSession! !

!WebJSONPresenter methodsFor: 'accessing'!
site
	"reference to a site on which this app shows some object. "
	^self session site! !

!WebJSONPresenter methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	"Well, we actually stream JSON!!"
	aStream nextPutAll: 
		self presenterBlock value "by default [self observee asJson] value"! !

!WebJSONPresenter class methodsFor: 'instance creation'!
newFor: anObject on: aSession
	^self new
		observee: anObject;
		session: aSession! !

!WebJSONTest methodsFor: 'support'!
json: aString parseTo: aValue
	"parse string and check if equal to value"
	| parsedValue |
	parsedValue := WebJSON parse: aString.
	self assert: parsedValue = aValue.! !

!WebJSONTest methodsFor: 'support'!
json: aString parseToDict: aValue
	"parse string and check if equal to value"
	| parsedValue |
	parsedValue := WebJSON parse: aString.
	self assert: parsedValue class == Dictionary.
	self assert: parsedValue keys size = aValue keys size.
	parsedValue keysAndValuesDo: [:key :value |
		self assert: (aValue at: key) = value]! !

!WebJSONTest methodsFor: 'support'!
json: aString stringifyFrom: aValue
	"serialize value and check if equal to json string"
	| jsonString |
	jsonString := WebJSON stringify: aValue.
	self assert: jsonString = aString.! !

!WebJSONTest methodsFor: 'support' stamp: 'jm 12/15/2010 00:16'!
json: andArrayOfStrings stringifyFromDict: aValue
	"serialize value and check if equal to one of json strings"
	| jsonString |
	jsonString := WebJSON stringify: aValue.
	self assert: (andArrayOfStrings includes: (jsonString copyWithout: $ ))! !

!WebJSONTest methodsFor: 'testing-parsing'!
testParseArray
	self json: '[]' parseTo: #().
	self json: '[[]]' parseTo: #(#()).
	self json: '[[], []]' parseTo: #(#() #()).
	self json: '["hi", "there"]' parseTo: #('hi' 'there').
	self json: '[["a", "b", null]]' parseTo: #(('a' 'b' nil)).! !

!WebJSONTest methodsFor: 'testing-parsing'!
testParseDictionary
	self json: '{}' parseToDict: (Dictionary new).
	self json: '{"a": "a"}' parseToDict: (Dictionary new at: 'a' put: 'a'; yourself).
	self json: '{"a": [[]]}' parseToDict: (Dictionary new at: 'a' put: #(#()); yourself).
	self json: '{"a":"b", "b":"a"}' parseToDict: (Dictionary new add: 'a'->'b'; add: 'b'->'a'; yourself).! !

!WebJSONTest methodsFor: 'testing-parsing'!
testParseFalse
	self json: 'false' parseTo: false.
	self json: '  false' parseTo: false.
	self json: 'false  ' parseTo: false.
	self json: '  false  ' parseTo: false.! !

!WebJSONTest methodsFor: 'testing-parsing'!
testParseNull
	self json: 'null' parseTo: nil.
	self json: '  null' parseTo: nil.
	self json: 'null  ' parseTo: nil.
	self json: '  null  ' parseTo: nil.! !

!WebJSONTest methodsFor: 'testing-parsing' stamp: 'janko 7/13/2011 22:01'!
testParseNumber
	self json: '1' parseTo: 1.
	self json: '0123' parseTo: 123.
"	self json: '1.23e2' parseTo: 123. "
	self json: '-1' parseTo: -1.
	self json: '-0' parseTo: 0.
"	self json: '[-1.2]' parseTo: #(-1.2). "! !

!WebJSONTest methodsFor: 'testing-parsing'!
testParseString
	self json: '"hi"' parseTo: 'hi'.
	self json: '"\""' parseTo: '"'.
	self json: '"\\"' parseTo: '\'.
	self json: '""' parseTo: ''.! !

!WebJSONTest methodsFor: 'testing-parsing'!
testParseTrue
	self json: 'true' parseTo: true.
	self json: '  true' parseTo: true.
	self json: 'true  ' parseTo: true.
	self json: '  true  ' parseTo: true.! !

!WebJSONTest methodsFor: 'testing-serializing'!
testStringifyArray
	self json: '[]' stringifyFrom: #().
	self json: '[[]]' stringifyFrom: #(#()).
	self json: '[[], []]' stringifyFrom: #(#() #()).
	self json: '["hi", "there"]' stringifyFrom: #('hi' 'there').
	self json: '[["a", "b", null]]' stringifyFrom: #(('a' 'b' nil)).! !

!WebJSONTest methodsFor: 'testing-serializing' stamp: 'jm 12/15/2010 00:17'!
testStringifyDictionary
	self json: '{}' stringifyFrom: (Dictionary new).
	self json: '{"a": "a"}' stringifyFrom: (Dictionary new at: 'a' put: 'a'; yourself).
	self json: '{"a": [[]]}' stringifyFrom: (Dictionary new at: 'a' put: #(#()); yourself).
	self json: #('{"a":"b","b":"a"}' '{"b":"a","a":"b"}') 
		stringifyFromDict: (Dictionary new add: 'a'->'b'; add: 'b'->'a'; yourself).! !

!WebJSONTest methodsFor: 'testing-serializing'!
testStringifyFalse
	self json: 'false' stringifyFrom: false! !

!WebJSONTest methodsFor: 'testing-serializing'!
testStringifyNil
	self json: 'null' stringifyFrom: nil! !

!WebJSONTest methodsFor: 'testing-serializing'!
testStringifyNumber
	self json: '1' stringifyFrom: 1.
	self json: '123' stringifyFrom: 123.
	self json: '-1' stringifyFrom: -1.
	self json: '[-1.2]' stringifyFrom: #(-1.2).! !

!WebJSONTest methodsFor: 'testing-serializing'!
testStringifyString
	self json: '"hi"' stringifyFrom: 'hi'.
	self json: '"\""' stringifyFrom: '"'.
	self json: '"\\"' stringifyFrom: '\'.
	self json: '""' stringifyFrom: ''.! !

!WebJSONTest methodsFor: 'testing-serializing'!
testStringifyTrue
	self json: 'true' stringifyFrom: true! !

!WebLabel methodsFor: 'attributes'!
for: anElementOrId
	"a related element id for which is that label"
	^self attributesAt: #for put: 
		((anElementOrId isKindOf: WebElement)
			ifTrue: [anElementOrId id]
			ifFalse: [anElementOrId])! !

!WebLabel methodsFor: 'private'!
hasTag
	^true! !

!WebLabel methodsFor: 'tags'!
tag
	^#label! !

!WebLabel methodsFor: 'attributes'!
text: aString
	self addText: aString! !

!WebLabel class methodsFor: 'instance creation'!
newFor: aWebElementOrId text: aString
	^super new
		for: aWebElementOrId;
		text: aString! !

!WebLink methodsFor: 'security'!
accessAllowedFor: aSession
	"true if for object of that link a view is allowed. Only for object links, for plain urls access is always 	allowed"
	| app view right |
	self ooReference isNil ifTrue: [^true].
	app := self ooReference aidaWebAppFor: aSession.
	app isNil ifTrue: [^true].     "is this really good?"
	view := (self parms at: 'view' ifAbsent: [app defaultView]) asSymbol.
	right := aSession site securityManager 
		isUser: aSession user allowedTo: (app class viewRightSymbolFor: view) on: app class name.
	(right not and: [aSession adminAllowed]) ifTrue: 
		[app initAdminAccess. ^true].
	^right! !

!WebLink methodsFor: 'accessing'!
accessNotAllowedText
	^#en->'You don''t have enough access rights to click this link'! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
addAnchorTo: anUrlString
	| in out anch | 
	anch := (self anchor includes: $#) ifTrue: [''] ifFalse: ['#']. 
	anch := anch, self anchor.
	in := anUrlString readStream. out := WriteStream on: String new.
"
	out nextPutAll: (in upTo: $? ). out nextPutAll: anch. 
	in atEnd ifFalse: [out nextPut: $? . out nextPutAll: in upToEnd].
"
	out nextPutAll: in upToEnd. out nextPutAll: anch.
	^out contents

"(WebLink new anchor: 'activity222') addAnchorTo:	
	'http://biart.eranova.si/object/o7665965.html?view=editActivityName&uuid=1518'
"! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
addSessionIdTo: aString on: aSession
	"for connection of secure seesion to nonsecure one"
	| url |
	aSession hasSecureCookie ifTrue: [^aString].
	url := (aString includes: $? ) ifTrue: [aString, '&'] ifFalse: [aString, '?'].
	^url, 'sessionId=', aSession id printString.! !

!WebLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
anchor

	^anchor! !

!WebLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
anchor: aString

	anchor := aString! !

!WebLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
anchorNr: aNumber

	"set hypertext link anchor in the same page in format '#anchorx', for example '#anchor4'. Use WebAnchor nr: method to add an anchor in a web page."

	^self anchor: '#anchor', aNumber printString.! !

!WebLink methodsFor: 'private'!
asWebText
	"return just a text part (with formating) of this link"
	| wtext |
	wtext := WebText new.
	wtext 
		basicText: self text copy;
		textAttributes: self textAttributes copy.
	self header notNil ifTrue: [wtext header: self header].
	self size notNil ifTrue: [wtext size: self size].
	self paragraph notNil ifTrue: [wtext paragraph: self paragraph].
	self elements do: [:each | wtext add: each].
	^wtext! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checkVersionedReference
	"if ooReference is not a current version, then point it to current and add 
	version parameter to url. Version objects have always same identity, that
	is those of current object in version chain!! "
	self ooReference isCurrentVersion ifTrue: [^self].
	self parameter: 'version' value: self ooReference versionNumber.
	ooReference := self ooReference currentVersion.! !

!WebLink methodsFor: 'private'!
composeURLOn: aSession
	"do url link only if ooReference or urlReference exists, return nil otherwise"
	| stream url |
	stream := WriteStream on: String new.
	(self ooReference notNil or: [self urlReference notNil] ) ifFalse: [^nil].
	"copy parameters to aSession parms, remove all other except session id"
	parms keysAndValuesDo: [:key :value | aSession parms at: key put: value].
	aSession parms copy keysAndValuesDo: [:key :value | 
		((parms includesKey: key) or: [key = 'id']) 
			ifFalse: [aSession parms removeKey: key ifAbsent: [nil]] ].
	"make an url reference"
	self ooReference notNil
		ifTrue:	
			[url := (aSession site urlResolver
				halfUrlFromPath:	(aSession site urlResolver halfUrlFor: self ooReference)
				andParms: aSession parms on: aSession).
			(self isEncryptedViewFor: self ooReference on: aSession) 
				ifTrue: [url := self encryptedUrl: url on: aSession] ]
		ifFalse: [url := self urlReference].
	anchor notNil ifTrue: [url := self addAnchorTo: url].
	stream nextPutAll: url.
	^self properAmpersand: stream contents " &amp; instead of mere & in XHTML!! "! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
encryptedUrl: aString on: aSession
	"https and port if not default"
	| url port sslPort stream |
	url := aSession site urlResolver urlFromHalfUrl: aString on: aSession.
	('https*' match: url) ifFalse: [url := url copyReplaceAll: 'http' with: 'https'].
	port := aSession site port.
	sslPort := aSession site sslPort.
	port = 80 & sslPort = 443 ifTrue: [^url].
	stream := url readStream.
	url := (stream upTo: $/ ), '//'.
	stream upTo: $/.
	url := url, (port = 80 ifTrue: [stream upTo: $/] ifFalse: [stream upTo: $: ]).
	port  ~= 80 ifTrue: [stream upTo: $/].
	sslPort ~= 443 ifTrue: [url := url, ':', sslPort printString].
	url := url, '/', stream upToEnd.
	aSession hasSecureCookie ifFalse: [url := self addSessionIdTo: url on: aSession].
	^url! !

!WebLink methodsFor: 'private'!
hasTag
	^false  "well .."! !

!WebLink methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
href: aString
	"url of that link"
	self attributesAt: #href put: aString! !

!WebLink methodsFor: 'initialize-release'!
initialize
	parms := Dictionary new.
	self security: #grayed.  "if access not allowed, only gray text is shown"! !

!WebLink methodsFor: 'private' stamp: 'jm 8/3/2010 10:23'!
isEncryptedViewFor: anObject on: aSession
	"check if we need to make an https link"
	| app view |
	app := anObject aidaWebAppFor: aSession.
	app isNil ifTrue: [^false].
	view := self parms at: 'view' ifAbsent: [app class defaultView].
	^app mustBeEncrypted: view! !

!WebLink methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isLink
	^true! !

!WebLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
linkTo: aLink
	"set hypertext link to some other object or page. If argumet is a String, then this is an url reference, 	else this is object reference, which is resolved to url with help of URLResolver"
	"to add anchor: #(object anchor) !! "
	(aLink isKindOf: String ) ifTrue: [self urlReference: aLink. ^self].
	(aLink isKindOf: Array)
		ifTrue: [self ooReference: (aLink at: 1). self anchor: (aLink at: 2)]
		ifFalse: [self ooReference: aLink].! !

!WebLink methodsFor: 'events' stamp: ' 21/4/07 22:07'!
onBlur: aJavascriptCode
	"link lost a mouse focus (when in image map)"
	self attributesAt: #onBlur add: aJavascriptCode! !

!WebLink methodsFor: 'events' stamp: ' 21/4/07 22:07'!
onFocus: aJavascriptCode
	"link got maouse focus (when in image map)"
	self attributesAt: #onFocus add: aJavascriptCode! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
ooReference
	^ooReference! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
ooReference: anObject
	"Set the hypertext link to other object. This reference is at HTML generation 
	resolved to urlReference by URLResolver.  ooReference has precedence over 
	urlReference, if both are set."
	ooReference := anObject.
	anObject isVersionedObject ifTrue: [self checkVersionedReference]! !

!WebLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
parameter: aParmString value: aValueString

	"set an optional parameter for query part of an URL string (e.g in http://www.eranova.si/demo.html?view=brief 'view' is a parameter and 'brief' is its value).
You can set more than one parameters by repeating this method"

	self parms at: aParmString asString put: aValueString asString.! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
parms
	"return a dictionary of parameter:value pairs for a query part of an URL"
	^parms! !

!WebLink methodsFor: 'private-streaming'!
prepareAttributesToStreamOn: aSession
	super prepareAttributesToStreamOn: aSession.
	self href: (self composeURLOn: aSession).! !

!WebLink methodsFor: 'translation'!
prepareForTranslation
	"if link with multilingual text, replace it with in-place input field and add a 'link' with link on right"
	| copied onlyText |
	self isMultilingual ifFalse: [^nil].
	copied := self copy.
	super prepareForTranslation. "of WebText part of link"
	onlyText := self asWebText.  "to avoid to be link anymore"
	copied text:  '<small>link</small>'.
	onlyText addTextSmall: ' ('; add: copied; addTextSmall: ')'.
	self parent replace: self with: onlyText.! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
printString
	^'aWebLink to: ', (self ooReference notNil 
		ifTrue: ['a', self ooReference printString] ifFalse: [self urlReference]).! !

!WebLink methodsFor: 'private'!
properAmpersand: aString
	" &amp; instead of mere & in XHTML!! "
	| page |
	page := self webPage.
	(page isNil or: [page isXHTML]) ifFalse: [^aString].
	^aString copyReplaceAll: '&' with: '&amp;'! !

!WebLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
security
	"you can gray or not show a link at all if this object is not accessible - a view 
	on that aWebApplication has no access rights in SecurityManager for current user.
	possible values:
	nil - no access restrictions, always show the link,
	#grayed - show only text in gray - no link if access denied
	#invisible - don't show anything - invisible link if access denied
	"

	^security! !

!WebLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
security: aSymbol

	security := aSymbol! !

!WebLink methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	| url allowed |
	self prepareToHtmlStreamingOn: aSession. 
	allowed := self security notNil ifTrue: [self accessAllowedFor: aSession] ifFalse: [true].
	allowed 	ifTrue: 
		[url := self composeURLOn: aSession.
		url notNil ifTrue:
			[aStream nextPutAll: self ident, '<a'. self streamAttributesTo: aStream for: aSession. 
			aStream nextPutAll: '>'.
			super streamHtmlTo: aStream for: aRequest on: aSession.
			aStream nextPutAll: '</a>'] ]
		ifFalse: [self security = #grayed ifTrue: 
			["print a grayed text with attributes and composite elements"
			self title: self accessNotAllowedText.
			aStream nextPutAll: self ident, '<font'. self streamAttributesTo: aStream for: aSession. 
			aStream nextPutAll: 'color="#c0c0c0">'.
			super streamHtmlTo: aStream for: aRequest on: aSession.
			aStream nextPutAll: '</font>', self  eol ] ].! !

!WebLink methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
target: aString
	self attributesAt: #target put: aString! !

!WebLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
text: aString linkTo: aLink
	self linkTo: aLink.
	self text: aString.! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
urlReference
	^urlReference! !

!WebLink methodsFor: 'private' stamp: ' 21/4/07 22:07'!
urlReference: aString
	"Set the URL hypertext link to the other Web page.  It is used if there is no ooReference 
	to resolve. ooReference has precedence over urlReference when both are set."
	urlReference := aString.! !

!WebLink methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
view: aViewStringOrSymbol
	"for speedy additions of a view parameters to urls"
	"ignore #main, because this is default view anyway!!"
	((aViewStringOrSymbol = 'main') | (aViewStringOrSymbol = #main)) ifTrue: [^self].
	self parameter: 'view' value: aViewStringOrSymbol! !

!WebLink class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
linkTo: aLink
	"set hypertext link to some other object or page. If argumet is a String, then this is an url reference, 	else this is object reference, which is resolved to url with help of URLResolver"
	"to add anchor: #(object anchor) !! "
	^self new linkTo: aLink! !

!WebLink class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebLink class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
text: aString attributes: anArray linkTo: aLink

	"set hypertext link and text to some other object or page. If argumet is a String, then this is an url reference, else this is object reference, which is resolved to url with help of URLResolver"
	| webLink |
	webLink := self linkTo: aLink.
	webLink text: aString attributes: anArray.
	^webLink

"WebLink text: 'text' linkTo: 'http://www.tris-a.si'"
"WebLink text: 'text' linkTo: Smalltalk"! !

!WebLink class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
text: aString linkTo: aLink

	"set hypertext link and text to some other object or page. If argumet is a String, then this is an url reference, else this is object reference, which is resolved to url with help of URLResolver"
	| webLink |
	webLink := self linkTo: aLink.
	webLink text: aString.
	^webLink

"WebLink text: 'text' linkTo: 'http://www.tris-a.si'"
"WebLink text: 'text' linkTo: Smalltalk"! !

!WebLink class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
text: aString linkTo: aLink parameter: aParmString value: aValueString
	"set hypertext link and text to some other object or page. If argumet is a String, then this is an url reference, else this is object reference, which is resolved to url with help of URLResolver. Add also one  parameter in query part of an URL"
	| webLink |
	webLink := self text: aString linkTo: aLink.
	webLink parameter: aParmString value: aValueString.
	^webLink

"WebLink text: 'text' linkTo: 'http://www.tris-a.si'"
"WebLink text: 'text' linkTo: Smalltalk"! !

!WebLink class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
text: aString linkTo: aLink 
	parameter: a1ParmString value: a1ValueString 
	parameter: a2ParmString value: a2ValueString
	"set hypertext link and text to some other object or page. If argumet is a String, then this is an url reference, else this is object reference, which is resolved to url with help of URLResolver. Add also one  parameter in query part of an URL"
	| webLink |
	webLink := self text: aString linkTo: aLink.
	webLink parameter: a1ParmString value: a1ValueString.
	webLink parameter: a2ParmString value: a2ValueString.
	^webLink! !

!WebLink class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
text: aString linkTo: aLink view: aViewString
	^(self text: aString linkTo: aLink) view: aViewString! !

!WebList methodsFor: 'adding/removing' stamp: ' 21/4/07 22:07'!
add: anElement
	"ensure always WebListItem as subelement of list"
	| element |
	element := (anElement class == WebListItem)
		ifTrue: [anElement] 
		ifFalse: [WebListItem newListItem add: anElement; yourself].
	^super add: element! !

!WebList methodsFor: 'adding/removing' stamp: ' 21/4/07 22:07'!
addDefinition: anElement
	"ensure always WebListItem as subelement of list"
	| element |
	element := (anElement class == WebListItem)
		ifTrue: [anElement setDefinition] 
		ifFalse: [WebListItem newDefinition add: anElement; yourself].
	^super add: element! !

!WebList methodsFor: 'adding/removing' stamp: ' 21/4/07 22:07'!
addDefinitionTerm: anElement
	"ensure always WebListItem as subelement of list"
	| element |
	element := (anElement class == WebListItem)
		ifTrue: [anElement setDefinitionTerm] 
		ifFalse: [WebListItem newDefinitionTerm add: anElement; yourself].
	^super add: element! !

!WebList methodsFor: 'adding/removing'!
addLinkTo: anObject text: aString 
	"add new line to the list with text and link to some object. Return link, not line!!" 
	| line link |
	line := WebListItem new.
	link := line addLinkTo: anObject text: aString.
	self add: line.
	^link! !

!WebList methodsFor: 'adding/removing'!
addText: aString
	"make a new element with aString. Attributes are same as previous text. Return text, not list item!!" 
	| line text |
	line := WebListItem new.
	text := line addText: aString.
	self  add: line.
	^text! !

!WebList methodsFor: 'accessing'!
definition
 	self kind: #definition! !

!WebList methodsFor: 'private'!
hasTag
	^false "well.."! !

!WebList methodsFor: 'initialize-release'!
initialize
	self unordered! !

!WebList methodsFor: 'accessing'!
kind
	"should be #ordered, #unordered, #definition"
	^kind! !

!WebList methodsFor: 'private'!
kind: aSymbol
	"should be #ordered, #unordered, #definition. By default is #unordered"
	kind := aSymbol.! !

!WebList methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
name
	^name! !

!WebList methodsFor: 'accessing'!
name:  aString
	"set the name of this list. Used for accessing the selections from WebForm or WebApplication"
	name := aString.! !

!WebList methodsFor: 'accessing'!
ordered
 	self kind: #ordered! !

!WebList methodsFor: 'private'!
shouldIdent
	^true! !

!WebList methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	| tag |
	self prepareToHtmlStreamingOn: aSession. 
	self kind == #ordered ifTrue: [tag := 'ol'].
	self kind == #unordered ifTrue: [tag := 'ul'].
	self kind == #definition ifTrue: [tag := 'dl'].
	aStream nextPutAll: self ident, '<', tag.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '>', self eol.
	super streamHtmlTo: aStream for: aRequest on: aSession.
	aStream nextPutAll: self ident, '</', tag, '>', self eol.! !

!WebList methodsFor: 'accessing'!
unordered
 	self kind: #unordered! !

!WebList class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
kind: aSymbol
	"should be #ordered, #unordered, #definition"

	^self new initialize kind: aSymbol! !

!WebList class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebList class methodsFor: 'instance creation'!
newDefinition
	^self new definition! !

!WebList class methodsFor: 'instance creation'!
newOrdered
	^self new ordered! !

!WebList class methodsFor: 'instance creation'!
newUnordered
	^self new unordered! !

!WebListItem methodsFor: 'private'!
hasTag
	^false "otherwise duplicate tags!!"! !

!WebListItem methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	self setListItem! !

!WebListItem methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setDefinition
	self tag: 'dd'! !

!WebListItem methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setDefinitionTerm
	self tag: 'dt'! !

!WebListItem methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setListItem
	self tag: 'li'! !

!WebListItem methodsFor: 'private'!
shouldIdent
	^true! !

!WebListItem methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession. 
	aStream nextPutAll: self ident, '<', self tag.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '>'.
	super streamHtmlTo: aStream for: aRequest on: aSession.
	aStream nextPutAll: '</', self tag, '>', self eol.! !

!WebListItem methodsFor: 'accessing'!
tag
	tag isNil ifTrue: [self setListItem].
	^tag! !

!WebListItem methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
tag: aString
	tag := aString! !

!WebListItem class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebListItem class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newDefinition
	^self new setDefinition "dd"! !

!WebListItem class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newDefinitionTerm
	^self new setDefinitionTerm "dt"! !

!WebListItem class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newListItem
	^self new setListItem "li"! !

!WebLiveImage methodsFor: 'private-caching' stamp: ' 21/4/07 22:07'!
addToCache
	self makeRoomInCache.
	self class cache add: self.! !

!WebLiveImage methodsFor: 'private' stamp: 'jm 7/29/2010 12:16'!
aidaContentType
	"MIME type for our image"
	^'image/gif'! !

!WebLiveImage methodsFor: 'as yet unclassified' stamp: 'janko 4/25/2012 10:59'!
aidaIsRespondingStreamed
	"is this page able to stream HTML directly into response?"
	^false! !

!WebLiveImage methodsFor: 'private-streaming'!
aidaPresenterFor: aRequest on: aSession 
	^self! !

!WebLiveImage methodsFor: 'private-caching' stamp: ' 21/4/07 22:07'!
cacheHysteresis
	"when removing from cache, make room for that number of entries"
	^10! !

!WebLiveImage methodsFor: 'drawing' stamp: ' 21/4/07 22:07'!
displayOn: aGraphicsContext

	"default painting - some hello message. Subclasses should override for some more paintings"

	| composite text |
	composite := CompositePart new.
	text := 'This is a live GIF image' asText.
	text emphasizeAllWith: (Array with: #bold with: #color -> ColorValue blue).
	text := text asComposedText.
	composite add: text at: 100 @ (height/2).
	composite displayOn: aGraphicsContext.! !

!WebLiveImage methodsFor: 'drawing' stamp: ' 21/4/07 22:07'!
drawImage
	"it paints a drawing with a painter and convert it to GIF"
	| pixmap graphicsContext image stream |
	pixmap := Pixmap extent: self width @ self height.
	graphicsContext := pixmap graphicsContext.
	self painter displayOn: graphicsContext.
	image := pixmap asImage.
	stream := GifImageStream on: ByteArray new writeStream.
	[stream nextPutImage: image. self gif: stream contents] 
		valueNowOrOnUnwindDo: [stream close].! !

!WebLiveImage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
gif
	"returns a representation of a image in GIF format"
	^gif! !

!WebLiveImage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
gif: aByteArray

	"also set a refreshed timestamp"

	gif := aByteArray.
	self refreshed: Timestamp now.! !

!WebLiveImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
height
	"height of image, default is 300 pixels"
	height isNil ifTrue: [self height: 300].
	^height! !

!WebLiveImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
height: anInteger
	height := anInteger.! !

!WebLiveImage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
isComposite
	^false! !

!WebLiveImage methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebElement
	^false! !

!WebLiveImage methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebPage
	^true! !

!WebLiveImage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
lastUsed
	"timestamp of last usage. Used for caching algorithms. Set at HTML generation"

	lastUsed isNil ifTrue: [self lastUsed: Timestamp now].
	^lastUsed! !

!WebLiveImage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
lastUsed: aTimestamp
	"timestamp of last usage. Used for caching algorithms"

	lastUsed := aTimestamp! !

!WebLiveImage methodsFor: 'private-caching' stamp: ' 21/4/07 22:07'!
makeRoomInCache
	"if cache is full, remove least used images"
	| cached  toRemove |
	self class cache size < self maxCacheSize ifTrue: [^self].
	cached := (SortedCollection 
		withAll: self class cache
		sortBlock: [:a :b | a lastUsed < b lastUsed]) asOrderedCollection.
	self cacheHysteresis timesRepeat:
		[toRemove := cached first.
		toRemove removeFromCache.
		cached removeFirst]! !

!WebLiveImage methodsFor: 'private-caching' stamp: ' 21/4/07 22:07'!
maxCacheSize
	^50! !

!WebLiveImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
painter
	"painter is an object, which actually paints an image. It must respond to message displayOn: anGraphicsContect. By default, painter is self and paints some hello message. Subclasses should override displayOn: appropriately"

	painter isNil ifTrue: [self painter: self].
	^painter! !

!WebLiveImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
painter: anObject
	painter := anObject.! !

!WebLiveImage methodsFor: 'private'!
preferredUrl
	| random |
	random := (AIDASite random next * 10000) truncated printString.
	^'/image/live-', random, '.gif'! !

!WebLiveImage methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
refreshNeeded
	^self gif isNil! !

!WebLiveImage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
refreshed
	"timestamp of last gif creation. Used for caching algorithms. Set,when calling gif: method"

	refreshed isNil ifTrue: [self refreshed: Timestamp now].
	^refreshed! !

!WebLiveImage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
refreshed: aTimestamp
	"timestamp of last gif creation. Used for caching algorithms"

	refreshed := aTimestamp! !

!WebLiveImage methodsFor: 'private-caching' stamp: ' 21/4/07 22:07'!
removeFromCache
	self class cache remove: self ifAbsent: [].
	self removeFromURLResolver.
	self gif: nil.! !

!WebLiveImage methodsFor: 'private-caching' stamp: ' 21/4/07 22:07'!
removeFromURLResolver
	self resolver notNil
		ifTrue: [self resolver removeObject: self]! !

!WebLiveImage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
resolver
	^resolver! !

!WebLiveImage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
resolver: anObject
	resolver := anObject! !

!WebLiveImage methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	"refresh gif if nesessary and put it into a HTML stream"
	Processor activeProcess priority: (Processor activeProcess priority - 3).
	self refreshNeeded ifTrue: 
		[self drawImage.
		self addToCache].
	aStream nextPutAll: self gif asByteString.
	Processor activeProcess priority: (Processor activeProcess priority + 3).
	self lastUsed: Timestamp now.

"	aSession server urlResolver removeObject: self "! !

!WebLiveImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
width
	"width of image, default is 500 pixels"
	width isNil ifTrue: [self width: 500].
	^width! !

!WebLiveImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
width: anInteger
	width := anInteger.! !

!WebLiveImage class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
cache
	Cache isNil ifTrue: [self initCache].
	^Cache! !

!WebLiveImage class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
initCache
	Cache := Set new.! !

!WebLivePDFCreator methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
aidaDontCache
	"refresh content always!! "
	^true! !

!WebLivePDFCreator methodsFor: 'converting' stamp: 'np 10/18/2008 13:15'!
convertToPdf: aHtmlString
	| fname pdfname stream |
	fname := (AIDASite random new next * 1000) truncated printString, '.html'.
	pdfname := (AIDASite random new next * 1000) truncated printString, '.pdf'.
	[stream := (SpFilename named: fname) writeStream. stream nextPutAll: aHtmlString] 
		ensure: [stream close].
	OSProcess exec: 'htmldoc --batch htmldoc.book --outfile ', pdfname, ' ', fname.
	(SpFilename named: fname) delete.
	[stream := (SpFilename named: pdfname) readStream binary. ^stream contents] 
		ensure: [stream close. (SpFilename named: pdfname) delete].! !

!WebLivePDFCreator methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
expiresTimestamp
	^nil! !

!WebLivePDFCreator methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	| html pdf |
	html := AIDASite convert: (self object perform: self method) toCodepage: #'iso-8859-2'.
	pdf := self convertToPdf: html.
	aStream nextPutAll:  pdf asByteString.! !

!WebLivePDFCreator class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
fromHtmlMethod: aMethodSymbol on: anObject site: anAIDASite
	"this method should return a complete html page!! "
	| docname |
	docname := (anObject class canUnderstand: #preferedUrlName) 
		ifTrue: [anObject preferedUrlName] ifFalse: ['live'].
	^self fromMethod: aMethodSymbol on: anObject 
		contentType: 'application/pdf' preferedUrl: '/generated/', docname, '.pdf' site: anAIDASite! !

!WebMenu methodsFor: 'model adapting'!
acceptFormInputFrom: aPostDataArray
	| values |
	values := aPostDataArray class == Dictionary
		ifTrue:  [Set new add: (aPostDataArray at: self name); yourself]
		ifFalse: [(aPostDataArray allAt: self name) asSet].
	self acceptInputFromValues: values! !

!WebMenu methodsFor: 'private'!
acceptInputFromValue: aString
	self acceptInputFromValues: (Array with: aString)! !

!WebMenu methodsFor: 'model adapting'!
acceptInputFromValues: aCollection
	| option result values |
	self selected isNil ifTrue: [self selected: OrderedCollection new]. "we need a collection!! "
	self selected copy do: [:each | self selected remove: each].
	values := aCollection collect: [:each | AIDASite convert: each fromCodepage: #'UTF-8'].
	self selected addAll: 
		(self collection select:  [:each |
			option := self aspect isNil ifTrue: [each] ifFalse: [each perform: self aspect].
			option := option trimBlanks. "it should also eliminate more than one spaces together!!"
			values contains: [:value | value match: option] ] ).
	self aspectToStore notNil ifTrue: 
		[result := self selected notEmpty ifTrue: [self selected asOrderedCollection first] ifFalse: [nil].
		self adaptorToStore value: result]! !

!WebMenu methodsFor: 'accessing'!
adaptorToStore
	"an aspect - name of a method to call on object, to write down a result from selection"
	^adaptorToStore! !

!WebMenu methodsFor: 'private'!
adaptorToStore: anAIDAAspectAdaptor
	"an aspect - name of a method to call on object, to write down a result from selection"
	adaptorToStore := anAIDAAspectAdaptor! !

!WebMenu methodsFor: 'model adapting'!
aspect: aSymbol collection: aCollection selected: aSelectedCollection
	self adaptor: ((AidaModelAdaptor forAspect: aSymbol) subject: aCollection).
	self selected: aSelectedCollection.
	self setMultiple.
	self size: 4.! !

!WebMenu methodsFor: 'model adapting'!
aspect: aSymbol collection: aCollection selectedToAspect: aSymbol2 of: anObject
	self multiple: false.
	self adaptor: ((AidaModelAdaptor forAspect: aSymbol) subject: aCollection).
	self adaptorToStore: ((AidaModelAdaptor forAspect: aSymbol2) subject: anObject).! !

!WebMenu methodsFor: 'accessing'!
aspectToStore
	^self adaptorToStore notNil
		ifTrue: [self adaptorToStore aspect]
		ifFalse: [nil]! !

!WebMenu methodsFor: 'accessing'!
collection
	^self object "in adaptor"! !

!WebMenu methodsFor: 'model adapting'!
collection: aCollection selected: aSelectedCollection
	self adaptor: (AidaModelAdaptor new subject: aCollection). "just to hold our collection"
	self selected: aSelectedCollection.
	self setMultiple.
	self size: 4.! !

!WebMenu methodsFor: 'model adapting'!
collection: aCollection selectedToAspect: aSymbol of: anObject
	self multiple: false.
	self adaptor: (AidaModelAdaptor new subject: aCollection). "just to hold our collection"
	self adaptorToStore: ((AidaModelAdaptor forAspect: aSymbol) subject: anObject).! !

!WebMenu methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	super initialize.
	self resetMultiple.! !

!WebMenu methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isEmpty
	"input field is empty or nil"
	| vlue |
	self objectToStore notNil ifTrue: [vlue := self objectToStore perform: self aspectToStore].
	^vlue isNil 
		or: [((vlue isKindOf: String) and: [vlue isEmpty])
			or: [(vlue isKindOf: Number) and: [vlue = 0] ]]! !

!WebMenu methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isMenu
	^true! !

!WebMenu methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isMultiple
	"multiple selection?"
	^self multiple! !

!WebMenu methodsFor: 'validation'!
isValid
	self adaptorToStore isNil ifTrue: [^true].
	^self adaptorToStore isValid! !

!WebMenu methodsFor: 'private' stamp: ' 21/4/07 22:07'!
joinToForm: aWebForm
	aWebForm fields keysAndValuesDo: [:fname :element | 
		element == self ifTrue: [self name: fname]. ^self]! !

!WebMenu methodsFor: 'private' stamp: ' 21/4/07 22:07'!
multiple
	^multiple! !

!WebMenu methodsFor: 'private' stamp: ' 21/4/07 22:07'!
multiple: aBoolean
	multiple := aBoolean! !

!WebMenu methodsFor: 'accessing'!
objectToStore
	^self adaptorToStore notNil
		ifTrue: [self adaptorToStore subject]
		ifFalse: [nil]! !

!WebMenu methodsFor: 'private-streaming'!
prepareSelected
	"add aspect of objectToStore selected result. There a preselection can reside"
	self aspectToStore isNil ifTrue: [^nil]. "multiple selections used, selected already set"
	self selected: (Set with: self adaptorToStore value)! !

!WebMenu methodsFor: 'private-streaming' stamp: 'mivsek 1/10/2008 22:25'!
printOptionsOn: aStream
	| option preselected session |
	self collection isEmpty ifTrue: [^nil].
	self prepareSelected.
	preselected := self selected notNil ifTrue: [self selected asSet] ifFalse: [#()].
	aStream nextPutAll: '<option></option>'. "empty choice"
	session := self firstSessionFromStack.
	self collection do: [:each |
		option := self aspect isNil ifTrue: [each] ifFalse: [each perform: self aspect]. 
		option := AIDASite convertToWeb: option on: session.
		aStream nextPutAll: '<option'.
		aStream nextPutAll: ((preselected includes: each) ifTrue: [' selected>'] ifFalse: ['>']).
 		aStream nextPutAll: option; nextPutAll: '</option> ' ]! !

!WebMenu methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
resetMultiple
	self multiple: false! !

!WebMenu methodsFor: 'model adapting'!
save
	^self adaptorToStore notNil ifTrue: [self adaptorToStore save]! !

!WebMenu methodsFor: 'accessing'!
selected
	"selected options wiil be stored here"
	^selected! !

!WebMenu methodsFor: 'private' stamp: ' 21/4/07 22:07'!
selected: aCollection
	selected := aCollection! !

!WebMenu methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setMultiple
	self multiple: true! !

!WebMenu methodsFor: 'private' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebMenu methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
size: aRowNumber
	"number of rows visible in multiple selection menu"
	self attributesAt: #size put: aRowNumber printString! !

!WebMenu methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession.
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	aStream nextPutAll: self ident, '<select'.
	self streamAttributesTo: aStream for: aSession.
	self isMultiple ifTrue: [aStream nextPutAll: ' multiple'].
	aStream nextPutAll: '>'.
	self streamOptionsTo: aStream.
	aStream nextPutAll: '</select>'.
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebMenu methodsFor: 'private-streaming'!
streamOptionsTo: aStream
	| option preselected session |
	self collection isEmpty ifTrue: [^nil].
	self prepareSelected.
	preselected := self selected notNil ifTrue: [self selected asSet] ifFalse: [#()].
	aStream nextPutAll: '<option></option>'. "empty choice"
	session := self firstSessionFromStack.
	self collection do: [:each |
		option := self aspect isNil ifTrue: [each] ifFalse: [each perform: self aspect]. 
		option := AIDASite convertToWeb: option on: session.
		aStream nextPutAll: '<option'.
		aStream nextPutAll: ((preselected includes: each) ifTrue: [' selected>'] ifFalse: ['>']).
 		aStream nextPutAll: option; nextPutAll: '</option> ' ]! !

!WebMenu class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol collection: aCollection selected: aSelectedCollection
	"Multiple selection menu. Aspect of every element in aColection will be shown in menu. 
	Multiple selections will be put in aSelectedCollection. Here also initial selections can be set"
	^self new aspect: aSymbol collection: aCollection selected: aSelectedCollection! !

!WebMenu class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol collection: aCollection selectedToAspect: aSymbol2 of: anObject
	"Single selection menu.. Aspect of every element in aColection will be shown in menu. 
	Single selection will be put in an seelcted aspect of object. Here also initial selection can be set"
	^self new aspect: aSymbol collection: aCollection  selectedToAspect: aSymbol2 of: anObject! !

!WebMenu class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
collection: aCollection selected: aSelectedCollection
	"Multiple selection menu.Every element (text!!) in aColection will be shown in menu. 
	Multiple selection will be put in aSelectedCollection. Here also initial selections can be set"
	^self new collection: aCollection selected: aSelectedCollection! !

!WebMenu class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
collection: aCollection selectedToAspect: aSymbol2 of: anObject
	"Single selection menu.. Every element (text!!) in aColection will be shown in menu. 
	Single selection will be put in an seelcted aspect of object. Here also initial selection can be set"
	^self new collection: aCollection selectedToAspect: aSymbol2 of: anObject! !

!WebMethodImage methodsFor: 'caching' stamp: ' 21/4/07 22:07'!
addToCache
	self makeRoomInCache.
	self class cache add: self.! !

!WebMethodImage methodsFor: 'caching' stamp: ' 21/4/07 22:07'!
cacheHysteresis
	"when removing from cache, make room for that number of entries"
	^10! !

!WebMethodImage methodsFor: 'accessing' stamp: 'JM 4/26/2007 17:48'!
lastUsed
	"timestamp of last usage. Used for caching algorithms. Set at HTML generation"

	lastUsed isNil ifTrue: [self lastUsed: SpTimestamp now].
	^lastUsed! !

!WebMethodImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
lastUsed: aTimestamp
	"timestamp of last usage. Used for caching algorithms"

	lastUsed := aTimestamp! !

!WebMethodImage methodsFor: 'caching' stamp: ' 21/4/07 22:07'!
makeRoomInCache
	"if cache is full, remove least used images"
	| cached  toRemove |
	self class cache size < self maxCacheSize ifTrue: [^self].
	cached := (SortedCollection 
		withAll: self class cache
		sortBlock: [:a :b | a lastUsed < b lastUsed]) asOrderedCollection.
	self cacheHysteresis timesRepeat:
		[toRemove := cached first.
		toRemove removeFromCache.
		cached removeFirst]! !

!WebMethodImage methodsFor: 'caching' stamp: ' 21/4/07 22:07'!
maxCacheSize
	^50! !

!WebMethodImage methodsFor: 'accessing'!
preferredUrl
	| ext |
	ext := self site mimeMap extensionForType: self aidaContentType.
	ext isNil ifTrue: [ext := ''].
	^'/img/' , self method asString asLowercase , ext! !

!WebMethodImage methodsFor: 'private'!
printString
	^'WebMethodImage #', self method asString, ' on ', self object class name! !

!WebMethodImage methodsFor: 'caching' stamp: ' 21/4/07 22:07'!
removeFromCache
	self class cache remove: self ifAbsent: [].
	self removeFromURLResolver.! !

!WebMethodImage methodsFor: 'caching' stamp: ' 21/4/07 22:07'!
removeFromURLResolver
	self resolver notNil
		ifTrue: [self resolver removeObject: self]! !

!WebMethodImage methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
resolver
	^self site urlResolver! !

!WebMethodImage class methodsFor: 'caching' stamp: 'rob.rothwell 3/2/2009 22:00'!
cache
	cache isNil ifTrue: [self initCache].
	^cache! !

!WebMethodImage class methodsFor: 'instance creation'!
fromMethod: aSymbol on: anObject contentType: aString site: anAIDASite
	"cached one only preservers its url, but method is still called everytime image is shown!!"
	| cached | 
	cached := self imageForObject: anObject andMethod: aSymbol.
	^cached notNil 
		ifTrue: [cached] 
		ifFalse: [super new
			object: anObject;
			method: aSymbol;
			aidaContentType: aString;
			site: anAIDASite;
			addToCache]! !

!WebMethodImage class methodsFor: 'caching' stamp: ' 21/4/07 22:07'!
imageForObject: anObject andMethod: aSymbol

	^self cache detect: [:each | each object == anObject and: [each method = aSymbol] ] ifNone: [nil]! !

!WebMethodImage class methodsFor: 'caching' stamp: 'rob.rothwell 3/2/2009 22:00'!
initCache
	cache := Set new.! !

!WebMethodResource methodsFor: 'accessing' stamp: 'jm 7/29/2010 12:30'!
aidaContentType
	"MIME type for our resource"	
	contentType isNil ifTrue: [self aidaContentType: 'image/gif'].
	^contentType! !

!WebMethodResource methodsFor: 'accessing' stamp: 'jm 7/29/2010 12:30'!
aidaContentType: aString
	contentType := aString! !

!WebMethodResource methodsFor: 'testing' stamp: 'janko 4/25/2012 10:59'!
aidaIsRespondingStreamed
	"always stream method resources"
	^true! !

!WebMethodResource methodsFor: 'private-streaming'!
aidaPresenterFor: aRequest on: aSession 
	^self! !

!WebMethodResource methodsFor: 'accessing' stamp: 'mivsek 1/10/2008 17:41'!
expiresTimestamp
	"24 hours from now, to avoid reloading of images" 
	^SpTimestamp fromSeconds: SpTimestamp now asSeconds + (24*3600)! !

!WebMethodResource methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebElement
	^false! !

!WebMethodResource methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebPage
	^true! !

!WebMethodResource methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
method
	^method! !

!WebMethodResource methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
method: aSymbol
	method := aSymbol! !

!WebMethodResource methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
object
	^object! !

!WebMethodResource methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
object: anObject
	object := anObject! !

!WebMethodResource methodsFor: 'accessing' stamp: 'janko 3/19/2012 13:21'!
preferredUrl
	^preferedUrl! !

!WebMethodResource methodsFor: 'accessing' stamp: 'janko 3/19/2012 21:17'!
preferredUrl: aString
	preferedUrl := aString! !

!WebMethodResource methodsFor: 'printing'!
printString
	^'aMethodResource
	method: ', self method printString, '
	preferedUrl: ', self preferredUrl, '
	content type: ', self aidaContentType! !

!WebMethodResource methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
site
	"a Site on which this resource will be shown"
	^site! !

!WebMethodResource methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
site: anAIDASite
	site := anAIDASite! !

!WebMethodResource methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	"stream content of method resource to a response"
	| response content |
	response := aRequest streamedResponse.
	content := self object perform: self method.
	response length: content size. "to stream on HTTP/1.0 too, because chunking is not allowed"
	self site addResponseHeadersTo: response forPage: self on: aSession.
	response nextPutAll: (AIDASite properArray: content). "in case of TwoByteString or Array"
	response close.! !

!WebMethodResource class methodsFor: 'instance creation' stamp: 'janko 3/19/2012 21:17'!
fromMethod: aSymbol on: anObject contentType: aString preferedUrl: aString2 site: anAIDASite
	^super new
		object: anObject;
		method: aSymbol;
		aidaContentType: aString;
		preferredUrl: aString2;
		site: anAIDASite! !

!WebMethodResource class methodsFor: 'instance creation'!
fromMethod: aSymbol on: anObject contentType: aString site: anAIDASite
	^super new
		object: anObject;
		method: aSymbol;
		aidaContentType: aString;
		site: anAIDASite! !

!WebMobileApplication class methodsFor: 'private' stamp: 'janko 8/25/2012 12:52'!
newFromNameFor: anObject on: aSession
	"Try to create of anObjectMobileApp instance if that class exists."
	"Squeak specific!!"
	| className class |
	className := (anObject class name asString, 'MobileApp') asSymbol.
	class := [Smalltalk at: className] on: Error do: [:ex | ^nil].  "Squeak specific!!"
	(class allSuperclasses includes: WebApplication) ifFalse: [^nil].
	^class basicNew 
		observee: anObject; 
		session: aSession; 
		initialize.
													
													! !

!WebNonHTMLResource methodsFor: 'accessing' stamp: 'jm 7/29/2010 12:17'!
aidaContentType
	^contentType! !

!WebNonHTMLResource methodsFor: 'accessing' stamp: 'jm 7/29/2010 12:18'!
aidaContentType: anObject
	contentType := anObject ! !

!WebNonHTMLResource methodsFor: 'private-streaming'!
aidaPresenterFor: aRequest on: aSession 
	^self! !

!WebNonHTMLResource methodsFor: 'accessing' stamp: 'np 10/18/2008 13:30'!
content
	^content! !

!WebNonHTMLResource methodsFor: 'accessing' stamp: 'np 10/18/2008 13:31'!
content: anObject
	content := anObject! !

!WebNonHTMLResource methodsFor: 'accessing' stamp: 'np 10/18/2008 13:31'!
filename
	^filename! !

!WebNonHTMLResource methodsFor: 'accessing' stamp: 'np 10/18/2008 13:31'!
filename: anObject
	filename := anObject! !

!WebNonHTMLResource methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	self filename isNil
		ifTrue: [aStream nextPutAll: self content]
		ifFalse: [aStream nextPutAll: 
			(SpFilename named: self filename) 
				underlyingFilename contentsOfEntireBinaryFile asString]! !

!WebNonHTMLResource class methodsFor: 'instance creation'!
forPDF: aByteArray
	^super new
		aidaContentType: 'application/pdf';
		content: aByteArray! !

!WebNonHTMLResource class methodsFor: 'instance creation'!
forPDFFile: aFilenameString
	^super new
		aidaContentType: 'application/pdf';
		filename: aFilenameString! !

!WebNonHTMLResource class methodsFor: 'instance creation'!
forText: aByteArray
	^super new
		aidaContentType: 'text/plain';
		content: aByteArray! !

!WebNonHTMLResource class methodsFor: 'instance creation'!
forXML: aByteArray
	^super new
		aidaContentType: 'text/xml';
		content: aByteArray! !

!WebPage methodsFor: 'private-scripts'!
addCometLoadScript
	"long polling Ajax call"
	self site cometEnabled ifTrue:
		[self onLoad: 'aidaOpenComet()' ] "will also check that WebSocket is not already open"! !

!WebPage methodsFor: 'header elements' stamp: 'janko 11/24/2008 21:56'!
addGlobalKeywords
	"global keywords to all pages on this website"
	| app |
	app := self firstAppFromStack.
	(app isNil or: [app site keywords isEmpty]) ifTrue: [^nil].
	self addMetaKeywords: app site keywords! !

!WebPage methodsFor: 'private' stamp: 'janko 8/25/2012 19:02'!
addHeader: aTagString value: aString
	| event |
	self isStreaming ifTrue: [self errorAlreadyInStreamingState]. "too late to add headers in streaming state!!"
	event := self firstContextFromStack event.
	event isClassicalRequest 
		ifFalse: [self errorCannotSetHeadersFromAjax]. "because page headers are already sent to browser"
	self headers add: (aTagString -> aString)! !

!WebPage methodsFor: 'private-scripts'!
addJSONReportScriptAndHandler
	"report existence of JSON support in browser"
	self onLoad: 'aidaJsonReport()'.
	(self eventHandlerFor: #jsonExists)
		addJsonExists! !

!WebPage methodsFor: 'header elements'!
addJavascript: aScriptString
	self addScriptWithParms: 'type="text/javascript"' script: aScriptString! !

!WebPage methodsFor: 'header elements' stamp: ' 21/4/07 22:07'!
addLinkToAlternateScreenStyleSheet: anObjectOrUrl
	| url |
	url := anObjectOrUrl isString
		ifTrue: [anObjectOrUrl]
		ifFalse: [self site urlResolver halfUrlFor: anObjectOrUrl].
	self addHeader: 'link' value: 'rel="alternate stylesheet" type="text/css" media="screen" href="', url, '" '! !

!WebPage methodsFor: 'header elements'!
addLinkToDefaultFavicon
	"WebStyle favicon (favorites icon). So far only in .ico format!!"
	self addLinkToFavicon: '/favicon.ico'! !

!WebPage methodsFor: 'header elements'!
addLinkToFavicon: aFaviconImageOrUrl
	"favicon (favorites icon). So far only in .ico format!!"
	| url |
	url := aFaviconImageOrUrl isString
		ifTrue: [aFaviconImageOrUrl]
		ifFalse: [self site urlResolver fullUrlFor: aFaviconImageOrUrl on: nil].
	self addHeader: 'link' value: 'rel="icon" type="image/x-icon" href="', url, '" '! !

!WebPage methodsFor: 'header elements' stamp: ' 21/4/07 22:07'!
addLinkToJavascript: anObjectOrUrl
	| url |
	url := anObjectOrUrl isString
		ifTrue: [anObjectOrUrl]
		ifFalse: [self site urlResolver halfUrlFor: anObjectOrUrl].
	self addScriptWithParms: ' src="', url, '" language="JavaScript" type="text/javascript"' script: ''.! !

!WebPage methodsFor: 'header elements'!
addLinkToMobileStyleSheet: anObjectOrUrl
	| url |
	url := anObjectOrUrl isString
		ifTrue: [anObjectOrUrl]
		ifFalse: [self site urlResolver halfUrlFor: anObjectOrUrl].
	self addHeader: 'link' value: 'rel="stylesheet" type="text/css" media="screen" href="', url, '" '! !

!WebPage methodsFor: 'header elements' stamp: ' 21/4/07 22:07'!
addLinkToPrintStyleSheet: anObjectOrUrl
	| url |
	url := anObjectOrUrl isString
		ifTrue: [anObjectOrUrl]
		ifFalse: [self site urlResolver halfUrlFor: anObjectOrUrl].
	self addHeader: 'link' value: 'rel="stylesheet" type="text/css" media="print" href="', url, '" '! !

!WebPage methodsFor: 'header elements' stamp: ' 21/4/07 22:07'!
addLinkToScreenStyleSheet: anObjectOrUrl
	| url |
	url := anObjectOrUrl isString
		ifTrue: [anObjectOrUrl]
		ifFalse: [self site urlResolver halfUrlFor: anObjectOrUrl].
	self addHeader: 'link' value: 'rel="stylesheet" type="text/css" media="screen" href="', url, '" '! !

!WebPage methodsFor: 'header elements' stamp: ' 21/4/07 22:07'!
addMetaContentType: aString
	"example: 'text/html; charset=iso8859-2'"
	self addHeader: 'meta' value: 'http-equiv="Content-Type"  content="', aString, '" '! !

!WebPage methodsFor: 'header elements'!
addMetaDescription: aString
	self addMetaName: 'description' content: aString! !

!WebPage methodsFor: 'header elements'!
addMetaKeywords: aString
	"keywords separated with , "
	self addMetaName: 'keywords' content: aString! !

!WebPage methodsFor: 'header elements'!
addMetaName: aNameString content: aContentString
	self addHeader: 'meta' value: 'name="', aNameString, '" content="', aContentString, '"'! !

!WebPage methodsFor: 'private-scripts'!
addNewTabScriptAndHandler
	"report opening page in new tab or window on the same page"
	self onLoad: 'aidaNewTabReport()'.
	(self eventHandlerFor: #newtab) 
		addNewTab! !

!WebPage methodsFor: 'private' stamp: 'janko 8/25/2012 19:02'!
addScriptWithParms: aString script: aScriptString
	self isStreaming ifTrue: [self errorAlreadyInStreamingState]. "too late to add headers in streaming state!!"
	self firstContextFromStack event isClassicalRequest 
		ifFalse: [self errorCannotSetHeadersFromAjax]. "because page headers are already sent to browser"
	self headers add: ('script' -> (Array with: aString with: aScriptString) )! !

!WebPage methodsFor: 'header elements' stamp: 'janko 8/25/2012 19:03'!
addStyle: aString
	"inline CSS to header of a page. It will be always the last in the header, after /screen.css, to allow overriding it"
	self isStreaming ifTrue: [self errorAlreadyInStreamingState]. "too late to add headers in streaming state!!"
	self firstContextFromStack event isClassicalRequest 
		ifFalse: [self errorCannotSetHeadersFromAjax]. "because page headers are already sent to browser"
	self headers add: ('style' -> (Array with: 'type="text/css"' with: aString) ).
	"see also #rearrangeHeaders called from #streamHtmlTo:..  "! !

!WebPage methodsFor: 'header elements'!
addTitle: aString
	self addHeader: 'title' value:  aString.! !

!WebPage methodsFor: 'private-scripts'!
addUnloadReportScriptAndHandler
	"report unloading (closing, going to another) the page"
	self onUnload: 'aidaUnloadReport()'.
	(self eventHandlerFor: #unload)
		addPageUnload! !

!WebPage methodsFor: 'private-scripts'!
addWebSocketLoadScript
	self onLoad: 'aidaOpenWebSocket()'! !

!WebPage methodsFor: 'accessing' stamp: 'jm 7/29/2010 12:28'!
aidaContentType
	"return 'text/html' as content type for web pages"
	^'text/html'! !

!WebPage methodsFor: 'testing' stamp: 'janko 4/25/2012 10:59'!
aidaIsRespondingStreamed
	"is this page able to stream HTML directly into response?"
	^false! !

!WebPage methodsFor: 'private-streaming'!
aidaPresenterFor: aRequest on: aSession 
	^self! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
alink: aSymbol
	"set the color of active link text. It can be in hex format (for example #00FF00) 
	or name of color (for example #White)"
	self attributesAt: #alink put: (self colorValue: aSymbol)! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
alinkColor: aSymbol
	self alink: aSymbol.! !

!WebPage methodsFor: 'accessing'!
app
	"return anApplication on which we are composing this web page"
	^self parent notNil 
		ifTrue: [self parent "context" app]
		ifFalse: [self firstContextFromStack app]! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
background: anImageOrURL
	"set the URL for the background image"
	self attributesAt: #background put:
		(anImageOrURL isString 
			ifTrue: [anImageOrURL]
			ifFalse: [self site urlResolver halfUrlFor: anImageOrURL]).! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
bgColor: aSymbol
	"set the color of page background)"
	self attributesAt: #bgcolor put: (self colorValue: aSymbol)! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
bgImage: anImageOrURL
	self background: anImageOrURL.! !

!WebPage methodsFor: 'initialize-release'!
checkBrowserSupport
	"if browser not supported then set a warning message in red on top of page"
	self session isBrowserSupported ifTrue: [^self warningMessage: nil].
"	Transcript cr; show: '*** browser not supported: ', self session lastRequest userAgent, ' ',
		self site name, ' ', self session user nameSurname.
" "		show: self app session lastRequest printString; cr;
		show: '       user: ', self session user nameSurname; cr."

	self warningMessage: '<b>Your browser is too old.</b><br> Please install the newest version, recommended browsers are <a href="http://www.mozilla.com/firefox/">Firefox</a>, <a href="http://www.opera.com/">Opera</a> or <a href="http://www.google.com/chrome">Chrome</a>'! !

!WebPage methodsFor: 'accessing'!
close
	"only the subwindow can be closed that way, not a main page"
	self error: 'only the subwindows can be closed!!'! !

!WebPage methodsFor: 'private-streaming' stamp: 'janko 8/25/2012 19:56'!
ensureTitleInHeader
	| app htitle |
	app := self app. app ifNil: [^nil].
	htitle := self headers detect: [:assoc | assoc key = 'title'] ifNone: [nil].
	(app title aidaIsAssociation or:  [app title isEmpty]) ifTrue: [^nil].
	htitle isNil
		ifTrue: [self addTitle: app title]
		ifFalse: [htitle value: app title]! !

!WebPage methodsFor: 'private'!
errorAlreadyInStreamingState
	self error: 'Too late to add page headers, page is already streaming to response!!'! !

!WebPage methodsFor: 'private'!
errorCannotSetHeadersFromAjax
	self error: 'Cannot set page headers from Ajax request!!'  "because page headers are already sent to browser"! !

!WebPage methodsFor: 'private'!
hasTag
	^false "well..."! !

!WebPage methodsFor: 'private' stamp: 'janko 8/25/2012 18:58'!
headers
	^self otherAt: #pageHeaders ifAbsent: [self initHeaders]! !

!WebPage methodsFor: 'accessing-doctypes'!
htmlDocType
	^self otherAt: #HTMLDocType ifAbsent: [self setDefaultDocType].! !

!WebPage methodsFor: 'private'!
htmlDocType: aString
	^self otherAt: #HTMLDocType put: aString! !

!WebPage methodsFor: 'attributes'!
htmlTagAttributes
	"attributes of HTML tag"
	^self otherAt: #HTMLTagAttributes ifAbsent: [nil].! !

!WebPage methodsFor: 'attributes'!
htmlTagAttributes: aString
	"attributes of HTML tag"
	^self otherAt: #HTMLTagAttributes put: aString.! !

!WebPage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
identDepth
	^self otherAt: #identDepth ifAbsent: [0]! !

!WebPage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
identDepth: aNumber
	"current depth of identation. If 0, the we are at the start of the line"
	self otherAt: #identDepth put: aNumber! !

!WebPage methodsFor: 'initialize-release' stamp: 'janko 8/25/2012 19:00'!
initHeaders
	^self otherAt: #pageHeaders put: OrderedCollection new.! !

!WebPage methodsFor: 'initialize-release' stamp: 'janko 8/25/2012 19:01'!
initPageHeaderLinks
	self app isNil ifTrue: [^nil].
	self addMetaContentType: 'text/html; charset=UTF-8'.
	self addTitle: self title. "should be after charset definition!! See also #ensureTitleInHeader"
	self addLinkToDefaultFavicon. "that from WebStyle favicon in imgs"
	self addGlobalKeywords. "if any"

" moved to #lateInitPageHeaderLinks to put them at the end, after app specific libraries are also put in header
	self addLinkToScreenStyleSheet: self site style screenCssResource.
	self addLinkToPrintStyleSheet: self site style printCssResource.
	self session isMobile ifTrue: 
		[self addLinkToMobileStyleSheet: self site style mobileCssResource].
	self addLinkToJavascript: self site style javascriptResource.
"! !

!WebPage methodsFor: 'initialize-release'!
initPageScripts
	"page body onLoad, onUnload, etc. scripts"
	self session existsJson ifFalse:
		[self addJSONReportScriptAndHandler]. "is native JSON support present in browser?"
"	self
		addWebSocketLoadScript." "if WebSocket supported in browser"
"		addCometLoadScript; "  "long poling Ajax, if enabled on that site and not WebSocket already open"
"		addNewTabScriptAndHandler; " "report opening page in new tab or window"
"		addUnloadReportScriptAndHandler." "report closing the page or going to another one"
			"WARNING, last two crash Safari 5.0.5 "! !

!WebPage methodsFor: 'testing'!
isActive
	"this page is (probably) still displayed on the browser"
	^self parent notNil! !

!WebPage methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isComposite

	"a WebPage is a composite element"
	^true! !

!WebPage methodsFor: 'accessing-doctypes'!
isHTML5
	"is page in HTML5?"
	^self otherAt: #HTML5 ifAbsent: [false]! !

!WebPage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
isNewline
	^self identDepth = 0! !

!WebPage methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebApplication
	^false! !

!WebPage methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebPage
	^true! !

!WebPage methodsFor: 'accessing-doctypes'!
isXHTML
	"is page in XHTML?"
	^self otherAt: #XHTML ifAbsent: [false]! !

!WebPage methodsFor: 'initialize-release'!
lateInitPageHeaderLinks
	"To put them at the end, after app specific libraries are also put in header, they are put in header just
	 before streaming phase begins"
	self app isNil ifTrue: [^nil].
	self addLinkToScreenStyleSheet: self site style screenCssResource.
	self addLinkToPrintStyleSheet: self site style printCssResource.
	self session isMobile ifTrue:  "as cascaded extension of screen CSS!!"
		[self addLinkToMobileStyleSheet: self site style mobileCssResource].
	self addLinkToJavascript: self site style javascriptResource.! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
link: aSymbol
	"set the color of link text."
	self attributesAt: #link put: (self colorValue: aSymbol).! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
linkColor: aSymbol
	self vlink: aSymbol.! !

!WebPage methodsFor: 'events'!
onLoad: aJavascriptCode
	self attributesAt: #onLoad add: aJavascriptCode! !

!WebPage methodsFor: 'events'!
onUnload: aJavascriptCode
	self attributesAt: #onUnload add: aJavascriptCode! !

!WebPage methodsFor: 'private-streaming'!
rearangeHeaders
	"put inline CSS style at the end to allow overriding /screen.css and CSS from libraries"
	| hdrs |
	hdrs := self headers copy.
	1 to: self headers size do: [:inx || header |
		header := hdrs at: inx. "header = aTagString -> aString "
		header key = 'style' ifTrue:
			[self headers removeIndex: inx.
			self headers add: header] ]! !

!WebPage methodsFor: 'redirects'!
redirectAfter: aSecondsNumber toUrl: aString
	"redirection or refresh of specified url, does not work on Mozilla!! "
	self addHeader: 'meta' value: 'http-equiv="REFRESH"  content="', 
		aSecondsNumber printString, '; url=', aString, '" '! !

!WebPage methodsFor: 'redirects'!
redirectTo: anObjectOrUrlString
	"send to browser a command to reload current page with this object or Url"
	| link cmd |
	link := WebLink text:'' linkTo: anObjectOrUrlString.
	cmd := WebCommand newLoadUrl: (link composeURLOn: self session).
	self session queueCommand: cmd! !

!WebPage methodsFor: 'redirects'!
redirectTo: anObject view: aViewSymbol
	"send to browser a command to reload current page with this object and view"
	| link cmd |
	link := WebLink text:'' linkTo: anObject view: aViewSymbol.
	cmd := WebCommand newLoadUrl: (link composeURLOn: self session).
	self session queueCommand: cmd! !

!WebPage methodsFor: 'redirects'!
redirectToView: aViewSymbol
	"send to browser a command to reload current page with this view on same object"
	| app object |
	app := self app.
	object := app observee notNil ifTrue: [app observee] ifFalse: [app].
	self redirectTo: object view: aViewSymbol! !

!WebPage methodsFor: 'accessing'!
script: aString
	"add this JavaScript  to scripts executed at the opening of page"
	self scriptBefore: aString.! !

!WebPage methodsFor: 'accessing'!
session
	"return a session on which we are composing this web page"
	^self parent notNil 
		ifTrue: [self parent "context" session]
		ifFalse: [self firstSessionFromStack]! !

!WebPage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
session: aSession
	session := aSession! !

!WebPage methodsFor: 'accessing-doctypes'!
setDefaultDocType
	^self setHTML5! !

!WebPage methodsFor: 'accessing-doctypes'!
setHTML401Strict
	^self htmlDocType: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">'! !

!WebPage methodsFor: 'accessing-doctypes'!
setHTML401Transitional
	^self htmlDocType: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

'.! !

!WebPage methodsFor: 'accessing-doctypes'!
setHTML5
	"this page is in HTML5"
	self otherAt: #HTML5 put: true.
	^self htmlDocType: '<!!DOCTYPE html>'.! !

!WebPage methodsFor: 'private' stamp: ' 21/4/07 22:07'!
setNewline
	self identDepth: 0! !

!WebPage methodsFor: 'initialize-release'!
setRandomId
	"set a random id of that page to have some unique identifier for page load/unload events"
	self id: ('p', (AIDASite random next * 10000) rounded printString) asSymbol! !

!WebPage methodsFor: 'private'!
setXHTML
	"this page is in XHTML"
	^self otherAt: #XHTML put: true! !

!WebPage methodsFor: 'accessing-doctypes'!
setXHTML10Strict
	self setXHTML.
	^self htmlDocType: '<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'.! !

!WebPage methodsFor: 'accessing-doctypes'!
setXHTML10Transitional
	self setXHTML.
	^self htmlDocType: '<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'.! !

!WebPage methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebPage methodsFor: 'private-streaming' stamp: 'janko 8/25/2012 19:04'!
streamHeaderElementsTo: aStream on: aSession
	self ensureTitleInHeader. "check once more if title is really there"
	self headers do: [:assoc | 
		aStream nextPutAll: '  <', assoc key, ' '.
		((assoc key = 'script') | (assoc key = 'style')) 
			ifTrue: [| array | 
				array := assoc value class == Array 
					ifTrue: [assoc value] 
					ifFalse: [Array with: assoc value with: ''].
				aStream nextPutAll: (array at: 1), '>', (array at: 2), '</', assoc key, '>']
			ifFalse: [(assoc key = 'title')
				ifTrue: [aStream nextPutAll: '>',  
						(AIDASite convertToWeb: (self translateIfNeeded: assoc value) on: aSession), '</title>']
				ifFalse: [aStream nextPutAll: assoc value, self tagClosing] ].
		aStream nextPutAll: self eol].! !

!WebPage methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	self 
		lateInitPageHeaderLinks;
		rearangeHeaders.
	self setStateStreaming.
	aStream 
		nextPutAll: self htmlDocType, self eol.
	aStream 
		nextPutAll: '<html', (self htmlTagAttributes notNil ifTrue: [' ', self htmlTagAttributes] ifFalse: ['']), '>';
		nextPutAll: self eol, ' <head>', self eol;
		nextPutAll: '  <meta name="generator" content="Aida/Web v', AIDASite version, ', Smalltalk Web Application Server (www.aidaweb.si)"', self tagClosing, self eol.
	self streamHeaderElementsTo: aStream on: aSession. "including title"
	aStream nextPutAll: ' </head>', self eol.
	aStream nextPutAll: ' <body'. self streamAttributesTo: aStream for: aSession. 
	aStream nextPutAll: '>', self eol.
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	self streamWarningMessageTo: aStream. "if any"

	elements notNil ifTrue: [elements do: [:element | 
		element notNil ifTrue: [element streamHtmlTo: aStream for: aRequest on: aSession] ] ].

	aStream nextPutAll:  self ident, ' </body>', self eol.
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].
	aStream nextPutAll:  '</html>', self eol.
	self setStateFinished.! !

!WebPage methodsFor: 'private-streaming'!
streamWarningMessageTo: aStream
	self warningMessage isNil ifTrue: [^nil].
	aStream nextPutAll: '
<div align="center" style="background-color: red">
  <br>
  ', self warningMessage, '
  <br>
  <hr>
</div>
'! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
text: aSymbol
	"set the color of page text."
	self attributesAt: #text put: (self colorValue: aSymbol).! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
textColor: aSymbol
	self text: aSymbol.! !

!WebPage methodsFor: 'accessing'!
title
	^self otherAt: #pageTitle ifAbsent: ['']! !

!WebPage methodsFor: 'accessing'!
title: aStringOrMultilangAssociation
	self otherAt: #pageTitle put: aStringOrMultilangAssociation! !

!WebPage methodsFor: 'private-streaming'!
translateIfNeeded: aStringOrMultilangAssociation
	^aStringOrMultilangAssociation aidaIsAssociation
		ifTrue: [aStringOrMultilangAssociation value] "no translation for now, TEMPORARY!!"
		ifFalse: [aStringOrMultilangAssociation convertToSloveneChars]! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
vlink: aSymbol
	"set the color of visited link text."
	self attributesAt: #vlink put: (self colorValue: aSymbol).! !

!WebPage methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
vlinkColor: aSymbol
	self vlink: aSymbol.! !

!WebPage methodsFor: 'accessing'!
warningMessage
	"if set, this warning will be shown on top of that page in red. Usefull for 'Browser not supported' warnings etc"
	^self otherAt: #PageWarningMessage ifAbsent: [nil]! !

!WebPage methodsFor: 'accessing'!
warningMessage: aString
	"if set, this warning will be shown on top of that page in red. Usefull for 'Browser not supported' warnings etc"
	self otherAt: #PageWarningMessage put: aString! !

!WebPage methodsFor: 'accessing'!
webPage
	^self! !

!WebRadioButton methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checked
	^checked! !

!WebRadioButton methodsFor: 'private' stamp: ' 21/4/07 22:07'!
checked: aBoolean
	checked := aBoolean! !

!WebRadioButton methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	super initialize.
	self type: 'radio'.
	self checked: false.! !

!WebRadioButton methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isChecked
	^self checked! !

!WebRadioButton methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isRadioButton
	^true! !

!WebRadioButton methodsFor: 'private' stamp: ' 26/4/07 10:37'!
joinToForm: aWebForm
	"join  this checkbox to the group of them with the same name in aWebForm. 
	This method is called by aWebForm!!"
	| existing |
	existing := aWebForm fieldSet 
		detect: [:each | each isRadioButton and: [each name = self name]]
		ifNone: [self value: Dictionary new. self].
	(existing value = '') ifTrue: [existing value: Dictionary new].
	self adaptor: existing adaptor.
	(self value includesKey: self value) ifFalse:
		[self value at: self value put: false] "????"! !

!WebRadioButton methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setChecked
	self checked: true! !

!WebRadioButton methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setUnchecked
	self checked: false! !

!WebRadioButton methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebRadioButton methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession.
	aStream nextPutAll: self ident, '<input'.
	self streamAttributesTo: aStream for: aSession.
	self isChecked ifTrue: [aStream nextPutAll: ' checked'].
	aStream nextPutAll: self tagClosing.! !

!WebRadioButton methodsFor: 'private' stamp: ' 21/4/07 22:07'!
value
	^self attributesAt: 'value'! !

!WebRadioButton methodsFor: 'private' stamp: ' 21/4/07 22:07'!
value: aString
	"set the value name  of the  radio button"
	^self attributesAt: 'value' put: aString! !

!WebRadioButton class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
name: aNameString value: aValueString 

	^(self new) name: aNameString; value: aValueString! !

!WebRawText methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	text notNil ifTrue: [aStream nextPutAll: self text].! !

!WebRawText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
text: aString
	text := aString! !

!WebRealtimeConnection methodsFor: 'accessing'!
app
	^app! !

!WebRealtimeConnection methodsFor: 'private'!
app: aWebApplication
	app := aWebApplication! !

!WebRealtimeConnection methodsFor: 'accessing'!
connection

	^connection! !

!WebRealtimeConnection methodsFor: 'private'!
connection: aHTTPOrWebSocketConnection
	connection := aHTTPOrWebSocketConnection! !

!WebRealtimeConnection methodsFor: 'accessing'!
handler
	"a parent handler of that and other realtime channels to the browser"
	^handler! !

!WebRealtimeConnection methodsFor: 'private'!
handler: aWebRealtimeHandler
	handler := aWebRealtimeHandler! !

!WebRealtimeConnection methodsFor: 'testing'!
isClosed
	"realtime channel connection is closed"
	self connection isNil ifTrue: [^true].
	^self isWebSocket 
		ifTrue: [self connection isOpen not]
		ifFalse: [self connection isClosed] "for Comet"! !

!WebRealtimeConnection methodsFor: 'testing'!
isComet
	^self type = #comet! !

!WebRealtimeConnection methodsFor: 'testing'!
isWebSocket
	^self type = #websocket! !

!WebRealtimeConnection methodsFor: 'handling'!
pageUrlFrom: aRequest
	"An url of page on which this realtime connection is open. From query part of url"
	| url |
	(aRequest queryAt: 'pageurl') isNil ifTrue: [^nil].
	url := (aRequest queryAt: 'pageurl') readStream upTo: $? .
	^url readStream upTo: $#! !

!WebRealtimeConnection methodsFor: 'handling' stamp: 'janko 7/13/2011 21:11'!
pageViewFrom: aRequest
	"A view on which this realtime connection is open. From query part of url"
	"Sqeak specific"
	| query pview |
	(aRequest queryAt: 'pageurl') isNil ifTrue: [^nil].
	query := (aRequest queryAt: 'pageurl') readStream upTo: $? ; upToEnd.
	query := (query readStream upTo: $# ) trimBlanks. "skip #anchor if any"
	(query isEmpty or: [(query includesSubString: 'view=') not ]) ifTrue: [^#main].
	pview := query readStream upToAll: 'view';  skip: 1  "="; upTo: $& . "Squeak specific"
	 ^pview asSymbol! !

!WebRealtimeConnection methodsFor: 'private'!
printString
	^'aWebRealtimeConnection 
	type: ', self type printString, '
	session: ',  (self session notNil ifTrue: [self session id printString] ifFalse: ['nil']), '
	app: ', (self app notNil ifTrue: [self app class name] ifFalse: ['nil']), '
	view: ', self view printString, '
	connection: ', (self isClosed ifFalse: ['open'] ifTrue: ['closed'])! !

!WebRealtimeConnection methodsFor: 'cleanup'!
removeIfNonactive
	"check and remove if app or view is nonactive, also if connection is already closed"
	"call that when page unload event came to close its realtime connections"
	self isClosed ifTrue: [^self removeYourself].
	(self app isNil  or: [self app isActive not])
		ifTrue: [self removeYourself]
		ifFalse: [(self app isActiveView: self view) ifFalse: [self removeYourself] ]! !

!WebRealtimeConnection methodsFor: 'cleanup'!
removeYourself
	self connection notNil ifTrue: 
		[self connection close].
	self handler notNil ifTrue:
		[self handler connections remove: self ifAbsent: [nil] ].
	self 
		handler: nil; 
		app: nil; 
		view: nil; 
		connection: nil! !

!WebRealtimeConnection methodsFor: 'handling-websocket' stamp: 'janko 8/19/2011 22:15'!
respondToWebSocketMessage: aString
	"respondss to webSocekt messages"
	"Intialized as webSocket's receiveBlock in streamWebSocketOn:for:on: "
	| event |
	[event := WebEvent fromJSON: aString on: self session.
	event app respondToEvent: event]
		on: Error
		do: [:exception | 
			"self handler site reportException: exception. "
			"exception defaultAction"]! !

!WebRealtimeConnection methodsFor: 'accessing'!
semaphore

	^semaphore! !

!WebRealtimeConnection methodsFor: 'private'!
semaphore: aSemaphore
	semaphore := aSemaphore! !

!WebRealtimeConnection methodsFor: 'handling'!
sendMesagesFromQueue
	"try to send messages to all open channels, depending on the target app on view of the connection"
	| msgs jsonString |
	msgs := self session queue select: [:msg | 
		msg app = self app and: [msg view = self view] ].
	msgs isEmpty ifTrue: [^nil].
	jsonString := self session packToJSONMessages: msgs.
	self connection send: jsonString.
	self session queue removeAll: msgs.! !

!WebRealtimeConnection methodsFor: 'accessing'!
session
	"session in which this realtime connection is open"
	^self handler notNil 
		ifTrue: [self handler session]
		ifFalse: [nil]! !

!WebRealtimeConnection methodsFor: 'handling'!
setAppAndViewFrom: aRequest
	| url object |
	self view: (self pageViewFrom: aRequest).
	url := self pageUrlFrom: aRequest.
	url notNil ifTrue:
		[object := self session site urlResolver objectOnUrl: url.
		self app: (self session webAppFor: object)]! !

!WebRealtimeConnection methodsFor: 'handling-comet'!
setCometFrom: aRequest
	self setAppAndViewFrom: aRequest! !

!WebRealtimeConnection methodsFor: 'handling-websocket'!
setWebSocketFrom: aRequest
	self connection: aRequest webSocket.
	self setAppAndViewFrom: aRequest.
	self connection receiveBlock: [:msg | self respondToWebSocketMessage: msg].! !

!WebRealtimeConnection methodsFor: 'accessing'!
type

	^type! !

!WebRealtimeConnection methodsFor: 'private'!
type: anObject

	type := anObject! !

!WebRealtimeConnection methodsFor: 'accessing'!
view

	^view! !

!WebRealtimeConnection methodsFor: 'private'!
view: aSymbol
	view := aSymbol! !

!WebRealtimeConnection class methodsFor: 'instance creation'!
newCometOn: aWebRealtimeHandler from: aRequest
	^super new
		type: #comet;
		handler: aWebRealtimeHandler;
		setCometFrom: aRequest! !

!WebRealtimeConnection class methodsFor: 'instance creation'!
newWebSocketOn: aWebRealtimeHandler from: aRequest
	^super new
		type: #websocket;
		handler: aWebRealtimeHandler;
		setWebSocketFrom: aRequest! !

!WebRealtimeHandler methodsFor: 'private'!
add: aRealtimeConnection
	^self connections add: aRealtimeConnection! !

!WebRealtimeHandler methodsFor: 'initialize-release' stamp: 'janko 7/13/2011 20:41'!
cleanup
	"remove all realtime connections with closed apps or views, etc."
	self isRealtimeChannelOpen ifFalse: [^nil].
	self connections copy do: [:conn | conn removeIfNonactive]! !

!WebRealtimeHandler methodsFor: 'handling-comet'!
cometConnections
	"open Comet connections and their sempaphores"
	^self connections select: [:each | each isComet ]! !

!WebRealtimeHandler methodsFor: 'accessing'!
connections
	"all currently open realtime connections"
	connections isNil ifTrue: [self initConnections].
	^connections! !

!WebRealtimeHandler methodsFor: 'initialize-release'!
initConnections
	connections := OrderedCollection new! !

!WebRealtimeHandler methodsFor: 'testing'!
isRealtimeChannelOpen
	"is any realtime connection open?"
	^self connections notEmpty! !

!WebRealtimeHandler methodsFor: 'initialize-release'!
removeAll
	"close and remove all realtime connections"
	self connections copy do: [:conn | conn removeYourself]! !

!WebRealtimeHandler methodsFor: 'handling-comet'!
respondToCometRequest: aRequest
	(Delay forSeconds: 5) wait. 
	^self! !

!WebRealtimeHandler methodsFor: 'serving'!
sendMesagesFromQueue
	"try to send messages to all open channels, depending on the target app on view of the connection"
	self cleanup. "remove all closed connections first"
	self connections do: [:conn | conn sendMesagesFromQueue] "also remove sent msgs from queue"! !

!WebRealtimeHandler methodsFor: 'accessing'!
session
	^session! !

!WebRealtimeHandler methodsFor: 'private'!
session: aWebSession
	session := aWebSession! !

!WebRealtimeHandler methodsFor: 'accessing'!
site
	^self session site! !

!WebRealtimeHandler methodsFor: 'handling-comet'!
streamCometOn: aStream for: aRequest on: aWebSession
	"Long polling Comet.
	This Ajax request will be blocked until some command come to queue"! !

!WebRealtimeHandler methodsFor: 'handling-websocket' stamp: 'janko 7/13/2011 17:07'!
streamWebSocketOn: aStream for: aRequest on: aWebSession
	"For web socket to become connected as bidirectional channel to browser"
	| realtimeConn response |
	aRequest isWebSocketRequest ifFalse: [^HTTPResponse forbidden].
	"put authorization check here!! "
	realtimeConn := WebRealtimeConnection newWebSocketOn: self from: aRequest.
	self cleanup; add: realtimeConn.
	response := realtimeConn connection answerTo: aRequest.
	aStream nextPutAll:  response body asString. "because of postprocessing on 
												  AIDASite answerToGetOrPost:on:"
	aRequest task response become: response. "switch with a preprepared response"! !

!WebRealtimeHandler methodsFor: 'handling-websocket'!
webSocketConnections
	"open WebSocket connections"
	^self connections select: [:each | each isWebSocket ]! !

!WebRealtimeHandler class methodsFor: 'instance creation'!
newOn: aWebSession
	^super new
		session: aWebSession! !

!WebRichEditor methodsFor: 'setup parameters'!
buttonsFirstLine
	"which buttons are in first line of toolbar"
	^self otherAt: #buttonsFirstLine ifAbsent: [self defaultButtonsFirstLine]! !

!WebRichEditor methodsFor: 'setup parameters'!
buttonsFirstLine: aString
	"which buttons are in first line of toolbar"
	^self otherAt: #buttonsFirstLine put: aString! !

!WebRichEditor methodsFor: 'setup parameters'!
buttonsSecLine
	"which buttons are in second line of toolbar"
	^self otherAt: #buttonsSecLine ifAbsent: [self defaultButtonsSecLine]! !

!WebRichEditor methodsFor: 'setup parameters'!
buttonsSecLine: aString
	"which buttons are in second line of toolbar"
	^self otherAt: #buttonsSecLine put: aString! !

!WebRichEditor methodsFor: 'setup parameters'!
buttonsThirdLine
	"which buttons are in third line of toolbar"
	^self otherAt: #buttonsThirdLine ifAbsent: [self defaultButtonsThirdLine]! !

!WebRichEditor methodsFor: 'setup parameters'!
buttonsThirdLine: aString
	"which buttons are in third line of toolbar"
	^self otherAt: #buttonsThirdLine put: aString! !

!WebRichEditor methodsFor: 'setup parameters'!
contentStyleUrl
	"where we have a CSS for content"
	^'/rich-editor.css' "as defined in WebStyle richEditorStyleSheet"
"	^'/tinymce/jscripts/tiny_mce/themes/advanced/skins/default/content.css'" "default only" 
"	^'/tinymce/jscripts/tiny_mce/themes/advanced/skins/default/content.css, /screen.css'"! !

!WebRichEditor methodsFor: 'setup defaults'!
defaultButtonsFirstLine
	"which buttons are in first line of toolbar"
	"see http://wiki.moxiecode.com/index.php/TinyMCE:Configuration/theme_advanced_buttons_1_n"
	^'save, , | , undo, redo, | , bold, italic, underline, strikethrough, sub, sup, | , bullist, numlist, outdent, indent, | , formatselect, fontsizeselect, | , justifyleft, justifycenter, justifyright,  justifyfull'! !

!WebRichEditor methodsFor: 'setup defaults'!
defaultButtonsSecLine
	"which buttons are in second line of toolbar"
	"see http://wiki.moxiecode.com/index.php/TinyMCE:Configuration/theme_advanced_buttons_1_n"
	^'cut, copy, pastetext, pasteword, | , search, replace, hr, | , tablecontrols, | , forecolor,backcolor, | , charmap, image,  flash, link, unlink'! !

!WebRichEditor methodsFor: 'setup defaults'!
defaultButtonsThirdLine
	"no buttons by default in third line of toolbar"
	"see http://wiki.moxiecode.com/index.php/TinyMCE:Configuration/theme_advanced_buttons_1_n"
	^''! !

!WebRichEditor methodsFor: 'setup defaults'!
defaultInlinePopups
	"popup windows shown inline?"
	^true! !

!WebRichEditor methodsFor: 'setup defaults'!
defaultPlugins
	"default plugins to load"
	^'paste, table, save, autosave, searchreplace, advimage'! !

!WebRichEditor methodsFor: 'setup'!
initScript
	"See TinyMCE docs for explanation: http://tinymce.moxiecode.com/tinymce/docs/index.html"
	"beware, only one instance of editor should run at once!! "
	"WebRichEditor basicNew richEditorInitScript"
	| language |
	language := self firstAppFromStack notNil
		ifTrue: [self firstAppFromStack site style richEditorLanguage]
		ifFalse: ['en'].
	^'
tinyMCE.init({
	mode : "specific_textareas",
	textarea_trigger : "mce_editable",
	language : "', language ,  '",
	content_css : "', self contentStyleUrl, '",
	theme : "advanced",
	plugins : "', self plugins, 
		(self inlinePopups ifTrue: [', inlinepopups'] ifFalse: ['']), '",
	theme_advanced_buttons1 : "', self buttonsFirstLine, '",
	theme_advanced_buttons2 : "', self buttonsSecLine, '",
	theme_advanced_buttons3 : "', self buttonsThirdLine, '",
	theme_advanced_toolbar_location : "top",
	theme_advanced_toolbar_align : "left",
	extended_valid_elements : "a[name|href|target|title|onclick],img[class|src|border=0|alt|title|hspace|vspace|width|height|align|onmouseover|onmouseout|name],hr[class|width|size|noshade],font[face|size|color|style],span[class|align|style]",
	save_enablewhendirty: "true",
	paste_use_dialog : "false",
	button_tile_map : "true",
	gecko_spellcheck : "true" ', 
 	(self saveCallback notNil ifTrue: [',
		save_callback : "', self saveCallback, '" ' ] ifFalse: ['']),
'});
'! !

!WebRichEditor methodsFor: 'initialize-release'!
initialize
	super initialize.
	self attributesAt: 'mce_editable' put: 'true'.
	self class ensureResourcesInPageHeader "JavaScript, CSS"! !

!WebRichEditor methodsFor: 'setup parameters'!
inlinePopups
	"popup windows shown inline?"
	^self otherAt: #inlinePopups ifAbsent: [self defaultInlinePopups]! !

!WebRichEditor methodsFor: 'setup parameters'!
plugins
	"which plugins to load"
	^self otherAt: #plugins ifAbsent: [self defaultPlugins]! !

!WebRichEditor methodsFor: 'setup parameters'!
plugins: aString
	"which plugins to load"
	^self otherAt: #plugins put: aString! !

!WebRichEditor methodsFor: 'setup parameters'!
saveCallback
	"a JS script to execute when save button pressed or whole form submited"
	^self otherAt: #saveCallback ifAbsent: [nil]! !

!WebRichEditor methodsFor: 'setup parameters'!
saveCallback: aString
	"a JS script to execute when save button pressed or whole form submited"
	^self otherAt: #saveCallback put: aString! !

!WebRichEditor methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
"	aRequest isAjaxRequest ifTrue:
		[self scriptBefore: self class richEditorInitScript]." "otherwise it won't show in Ajax update"
	self scriptBefore: self initScript. "for every editor instance, is that good? "
	^super streamHtmlTo: aStream for: aRequest on: aSession! !

!WebRichEditor class methodsFor: 'ensure resources'!
ensureResourcesInPageHeader
	"JavaScript, CSS"
	" For CSS see WebStyle richEditorCssResource and richEditorStyleSheet"
	"Be carefull to add the same url in initRichEditorScript at content_css !!"
	| site |
	TinyMCELibrary ensure.
	site := self firstAppFromStack site.
	site urlResolver halfUrlFor: site style richEditorCssResource. "just to register if not yet"! !

!WebRichEditorWakeup methodsFor: 'printing' stamp: 'np 10/18/2008 16:41'!
build
	| iframe |
	self clear. self setDiv. self hide.
"	self isWakeupTimeout ifFalse: [^self]. "
	iframe := WebIFrame new src: '/admin.html?view=wakeupRichEditor'.
	self add: iframe.
	self setWakeupTimestamp.
	
"	self setDiv. self registerId.
	self session lastRequest isAjaxRequest 
		ifFalse: 
			[self hide.
			self update ] ""to call iframe below in backgrund""
		ifTrue: 
			[iframe := WebIFrame new src: '/admin.html?view=wakeupRichEditor'.
			self add: iframe.
			self setWakeupTimestamp]
"! !

!WebRichEditorWakeup methodsFor: 'timeout' stamp: 'janko 7/18/2008 17:13'!
isWakeupTimeout
	"more that one hour since last prefech?"
	"why refresh every hour?"
	| last |
	last := self session userValues at: #wakeupRichEditorTimestamp ifAbsent: [^true].
	^SpTimestamp now asSeconds - last asSeconds > 3600! !

!WebRichEditorWakeup methodsFor: 'timeout' stamp: 'janko 7/18/2008 17:11'!
setWakeupTimestamp
	"store in user's session when last wakeup was done"
	self session userValues at: #wakeupRichEditorTimestamp put: SpTimestamp now.
! !

!WebRouter methodsFor: 'adding-removing'!
addFirstRoutePattern:  aPatternString handler: aHandler
	"add a route at the start of routes"
	^self routes addFirst: (aPatternString -> aHandler)! !

!WebRouter methodsFor: 'adding-removing'!
addMethodLibrariesRoute
	"AIDASite allInstances do: [:each | each router addMethodLibrariesRoute] "
	"WebStyles holds method resources like JS, CSS, etc, while method images are dealed in URLResolver"
	(self routes contains: [:route | route value == WebMethodLibrary]) "only one lib route!!"
		ifTrue: [^nil].
	self addRoutePattern: '/*' handler: WebMethodLibrary "class directly, it will route further by itself"! !

!WebRouter methodsFor: 'adding-removing'!
addMethodResourcesRoute
	"AIDASite allInstances do: [:each | 
		each router addMethodResourcesRoute.
		each urlResolver removeObjectsOfClass: WebMethodResource] "
	"WebStyles holds method resources like JS, CSS, etc, while method images are dealed in URLResolver"
	(self routes contains: [:route | route value isKindOf: WebStyle]) "only one static server!!"
		ifTrue: [^nil].
	self addRoutePattern: '/*' handler: self site style! !

!WebRouter methodsFor: 'adding-removing'!
addRoutePattern:  aPatternString handler: aHandler
	"add a route at the end of routes"
	^self routes add: (aPatternString -> aHandler)! !

!WebRouter methodsFor: 'adding-removing'!
addSessionManagerRoute
	"routes all session related requests like Ajax and WebSocket to session manager"
	"AIDASite allInstances do: [:site | site router addSessionManagerRoute] "
	(self routes contains: [:route | route value class == WebSessionManager]) "only one route!!"
		ifTrue: [^nil].
	self addFirstRoutePattern: '/aidasession/*' handler: self site sessionManager! !

!WebRouter methodsFor: 'adding-removing'!
addStaticServerRoute
	"WebStaticServer as an one-way router to serve static files"
	(self routes contains: [:route | route value isKindOf: WebStaticServer]) "only one static server!!"
		ifTrue: [^nil].
	self addRoutePattern: '/*' handler: self site staticServer! !

!WebRouter methodsFor: 'adding-removing'!
addURLResolverRoute
	"URLResolver as a two-way router between urls and domain objects"
	(self routes contains: [:route | route value isKindOf: WebStaticServer]) "only one url resolver!!"
		ifTrue: [^nil].
	self addRoutePattern: '/*' handler: self site urlResolver! !

!WebRouter methodsFor: 'initialize-release' stamp: 'janko 8/25/2012 19:33'!
initDefaultRoutes
	self addSessionManagerRoute. "routes all session related requests like WebSocket"
	self addURLResolverRoute.
	self addMethodLibrariesRoute.
	self addMethodResourcesRoute.  "to the style (WebStyle subclass)"
	self addStaticServerRoute.! !

!WebRouter methodsFor: 'initialize-release'!
initRoutes
	routes := OrderedCollection new! !

!WebRouter methodsFor: 'initialize-release'!
initialize
	self initDefaultRoutes! !

!WebRouter methodsFor: 'routing' stamp: 'janko 8/25/2012 17:51'!
resourceFor: aRequest
	"it routes a request to appropriate handler, which returns a resource to respond to request"
	| url resource  | 
	url := AIDASite convertFromWeb: aRequest uriString on: aRequest session.  "for international Urls"
	self routes do: [:route |
		(route key "url pattern" match: url) ifTrue: 
			[resource := route value "handler" resourceFor: aRequest.
			resource notNil ifTrue: [^resource] ] ].
	^nil "no route to resource for that request"! !

!WebRouter methodsFor: 'accessing'!
routes
	routes ifNil: [self initRoutes].
	^routes! !

!WebRouter methodsFor: 'accessing'!
site
	^site! !

!WebRouter methodsFor: 'private'!
site: anAIDASite
	site := anAIDASite! !

!WebRouter class methodsFor: 'instance creation' stamp: 'jm 9/8/2010 20:48'!
newOn: anAIDASite
	^super basicNew
		site: anAIDASite;
		initialize! !

!WebScheduledEvent methodsFor: 'private' stamp: 'np 10/17/2008 17:40'!
aidaDeepCopyNotIn: aDictionary 
	^ nil! !

!WebScheduledEvent methodsFor: 'setup' stamp: ' 21/4/07 22:07'!
at: aTimestamp runBlock: aBlockClosure
	self timestamp: aTimestamp.
	self block: aBlockClosure.
	self setPeriodSingle! !

!WebScheduledEvent methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
block
	"a block to be run at event"
	^block! !

!WebScheduledEvent methodsFor: 'private' stamp: ' 21/4/07 22:07'!
block: anObject
	block := anObject! !

!WebScheduledEvent methodsFor: 'setup' stamp: 'jm 2/4/2011 20:57'!
everyDayAt: aTimeOrHour  runBlock: aBlock
	| time |
	time := aTimeOrHour class == Time 
		ifTrue: [aTimeOrHour] ifFalse: [Time fromSeconds: aTimeOrHour*60*60].
	self timestamp: (SpTimestamp fromDate: Date today andTime: time).
	self block: aBlock.
	self periodType: #day value: time! !

!WebScheduledEvent methodsFor: 'setup' stamp: 'jm 2/4/2011 20:57'!
everyHourAt: aMinuteNumber runBlock: aBlock
	self timestamp: (SpTimestamp fromDate: Date today andTime: 
		(Time fromSeconds: (Time now hours * 3600) + (aMinuteNumber * 60))).
	self block: aBlock.
	self periodType: #hour value: aMinuteNumber! !

!WebScheduledEvent methodsFor: 'setup' stamp: 'mivsek 8/22/2007 20:55'!
everyMinuteAt: aSecondNumber runBlock: aBlock
	self timestamp: (SpTimestamp fromDate: Date today andTime: 
		(Time fromSeconds: (Time now hours * 3600) + (Time now minutes * 60) + aSecondNumber)).
	self block: aBlock.
	self periodType: #minute value: aSecondNumber! !

!WebScheduledEvent methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isDayPeriod
	^self period notNil and: [self period key = #day]! !

!WebScheduledEvent methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isHourPeriod
	^self period notNil and: [self period key = #hour]! !

!WebScheduledEvent methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isMinutePeriod
	^self period notNil and: [self period key = #minute]! !

!WebScheduledEvent methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isPeriodic
	^(self period isNil or: [self period key = #single]) not! !

!WebScheduledEvent methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
method
	"a method to be called on an object at a scheduled time"
	^method! !

!WebScheduledEvent methodsFor: 'private' stamp: ' 21/4/07 22:07'!
method: aSymbol
	"a method to be called on an object at a scheduled time"
	method := aSymbol! !

!WebScheduledEvent methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
object
	"object on which a method wil be called at scheduled time"
	^object! !

!WebScheduledEvent methodsFor: 'private' stamp: ' 21/4/07 22:07'!
object: anObject
	object := anObject! !

!WebScheduledEvent methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
parent
	^parent! !

!WebScheduledEvent methodsFor: 'private' stamp: ' 21/4/07 22:07'!
parent: anObject
	parent := anObject! !

!WebScheduledEvent methodsFor: 'private-periods' stamp: ' 21/4/07 22:07'!
period
	"asociation with type and parameter: #single>nil #day>aTime, ... "
	^period! !

!WebScheduledEvent methodsFor: 'private-periods' stamp: ' 21/4/07 22:07'!
periodType: aSymbol value: anObject
	period := Association key: aSymbol value: anObject! !

!WebScheduledEvent methodsFor: 'private' stamp: 'jm 2/4/2011 21:28'!
printString
	^'aScheduledEvent 
	timestamp: ', self timestamp printSloString, ':', self timestamp asTime second printString, '
	period: ', self period key printString, ' ', self period value printString, '
	method: ', self method printString, '
	object: ', self object printString, '
	block: ', self block printString! !

!WebScheduledEvent methodsFor: 'private' stamp: ' 21/4/07 22:07'!
representBinaryOn: binWriter
	"for BOSS out. Blocks are not BOSSed out correctly, therefore we cannot export evens that way!!"
	"TEMPORARY, find a better solution!!"
	^0! !

!WebScheduledEvent methodsFor: 'private' stamp: 'mivsek 8/22/2007 20:55'!
reschedule
	"calculate and set a new time to run, according to a period"
	self isDayPeriod ifTrue: 
		[self timestamp: (SpTimestamp fromSeconds: (self timestamp asSeconds + (60*60*24)))].
	self isHourPeriod ifTrue: 
		[self timestamp: (SpTimestamp fromSeconds: (self timestamp asSeconds + (60*60)))].
	self isMinutePeriod ifTrue: 
		[self timestamp: (SpTimestamp fromSeconds: (self timestamp asSeconds + 60))].
	self parent scheduleEvent: self.! !

!WebScheduledEvent methodsFor: 'running' stamp: 'jm 2/7/2011 13:08'!
run
	"run this event (in forked process), remove it from queue and reschedule if periodic"
	self block notNil 
		ifTrue: [ [self block value] forkAt: self runPriority]
		ifFalse: [ [self object perform: self method] forkAt: self runPriority].
	self parent queue removeFirst.
	self isPeriodic ifTrue: [self reschedule]
! !

!WebScheduledEvent methodsFor: 'running' stamp: ' 21/4/07 22:07'!
runPriority
	^Processor userBackgroundPriority! !

!WebScheduledEvent methodsFor: 'private-periods' stamp: ' 21/4/07 22:07'!
setPeriodSingle
	self periodType: #single value: nil! !

!WebScheduledEvent methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
timestamp
	"when this event must occur"
	^timestamp! !

!WebScheduledEvent methodsFor: 'private' stamp: 'jm 2/4/2011 21:06'!
timestamp: aSpTimestamp
	timestamp := aSpTimestamp! !

!WebScheduledEvent class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newOn: aScheduler
	^super new parent: aScheduler! !

!WebScheduler methodsFor: 'events-single' stamp: 'jm 4/26/2009 15:41'!
at: aTimestamp callMethod: aSymbol of: anObject
	| event |
	event := WebScheduledEvent newOn: self.
	event at: aTimestamp callMethod: aSymbol of: anObject.
	self scheduleEvent: event.
	^event! !

!WebScheduler methodsFor: 'events-single' stamp: 'jm 4/26/2009 15:41'!
at: aTimestamp runBlock: aBlock
	| event |
	event := WebScheduledEvent newOn: self.
	event at: aTimestamp runBlock: aBlock.
	self scheduleEvent: event.
	^event! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
considerMissedEvents
	"events which we miss to run, eg. if scheduler didn't run for a while"
	self removeMissedEvents "and nothing more, for now"! !

!WebScheduler methodsFor: 'private'!
critical: aBlock
	"run a block in a critical section (only one block at once!!)"
	^self mutex critical: aBlock! !

!WebScheduler methodsFor: 'events-periodic' stamp: 'jm 4/26/2009 15:41'!
everyDayAt: aTimeOrHour runBlock: aBlock
	| event |
	event := WebScheduledEvent newOn: self.
	event everyDayAt: aTimeOrHour runBlock: aBlock.
	self scheduleEvent: event.
	^event! !

!WebScheduler methodsFor: 'events-periodic' stamp: 'jm 4/26/2009 15:41'!
everyHourAt: aMinuteNumber  runBlock: aBlock
	| event |
	event := WebScheduledEvent newOn: self.
	event everyHourAt: aMinuteNumber  runBlock: aBlock.
	self scheduleEvent: event.
	^event! !

!WebScheduler methodsFor: 'events-periodic' stamp: 'jm 4/26/2009 15:41'!
everyMinuteAt: aSecondNumber callMethod: aSymbol of: anObject
	| event |
	event := WebScheduledEvent newOn: self.
	event everyMinuteAt: aSecondNumber callMethod: aSymbol of: anObject.
	self scheduleEvent: event.
	^event! !

!WebScheduler methodsFor: 'events-periodic' stamp: 'jm 4/26/2009 15:42'!
everyMinuteAt: aSecondNumber  runBlock: aBlock
	| event |
	event := WebScheduledEvent newOn: self.
	event everyMinuteAt: aSecondNumber  runBlock: aBlock.
	self scheduleEvent: event.
	^event! !

!WebScheduler methodsFor: 'events-periodic' stamp: ' 21/4/07 22:07'!
everyMonthday: aDayNumber at: aTime  runBlock: aBlock! !

!WebScheduler methodsFor: 'events-periodic' stamp: ' 21/4/07 22:07'!
everyWeekday: aDaySymbol at: aTime  runBlock: aBlock! !

!WebScheduler methodsFor: 'initialize-release'!
initMutex
	mutex := AidaMutex new! !

!WebScheduler methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initQueue
	queue := OrderedCollection new.! !

!WebScheduler methodsFor: 'private' stamp: 'jm 2/7/2011 13:39'!
insertToQueueEvent: aScheduledEvent
	self critical:
		[self queue isEmpty ifTrue: [^self queue add: aScheduledEvent].
		aScheduledEvent timestamp >= self queue last timestamp
			ifTrue: [^self queue add: aScheduledEvent].
		aScheduledEvent timestamp < self queue first timestamp 
			ifTrue: [^self queue addFirst: aScheduledEvent].
		self queue size to: 1 by: -1 do: [:inx |
			aScheduledEvent timestamp >= (queue at: inx) timestamp ifTrue: 
				[^self queue add: aScheduledEvent beforeIndex: inx+1] ].
		self error: 'rescheduling error!!'.  "in case any of above conditions don't satisfy"
		]! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
isLoopRunning
	^self loop notNil! !

!WebScheduler methodsFor: 'testing'!
isScheduledBlock: aBlock
	"is this block aready scheduled in some event?"
	^self queue contains: [:event | event block = aBlock]! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
loop
	^loop! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
loop: aProcess
	loop := aProcess! !

!WebScheduler methodsFor: 'private'!
mutex
	"for protecting critical sections"
	mutex isNil ifTrue: [self initMutex].
	^mutex! !

!WebScheduler methodsFor: 'private'!
mutex: anAidaMutex
	mutex := anAidaMutex! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
printString
	^'aScheduler on site: ', (self site notNil ifTrue: [self site name] ifFalse: [''])! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
queue
	"queue of events next one to run on first place"
	queue isNil ifTrue: [self initQueue].
	^queue! !

!WebScheduler methodsFor: 'events-single' stamp: 'jm 2/7/2011 13:39'!
removeEvent: anEvent
	"stop running  this single or periodic event"
	self critical: 
		[self queue 
			remove: anEvent
			ifAbsent: [self error: 'Scheduler: this event does not exist'] ]! !

!WebScheduler methodsFor: 'private' stamp: 'jm 2/7/2011 13:39'!
removeMissedEvents
	| now event |
	self critical:
		[self queue isEmpty ifTrue: [^nil].
		now := SpTimestamp now asSeconds.
		[now > self queue first timestamp asSeconds] whileTrue:
			[event := self queue first.
			self queue removeFirst.
			event isPeriodic ifTrue: [event reschedule].
			self queue isEmpty ifTrue: [^nil] ]
		]! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
scheduleEvent: aScheduledEvent
	self insertToQueueEvent: aScheduledEvent.! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
schedulerPriority
	^Processor userInterruptPriority! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
site
	^site! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
site: anAIDASite
	site := anAIDASite! !

!WebScheduler methodsFor: 'start/stop' stamp: ' 21/4/07 22:07'!
start
	self considerMissedEvents.
	self startLoop! !

!WebScheduler methodsFor: 'private' stamp: 'jm 2/7/2011 13:40'!
startLoop
	"to check every second if some event is to be run"
	self isLoopRunning ifTrue: [self stopLoop].
	self loop: 
		([ [true] whileTrue: 
			[| event now |
			self critical: 
				[self queue notEmpty ifTrue:
					[event := self queue first. now := SpTimestamp now asSeconds.
				 	now = event timestamp asSeconds
						ifTrue:  [event run]  "and reschedule if periodic event"
						ifFalse: [now > event timestamp asSeconds  ifTrue: [self removeMissedEvents]].
					[self queue notEmpty and: [now = self queue first timestamp asSeconds]]  "run all events on the same time"
						whileTrue: [self queue first run]
				 ]].
			(Delay forSeconds: 1) wait]   "check every second"
		] forkAt: self schedulerPriority)! !

!WebScheduler methodsFor: 'start/stop'!
stop
	self stopLoop.
	self mutex: nil! !

!WebScheduler methodsFor: 'private' stamp: ' 21/4/07 22:07'!
stopLoop
	self loop notNil ifTrue: [self loop terminate. self loop: nil].! !

!WebScheduler class methodsFor: 'instance creation'!
newOn: anAIDASite
	^super new site: anAIDASite! !

!WebScript methodsFor: 'private'!
changeContextFrom: oldCtx to: newCtx
	"scan for all references to context ids and change them. Also in subelements"
	| in out aidaCtx sep |
	aidaCtx := WebContext contextIdName.
	(('*', aidaCtx, '*') match: self script) ifFalse: [^nil].
	in := self script readStream. out := WriteStream on: String new.
	[in atEnd] whileFalse: 
		[out nextPutAll: (in upTo: aidaCtx). 
		in atEnd not ifTrue: 
			[in skip "=". sep := in upTo: $&.
			out nextPutAll: aidaCtx, '=', newCtx id printString, sep ] ].
	self script: out contents! !

!WebScript methodsFor: 'private'!
hasTag
	^true! !

!WebScript methodsFor: 'private'!
includesScriptTag
	"if script starts and ends with a script tag. Otherwise we add it by ourselves"
	^'<script*' match: self script! !

!WebScript methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
script
	^script! !

!WebScript methodsFor: 'accessing'!
script: aString
	"add to others if already exists, separate with JavaScript separator ; "
	script isNil ifTrue: [script := ''].
	(script notEmpty and: [script last ~= $; ]) ifTrue: [script := script, '; '].
	script := script, aString trimBlanks.! !

!WebScript methodsFor: 'accessing'!
source
	"URL of external script source, if any"
	^source! !

!WebScript methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	| existScriptTag |
	existScriptTag := self includesScriptTag. "don't add script tag if script already have it!! "
	existScriptTag ifFalse: [aStream nextPutAll: '<script type="text/javascript"'].
	self source notNil ifTrue: 
		[aStream nextPutAll: ' src="', self source, '"'].
	existScriptTag ifFalse: [aStream nextPutAll: '>']. 
	self script notNil ifTrue: [aStream nextPutAll: script].
	existScriptTag ifFalse: [aStream nextPutAll: '</script>'].
	aStream nextPutAll: self eol.! !

!WebScript class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
script: aString
	^super new script: aString! !

!WebScript class methodsFor: 'instance creation' stamp: 'mivsek 1/10/2008 19:38'!
source: anURLString
	"and external script, with an Url to it"
	^super new source: anURLString! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
accessByObject 
	"this is a dictionary of user - access level pairs for access to the object, 
	which reference is a key in dictionary"
	accessByObject isNil ifTrue: [self initAccessByObject].
	^accessByObject! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
accessRightsArray: anAccessSymbols for: aWebUserOrGroup on: anObject
	| objectRights rigthsArray |
	self site critical:
		[objectRights := self accessByObject at: anObject 
			ifAbsent: 
				[self accessByObject at: anObject put: (Dictionary new).
				self accessByObject at: anObject].
		rigthsArray := objectRights at: aWebUserOrGroup 
			ifAbsent:
				[objectRights at: aWebUserOrGroup put: IdentitySet new.
				objectRights at: aWebUserOrGroup].
		rigthsArray addAll: anAccessSymbols].! !

!WebSecurityManager methodsFor: 'access control' stamp: ' 21/4/07 22:07'!
accessRightsFor: aWebUserOrGroup on: anObject
	"get the access rights for specified user or group on object  as literal array of 
	rights (e.g. #(#read #write). " 
	^(self accessByObject at: anObject 
		ifAbsent: [^self defaultAccessRights])
			at: aWebUserOrGroup ifAbsent:  [^self defaultAccessRights]! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
activatingGroup
	"group for users to confirm registration"
	^self groups detect: [:each | each isActivatingGroup] ifNone: [nil].! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
addActivatingUser: aWebUser
	"add this user also to group waiting for confirmation"
	self addUser: aWebUser.
	self activatingGroup addUser: aWebUser.! !

!WebSecurityManager methodsFor: 'group management'!
addGroup: aWebUserGroup
	^self addGroup: aWebUserGroup ifExist: [^nil].! !

!WebSecurityManager methodsFor: 'private'!
addGroup: aWebUserGroup ifExist: aBlock
	"add new group. If already exist ( as object or as group with the same name) do aBlock"
 	(aWebUserGroup isKindOf: WebUserGroup) ifFalse: [^self error: 'This is not aWebUserGroup'].
	(self existGroupNamed: aWebUserGroup name) ifTrue: [aBlock value].
	^self groups add: aWebUserGroup! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
addGroupNamed: aString
 	"add new group with a specified name. If already exist, error"
	self addGroup: (WebUserGroup new name: aString).! !

!WebSecurityManager methodsFor: 'user management'!
addPerson: aPerson
	"make parallel WebUser, cross-connect both and put into Registered group"
	"by default username and password are aPerson surname!!"
	| user |
	aPerson asWebUser notNil ifTrue: [^self error: 'already added!!'].
	user := self site webUserClass new.
	user username: aPerson surname.
	user password: aPerson surname.
	(self addRegisteredUser: user) notNil "no duplicates in username"
		ifTrue: [ aPerson webUser: user. user person: aPerson]
		ifFalse: [^nil].
	^aPerson! !

!WebSecurityManager methodsFor: 'user management'!
addRegisteredUser: aWebUser
	"add this user also to registered users group. Remove him from activating group"
	self addUser: aWebUser.
	self registeredGroup addUser: aWebUser.
	self activatingGroup removeUser: aWebUser.
	aWebUser setRegisteredTimestamp.! !

!WebSecurityManager methodsFor: 'user management'!
addUser: aWebUser
	"add new user also in All Users group"
	(aWebUser isKindOf: WebUser) ifFalse: [^self error: 'This is not aWebUser'].
	(self users includes: aWebUser) ifTrue: [^nil].
	(self existUserNamed: aWebUser username withPassword: aWebUser password) ifTrue: [^nil]. 
	self users add: aWebUser.
	self allUsersGroup addUser: aWebUser.
	aWebUser parent: self.
	^aWebUser! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
adminGroup
	"group for admins, those who have all acess rights !! "
	^self groups detect: [:each | each isAdminGroup] ifNone: [nil].! !

!WebSecurityManager methodsFor: 'user management'!
adminUser
	"first admin user, initialy it is with username 'admin'"
	^self users 
		detect: [:each | each isAdminUser] 
		ifNone: [self error: 'Admin user missing?']! !

!WebSecurityManager methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allGroups
	^self groups copy! !

!WebSecurityManager methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allUsers
	^self users copy! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
allUsersGroup
	"group for all users in system"
	^self groups detect: [:each | each isAllUsersGroup] ifNone: [nil].! !

!WebSecurityManager methodsFor: 'access control'!
allowViews: viewSymbols andUpdates: updateSymbols for: aWebUserOrGroup on: anAppClass
	"those views and updates(actions) are allowed for that user or group on that App class"
	| viewRightSymbols updateRightSymbols |
	viewRightSymbols := viewSymbols collect: [:each | anAppClass viewRightSymbolFor: each].
	self setAccessRights: viewRightSymbols for: aWebUserOrGroup on: anAppClass name.
	updateRightSymbols := updateSymbols collect: [:each | anAppClass updateRightSymbolFor: each].
	self setAccessRights: updateRightSymbols for: aWebUserOrGroup on: anAppClass name.! !

!WebSecurityManager methodsFor: 'settings'!
allowedIPs
	"whitelist: a collection of IP addresses, from which login is allowed. Star can be used, like 12.234.*  "
	^self settings at: #AllowedIPs ifAbsentPut: [OrderedCollection new]! !

!WebSecurityManager methodsFor: 'settings'!
allowedIPs: aCollectionOfStrings
	"whitelist: a collection of IP addresses, from which login is allowed. Star can be used, like 12.234.*  "
	^self settings at: #AllowedIPs put: aCollectionOfStrings! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
authenticationScheme
	"#Form - with WebAdminApp login form - default!!
	#HttpBasic - rfc2617 Basic authentication - passwords NOT encrypted!!
	#HttpDigest - rfc2617 Digest authentication - encrypted passwords
	#SSLClientCertificate - most secure, user needs a valid PKI certificate"
	authenticationScheme isNil ifTrue: [self setFormAuthenticationScheme].
	^authenticationScheme! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
authenticationScheme: aSymbol
	authenticationScheme := aSymbol! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
copyAccessByObject
 
|dict|
Janko := Dictionary new.
WebSecurityManager default accessByObject 
keysAndValuesDo:
	[:key :value | 
		dict := Dictionary new.
		value keysAndValuesDo: [:key1 :value1 |
			dict at: key1 put: (IdentitySet withAll: (value1 collect: [:el | el asString asSymbol] )) ].
		Janko at: key put: dict].! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
defaultAccessRights
	
	^#()! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
existGroupNamed: aString
	^(self groupNamed: aString) notNil! !

!WebSecurityManager methodsFor: 'user management'!
existUserNamed: anUsernameString 
	^(self userNamed: anUsernameString) notNil! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
existUserNamed: anUsernameString withPassword: aPasswordString
	^(self userNamed: anUsernameString withPassword: aPasswordString) notNil! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
existUserWithId: aNumber
	^self users contains: [:each | each id = aNumber].! !

!WebSecurityManager methodsFor: 'user management'!
extranetUser
	"a common extranet user, for easier setup of access rights"
	^self users detect: [:each | each isExtranetUser] ifNone: [nil]! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
groupNamed: aString
	aString isEmpty ifTrue: [^nil].
	^self groups detect: [:group | group name =  aString] ifNone: [nil]! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
groupWithUuid: aString
	" find and return a group with specified uuid. Return nil if not found" 
	^self groups detect: [:each | each uuid = aString] ifNone: [nil]! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
groups 
	groups isNil ifTrue: [self initGroups].
	^groups! !

!WebSecurityManager methodsFor: 'user management'!
guestUser
	"actually only one is guest user"
	^self users 
		detect: [:each | each isGuest] 
		ifNone: [self error: 'Guest user missing?']! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
has: aWebUserOrGroup rightTo: anAccessSymbol on: anObject 
	"test the access right for that object and that user or group "
	| usersAndGroups |
	usersAndGroups := self accessByObject at: anObject ifAbsent: [^false].
	(usersAndGroups includesKey: aWebUserOrGroup)	ifTrue:
		[((usersAndGroups at: aWebUserOrGroup) includes: anAccessSymbol) ifTrue: [^true] ].
	^false! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
hasFormAuthenticationScheme
	^self authenticationScheme = #Form! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
hasHttpAuthenticationScheme
	^self hasHttpBasicAuthenticationScheme | self hasHttpDigestAuthenticationScheme! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
hasHttpBasicAuthenticationScheme
	^self authenticationScheme = #HttpBasic! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
hasHttpDigestAuthenticationScheme
	^self authenticationScheme = #HttpDigest! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
hasSSLClientCertificateAuthenticationScheme
	^self authenticationScheme = #SSLClientCertificate! !

!WebSecurityManager methodsFor: 'access control' stamp: ' 21/4/07 22:07'!
hasUser: aWebUser rightInAnyGroupTo: anAccessSymbol on: anObject 
	"test the access right for that object and in groups for that user"
	aWebUser groups do: [:group |
		(self has: group rightTo: anAccessSymbol on: anObject) ifTrue: [^true] ].
	^(self has: self allUsersGroup rightTo: anAccessSymbol on: anObject)! !

!WebSecurityManager methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initAccessByObject
	accessByObject := Dictionary new.! !

!WebSecurityManager methodsFor: 'initialize-release' stamp: 'mivsek 6/13/2007 16:00'!
initAdminAccess
	"admin group has rights to all views and updates in all Apps!! "
	WebApplication allowAllViewsFor: self adminGroup on: self site.
	WebApplication allowAllUpdatesFor: self adminGroup  on: self site.! !

!WebSecurityManager methodsFor: 'initialize-release'!
initAdminUser
	"add default admin user"
	| user |
	(self users detect: [:each | each isAdminUser] ifNone: [nil] )
		notNil ifTrue: [^nil].
	user := WebUser newAdmin.
	user setLocked. "to avoid name/username changes"
	self addUser: user.
	self adminGroup addUser: user.! !

!WebSecurityManager methodsFor: 'initialize-release'!
initDefaultAccessRights
	"to allow login, registering new user etc"
	self allowViews: #(login logout forgoten registration passwordSent waitingConfirmation activation 
						wakeupScriptaculous wakeupRichEditor
						loginGoogle loginGoogle2 loginGoogle3 logoutGoogle) "OpenID login" 
		andUpdates: #(login registration passwordSent)
		for: self allUsersGroup on: WebAdminApp.
	self allowViews: #(main activationRequest activate) andUpdates:  #(main) 
		for: self allUsersGroup on: WebRegistrationApp.

"AIDASite allInstances do: [:each | each securityManager initDefaultAccessRights]"! !

!WebSecurityManager methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initDefaultGroups
	self addGroup: WebUserGroup newAllUsers.
	self users do: [:user | 	self allUsersGroup addUser: user].
	self addGroup: WebUserGroup newAdmin.
	self addGroup: WebUserGroup newRegistered.
	self addGroup: WebUserGroup newActivating.
	self postInitDefaultGroups.  "override this method for your own default groups"! !

!WebSecurityManager methodsFor: 'initialize-release'!
initDefaultSettings! !

!WebSecurityManager methodsFor: 'initialize-release'!
initDemoAccessRights
	"access to all for demos in WebDemoApp"
	"(AIDASite named: 'aidademo') securityManager initDemoAccessRights"
	self allowViews: WebDemoApp allViews asArray 
		andUpdates:  #(editMembers fileUpload gridSelected webdav controlFlow) 
		for: self allUsersGroup on: WebDemoApp.! !

!WebSecurityManager methodsFor: 'initialize-release'!
initExtranetAccessRights
	"for extranet user"! !

!WebSecurityManager methodsFor: 'initialize-release'!
initExtranetUser
	"add default extranet user"
	| user |
	(self users detect: [:each | each isExtranetUser and: [each name = WebUser extranetName]] 
		ifNone: [nil] )
			notNil ifTrue: [^nil].
	user := WebUser newExtranet.
	user setLocked. "to avoid name/username changes"
	self addUser: user.
	self registeredGroup addUser: user.! !

!WebSecurityManager methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initGroups
	groups := Set new.! !

!WebSecurityManager methodsFor: 'initialize-release' stamp: 'mivsek 1/10/2008 19:22'!
initGuestAccessRights
	"for guest user"! !

!WebSecurityManager methodsFor: 'initialize-release'!
initGuestUser
	"add new user,with name 'Guest'"
	| user |
	(self users detect: [:each | each isGuest] ifNone: [nil] ) notNil ifTrue: [^nil].
	user := WebUser newGuest.
	user setLocked. "to avoid name/username changes"
	self addUser: user.
	self allUsersGroup addUser: user.! !

!WebSecurityManager methodsFor: 'initialize-release'!
initUsers
	users := Set new. 
	self groups do: [:each | each initUsers]. "to delete all potential users in those groups!!"! !

!WebSecurityManager methodsFor: 'initialize-release'!
initialize
	self initUsers.
	self initGroups.
	self initAccessByObject.
	self initDefaultGroups; lockDefaultGroups.
	self initAdminUser. self initGuestUser. self initExtranetUser.
	self initDefaultAccessRights. self initDemoAccessRights.
	self initAdminAccess. self initGuestAccessRights. self initExtranetAccessRights.! !

!WebSecurityManager methodsFor: 'settings'!
ipFilterPolicy
	"what to do if IP is on blacklist or whitelist"
	^self settings at: #ipFilterPolicy ifAbsentPut: [#warn]! !

!WebSecurityManager methodsFor: 'settings'!
ipFilterPolicy: aSymbol
	"what to do if IP is on blacklist or whitelist"
	"(AIDASite named: 'aidademo') securityManager ipFilterPolicy: #deny "
	(#(#none #warn #deny) includes: aSymbol) ifFalse: [self error: 'unkown IP filter policy'].
	^self settings at: #ipFilterPolicy put: aSymbol! !

!WebSecurityManager methodsFor: 'access control'!
isAclSetFor: aUserOrGroup on: anAppClass
	| aclDict aclSet |
	aclDict := self accessByObject at: anAppClass name ifAbsent: [^false].
	aclSet := aclDict at: aUserOrGroup ifAbsent: [^false].
	^aclSet notEmpty! !

!WebSecurityManager methodsFor: 'authentication'!
isAllowedToLoginIP: anIPString
	self allowedIPs isEmpty ifTrue: [^true].
	self isIpFilterPolicyNone ifTrue: [^true].
	^self allowedIPs contains: [:ip | ip trimBlanks notEmpty and: [ip match: anIPString] ]! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
isDefaultAllowedTo: anAccessSymbol 
	"default access right for all objects and all users"
	^self defaultAccessRights includes: anAccessSymbol! !

!WebSecurityManager methodsFor: 'filtering'!
isIpFilterPolicyDeny
	"what to do if IP is on blacklist or whitelist"
	^self ipFilterPolicy = #deny! !

!WebSecurityManager methodsFor: 'filtering'!
isIpFilterPolicyNone
	"what to do if IP is on blacklist or whitelist"
	^self ipFilterPolicy = #none! !

!WebSecurityManager methodsFor: 'filtering'!
isIpFilterPolicyWarn
	"what to do if IP is on blacklist or whitelist"
	^self ipFilterPolicy = #warn! !

!WebSecurityManager methodsFor: 'access control' stamp: ' 21/4/07 22:07'!
isUser: aWebUser allowedTo: anAccessSymbol on: anObject 
	"test the access right for that object and that user or groups for that user"
	(self has: aWebUser rightTo: anAccessSymbol on: anObject) ifTrue: [^true].
	^(self hasUser: aWebUser rightInAnyGroupTo: anAccessSymbol on: anObject)! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
isUser: aWebUser inGroup: aWebGroup
	"test if user is member of this group"
	^aWebGroup includes: aWebUser! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
isUser: aWebUser inGroupNamed: aString
	| group |
	group := self groupNamed: aString.
	group isNil ifTrue: [^false].
	^group includes: aWebUser! !

!WebSecurityManager methodsFor: 'initialize-release'!
lockDefaultGroups
	"to avoid name change or delete of default groups"
	"AIDASite allInstances do: [:each | each securityManager lockDefaultGroups]"
	self allUsersGroup setLocked.
	self adminGroup setLocked.
	self registeredGroup setLocked.
	self activatingGroup setLocked.
	self allUsersGroup setLocked.! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
migrateAppClassessToSymbols
	"do not use app classes but their names as symbols"

	self accessByObject keys do: [:obj |
		((obj isKindOf: Behavior) and: [obj includesBehavior: WebApplication]) ifTrue: [
			self accessByObject 
				at: obj name 
				put: (self accessByObject at: obj).
			self accessByObject removeKey: obj] ].

"WebSecurityManager default migrateAppClassessToSymbols"! !

!WebSecurityManager methodsFor: 'private' stamp: 'mivsek 3/7/2008 23:03'!
migrateToEncryptedPasswords
	"if not already"
	self allUsers do: [:each | each password size ~= 48 ifTrue: [each password: each password] ]

"WebSecurityManager allInstances do: [:each | each migrateToEncryptedPasswords] "
"WebSecurityManager hashPassword: 'aaaaaaaaa' "! !

!WebSecurityManager methodsFor: 'private'!
migrateToLockedReservedUsers
	"to preserve them by not allowing changes"
	"WebSecurityManager allInstances do: [:each | each migrateToLockedReservedUsers] "	
	| user |
	user := self adminUser.
	user isNil ifTrue: [self initAdminUser. user := self adminUser].
	user setLocked.
	user := self guestUser.
	user isNil ifTrue: [self initGuestUser. user := self guestUser].
	user setLocked.
	user := self extranetUser.
	user isNil ifTrue: [self initExtranetUser. user := self extranetUser].
	user setLocked.! !

!WebSecurityManager methodsFor: 'private'!
migrateUrlsForUsersAndGroups
	"WebSecurityManager allInstances do: [:each | each migrateUrlsForUsersAndGroups] "
	self site isNil ifTrue: [^nil].	
	self users do: [:each | self site urlResolver changeToPreferredUrl: each].
	self groups do: [:each | self site urlResolver changeToPreferredUrl: each].! !

!WebSecurityManager methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
postInitDefaultGroups
	"override this method for your own default groups"! !

!WebSecurityManager methodsFor: 'private'!
preferredUrl
	^'/security'! !

!WebSecurityManager methodsFor: 'private'!
printString
	^'WebSecurityManager on: ', self site name! !

!WebSecurityManager methodsFor: 'private'!
reconnectUsersToGroups
	"if user groups don't match group users"
	"AIDASite default securityManager reconnectUsersToGroups"
	self users do: [:user |
		user groups do: [:group | (group includes: user) ifFalse: [group addUser: user] ] ].
	self groups do: [:group |
		group users do: [:user | (self users includes: user) ifFalse: [self addUser: user] ] ]! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
registeredGroup
	"group for registered users"
	^self groups detect: [:each | each isRegisteredGroup] ifNone: [nil].! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
removeAccessRightArray: anAccessSymbols for: aWebUserOrGroup and: anObject 
	"remove all specified access rigths for specified user or group on specified object"
	self site critical:
		[((self accessByObject at: anObject ifAbsent: [^self])
			at: aWebUserOrGroup ifAbsent: [^self])	removeAll: anAccessSymbols].! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
removeAccessRightArray: anAccessSymbols for: aWebUserOrGroup on: anObject 
	"remove all specified access rigths for specified user or group on specified object"
	| usrGrps rights |
	self site critical:
		[usrGrps := self accessByObject at: anObject ifAbsent: [^self].
		rights := usrGrps at: aWebUserOrGroup ifAbsent: [^self].
		anAccessSymbols do: [:each | rights remove: each ifAbsent: [] ] ].! !

!WebSecurityManager methodsFor: 'access control' stamp: ' 21/4/07 22:07'!
removeAccessRights: anAccessSymbol for: aWebUserOrGroup on: anObject 
	"remove all specified access rigths for specified user or group on specified object"
	| access |
	(anAccessSymbol isKindOf: Array)
		ifTrue: [access := anAccessSymbol ]
		ifFalse: [access := Array with: anAccessSymbol].
	self removeAccessRightArray: access for: aWebUserOrGroup on: anObject! !

!WebSecurityManager methodsFor: 'access control' stamp: ' 21/4/07 22:07'!
removeAllAccessRightsFor: aWebUserOrGroup 
	self accessByObject keys do: [:object |
		self 
			removeAllAccessRightsFor: aWebUserOrGroup 
			on: object]! !

!WebSecurityManager methodsFor: 'access control' stamp: ' 21/4/07 22:07'!
removeAllAccessRightsFor: aWebUserOrGroup on: anObject 
	self site critical:
		[(self accessByObject at: anObject ifAbsent: [^self])
			removeKey: aWebUserOrGroup ifAbsent: [^self] ].! !

!WebSecurityManager methodsFor: 'access control' stamp: ' 21/4/07 22:07'!
removeAllAccessRightsForObject: anObject 
	self site critical:
		[self accessByObject removeKey: anObject ifAbsent: []	].! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
removeGroup: aWebUserGroup
	"remove group, if exist. If not exist do nothing" 
	self removeGroup: aWebUserGroup ifAbsent: [].! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
removeGroup: aWebUserGroup ifAbsent: aBlock
	"remove group, if exist. If not exist do aBlock. You cannot remove group AllUsers!!" 
	aWebUserGroup isAllUsersGroup ifTrue: [^self error: 'group AllUsers cannot be removed!!'].
	(self groups includes: aWebUserGroup) ifFalse: [^aBlock value].
	self groups remove: aWebUserGroup.
	aWebUserGroup allUsers do: [:each | aWebUserGroup removeUser: each].
	self removeAllAccessRightsFor: aWebUserGroup! !

!WebSecurityManager methodsFor: 'group management' stamp: ' 21/4/07 22:07'!
removeGroupNamed:  aString 
	| group |
	group := self groupNamed: aString.
	group notNil ifTrue: [self removeGroup: group]! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
removeUser: aWebUser
	"remove user, if exist" 
	(self users includes: aWebUser) ifFalse: [^nil].
	self users remove: aWebUser.
	self allGroups do: [:group | group removeUser: aWebUser].
	self removeAllAccessRightsFor: aWebUser! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
removeUserNamed:  anUsername withPassword: aPassword
	| user |
	user := self userNamed: anUsername withPassword: aPassword.
	self removeUser: user! !

!WebSecurityManager methodsFor: 'access control' stamp: ' 21/4/07 22:07'!
setAccessRights: anAccessSymbols for: aWebUserOrGroup on: anObject
	"set the access rights for specified user or group on object. it can be only one right 
	or an literal array of rights (e.g.#(#read #write) ) " 
	| access |
	aWebUserOrGroup isNil ifTrue: [^self error: 'User is nil'].
	access := (anAccessSymbols isKindOf: Array) 
		ifTrue: [anAccessSymbols ] 
		ifFalse: [Array with: anAccessSymbols].
	self accessRightsArray: access for: aWebUserOrGroup on: anObject.! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
setFormAuthenticationScheme
	"AIDASite default securityManager setFormAuthenticationScheme"
	self authenticationScheme: #Form! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
setHttpBasicAuthenticationScheme
	"AIDASite default securityManager setHttpBasicAuthenticationScheme"
	self authenticationScheme: #HttpBasic! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
setHttpDigestAuthenticationScheme
	"AIDASite default securityManager setHttpDigestAuthenticationScheme"
	self authenticationScheme: #HttpDigest! !

!WebSecurityManager methodsFor: 'authentication' stamp: ' 21/4/07 22:07'!
setSSLClientCertificateAuthenticationScheme
	"AIDASite default securityManager setSSLClientCertificateAuthenticationScheme"
	self authenticationScheme: #SSLClientCertificate! !

!WebSecurityManager methodsFor: 'private'!
settings
	settings isNil ifTrue: 
		[settings := Dictionary new. 
		self initDefaultSettings].
	^settings

"WebServer default settings"! !

!WebSecurityManager methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
site
	"a parent site using that security manager"
	^site! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
site: anAIDASite
	site := anAIDASite.! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
userNamed: anUsernameString
	" find and return a WebUser with username . Return nil if not found"
	"WebSecurityManager default userNamed: 'mivsek'"
 	(anUsernameString ~= '') ifFalse: [^nil].
	^self users 
		detect: [:user | (user username asLowercase = anUsernameString asLowercase)] ifNone: [nil]! !

!WebSecurityManager methodsFor: 'user management' stamp: 'janko 10/28/2011 11:52'!
userNamed: anUsernameString withPassword: aPasswordString
	" find and return a WebUser with username and password. Return nil if not found"
 	(anUsernameString isNil  | aPasswordString isNil) ifTrue: [^nil].
 	((anUsernameString = '') | (aPasswordString = '')) ifTrue: [^nil].
	^self users detect: [:user | 
		(user username asLowercase = anUsernameString asLowercase) and: 
			[user password = (WebSecurityManager hashPassword: aPasswordString)]] 
				ifNone: [nil]
! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
userWithEMail: aString
	" find and return a WebUser with specified email. Return nil if not found" 
	(aString ~= '') ifFalse: [^nil]. 
	^self users detect: [:user | user email asLowercase = aString asLowercase ] ifNone: [^nil]! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
userWithId: aNumber
	^self users detect: [:each | each id = aNumber] ifNone: [nil]! !

!WebSecurityManager methodsFor: 'user management' stamp: 'np 3/16/2009 13:04'!
userWithName: aNameString surname: aSurnameString
	" find and return a WebUser with name and surname. Return nil if not found"
 	(aNameString ~= '') | (aNameString ~= '') ifFalse: [^nil].
	^self users detect: [:user | 
		(user name asLowercase = aNameString asLowercase) and: 
			[user surname asLowercase = aSurnameString asLowercase]] 
				ifNone: [nil]! !

!WebSecurityManager methodsFor: 'user management' stamp: ' 21/4/07 22:07'!
userWithUuid: aString
	" find and return a WebUser with specified uuid. Return nil if not found" 
	^self users detect: [:each | each uuid = aString] ifNone: [nil]! !

!WebSecurityManager methodsFor: 'private' stamp: ' 21/4/07 22:07'!
users 
	users isNil ifTrue: [self initUsers].
	^users! !

!WebSecurityManager class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
default 
	^AIDASite default securityManager! !

!WebSecurityManager class methodsFor: 'hashing' stamp: 'jm 12/14/2010 23:32'!
hashPassword: aString
	"Squeak specific"
	"Returns a hashed string, used to store and compare passwords in a secure way"
	^(SecureHashAlgorithm new 
			hashMessage: (AIDASite convert: aString toCodepage: #UTF8) )
				asString! !

!WebSecurityManager class methodsFor: 'instance creation' stamp: 'mivsek 1/10/2008 19:01'!
newOn: anAIDASite
	^super basicNew 
		site: anAIDASite.
		"initialize"  "do that separately, otherwise it drops in indefinitive recursion"! !

!WebSecurityTest methodsFor: 'running' stamp: 'mivsek 8/22/2007 21:20'!
setUp
"TOO DANGEROUS!!!!!!
	server := Swazoo.SwazooServer singleton.
	server initialize.  ""to remove all stuff and stop it""
	site := AIDASite newNamed: 'test'.
	mgr := site securityManager.
"! !

!WebSecurityTest methodsFor: 'running' stamp: 'mivsek 8/22/2007 21:20'!
tearDown
"	site := server siteNamed: 'test'.
	site stop.
	server removeSite: site.
	server := nil. site := nil. mgr := nil.
"! !

!WebSecurityTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 21:21'!
testGroups
"	| group |
	self assert: (mgr groups size = 2). ""AllUsers and Admins""
	group := WebUserGroup new name: 'test'.
	self deny: (mgr existGroupNamed: 'test').
	mgr addGroup: group.
	self assert: (mgr existGroupNamed: 'test').
	self assert: (mgr groups size = 3). 
	mgr addGroupNamed: 'test'. ""duplicate test""
	self assert: (mgr groups size = 3).
	mgr removeGroupNamed: 'test'.
	self assert: (mgr groups size = 2).
"! !

!WebSecurityTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 21:21'!
testInitialize
"	self assert: mgr users size = 1.
	self assert: mgr groups size = 2.  ""Admininstrators and AllUsers""
	self assert: (mgr existUserNamed: 'admin' withPassword: 'password').
	self assert: (mgr existGroupNamed: 'Administrators').
	self assert: (mgr existGroupNamed: 'AllUsers').
"! !

!WebSecurityTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 21:22'!
testMultipleAccessRights
"	| object right1 right2 user |
	right1 := #AllowThat. right2 := #AllowThatToo.
	object := #JustSomething.
	user := mgr adminUser.
	self deny: (mgr has: user rightTo: right1 on: object).
	self deny: (mgr has: user rightTo: right2 on: object).
	mgr setAccessRights: (Array with: right1 with: right2) for: mgr adminUser on: object.
	self assert: (mgr has:user rightTo: right1 on: object).
	self assert: (mgr has: user rightTo: right2 on: object).
	mgr removeAccessRights: (Array with: right1 with: right2) for: mgr adminUser on: object.
	self deny: (mgr has: user rightTo: right1 on: object).
	self deny: (mgr has: user rightTo: right2 on: object).
"! !

!WebSecurityTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 21:22'!
testSimpleAccessRight
"	| right object user |
	right := #AllowThat.
	object := #JustSomething.
	user := mgr adminUser.
	self deny: (mgr has: user rightTo: right on: object).
	mgr setAccessRights: right for: mgr adminUser on: object.
	self assert: (mgr has:user rightTo: right on: object).
	mgr removeAccessRights: right for: mgr adminUser on: object.
	self deny: (mgr has: user rightTo: right on: object).
"! !

!WebSecurityTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 21:23'!
testUsers
"	| user |
	self assert: (mgr users size = 1). ""only admin user""
	user := WebUser new username: 'test'; password: 'test'; email: 'a@a.si'.
	self deny: (mgr existUserNamed: 'test' withPassword: 'test').
	mgr addUser: user.
	self assert: (mgr existUserNamed: 'test' withPassword: 'test').
	self assert: (mgr users size = 2). 
	mgr addUser: user. ""duplicate test""
	self assert: (mgr users size = 2).
	mgr removeUserNamed: 'test' withPassword: 'test'.
	self assert: (mgr users size = 1).
"! !

!WebSeparator methodsFor: 'private'!
hasTag
	^true! !

!WebSeparator methodsFor: 'private'!
shouldIdent
	^self type ~= #break! !

!WebSeparator methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
size: aNumber
	"size of a ruler"
	self attributesAt: #size put: aNumber printString.! !

!WebSeparator methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	| tag |
	self prepareToHtmlStreamingOn: aSession. 
	type = #paragraph ifTrue: [tag := 'p'].
	type = #break ifTrue: [tag := 'br'].
	type = #ruler ifTrue: [tag := 'hr'].
	aStream nextPutAll: self ident, '<', tag.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: self tagClosing, self eol.! !

!WebSeparator methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
type
	^type! !

!WebSeparator methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
type: aSymbol
	"#ruler #paragraph #break"
	type := aSymbol.! !

!WebSeparator class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
break
	
	^ self new type: #break! !

!WebSeparator class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
paragraph
	
	^ self new type: #paragraph! !

!WebSeparator class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
rulerSize: aNumber
	
	^(self new) type: #ruler; size: aNumber! !

!WebSession methodsFor: 'private-app state'!
addApp: anApplication for: anObject type: aSymbol
	"web or wap apps, type can be #web or #wap "
	| objDict |
	objDict := self appsForObjects at: anObject ifAbsentPut: [Dictionary new].
	^objDict at: aSymbol put: anApplication! !

!WebSession methodsFor: 'private' stamp: ' 21/4/07 22:07'!
addSessionID
	"add session id to  parms dictionary. Url with session id looks like: 	http://www.tris-a.si/welcome.html?id=523453. This should be done for every automaticaly 
	generated url (WebLink printHTMLPage) to distinguish sesions among themselves."
	self parms at: 'id' put: self id printString.! !

!WebSession methodsFor: 'private-app state' stamp: ' 21/4/07 22:07'!
addWebApp: aWebApplication for: anObject
	^self addApp: aWebApplication for: anObject type: #web! !

!WebSession methodsFor: 'security-login'!
adminAllowed
	"check if general administration is allowed for user on our session"
	^self site securityManager
		isUser: self user
		inGroupNamed: self site securityManager adminGroup name! !

!WebSession methodsFor: 'private-serving' stamp: 'janko 4/25/2012 10:59'!
aidaIsRespondingStreamed
	"to simulate WebPAge, see AIDASite answer:toGetoOrPost:on:"
	^false! !

!WebSession methodsFor: 'private-serving'!
aidaPresenterFor: aRequest on: aSession
	| event |
	aRequest isWebSocketRequest ifTrue: 
		["Transcript cr; show: '** new WebSocket on ', self site name ,' from ', aRequest peer. "
		^self]. "upgrade to WebSocket request on /aidasession/websocket, see printHTMLPage.."
	 '/aidasession/comet' = aRequest uriString ifTrue: 
		[^self realtimeHandler respondToCometRequest: aRequest].
	('/aidasession/element-*' match: aRequest uriString) ifTrue: 
		[^self respondToElementDirectRequest: aRequest].  "direct Ajax request to some element of a webpage"
"	aRequest uriString = '/aidasession/ajax' ifFalse: 
		[(Delay forSeconds: 1) wait. ^self]. "  "WebSocket over Squid proxy troubles!!"
	aRequest isPost not ifTrue: [^WebPage new]. "JSON msg is in body of post request"
	event := WebEvent fromJSON: (aRequest ensureFullRead; entityBody) on: aSession.
	(event context notNil and: [event element notNil]) ifTrue:
		[event app respondToEvent: event].
	"next, streaming step occurs in printHTMLPageOnfor:to: "! !

!WebSession methodsFor: 'private-app state' stamp: ' 21/4/07 22:07'!
appFor: anObject type: aSymbol 
	^(self appsForObjects at: anObject ifAbsent: [^nil]) 
		at: aSymbol ifAbsent: [^nil]! !

!WebSession methodsFor: 'private-app state' stamp: ' 21/4/07 22:07'!
appsForObjects
	
	appsForObjects isNil ifTrue: [self initAppsForObjects].
	^appsForObjects! !

!WebSession methodsFor: 'security-login'!
authenticateFrom: aRequest
	"try to login with username and password from request (rfc2617)"
	| usr |
	aRequest username isNil ifTrue: [^nil].
	usr := self site securityManager userNamed: aRequest username.
	usr isNil ifTrue: [^nil].
	(aRequest matchUserWithPassword: usr password) 
		ifTrue: [self loginUser: usr] ifFalse: [self logout].! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
browser
	
	"try to find out, which browser a web request originator is using. It can be #Netscape, #IBM, #Microsoft, #lynx, #Mosaic.  Returns #Unknown if not possible to find out the browser type"

	| partOfString |
	self browserString = '' ifTrue: [^#Unknown].
	partOfString := self browserString copyFrom: 1 to: 6.
	partOfString = 'Mozill' ifTrue: [^#Netscape].
	partOfString = '' ifTrue: [^#Microsoft].
	partOfString = 'IBM-We' ifTrue: [^#IBM].
	partOfString = '' ifTrue: [^#Lynx].
	partOfString = '' ifTrue: [^#Mosaic].! !

!WebSession methodsFor: 'accessing'!
browserString
	"return the string, whick browser sends as identification in a web request"
	self lastRequest isNil ifTrue: [^''].
	^self lastRequest userAgent.! !

!WebSession methodsFor: 'security-login'!
checkExpirationAndPossiblyLogoutFor: aRequest
	"don't logout if request is POST on the same object (eg. after long editing)"
	self isLoggedIn ifFalse: [^self].
	(self site autoLogout or: [self user autoLogout]) ifFalse: [^self].
	(self isExpired and: [aRequest isPost not]) ifTrue: 
		[self logout.
		(self site admin aidaWebAppFor: self) 
			showError: self site style sessionTimeoutText].! !

!WebSession methodsFor: 'private-serving' stamp: 'janko 8/19/2011 22:13'!
cleanupQueue
	"remove stalled commands like those on inactive apps or views"
	self queue copy do: [:cmd |
		( (#(#update) includes: cmd command) and:
			[cmd app isNil or: 
				[cmd app isActive not or: [(cmd app isActiveView: cmd view) not]]])
					ifTrue: [self queue remove: cmd] ].
	self queue size > 1000 ifTrue: "something is wrong!!"
		[Transcript cr; show: '*** Queue too long, reinitializing on ', self user username.
		self initQueue]! !

!WebSession methodsFor: 'accessing-other'!
clipboard
	"for cut/copy/paste references to web pages to easier hyperlink them"
	^self otherAt: #clipboard ifAbsent: [self initClipboard].! !

!WebSession methodsFor: 'locale support' stamp: ' 21/4/07 22:07'!
codePage
	^#'UTF_8' "always!!"! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
cookie
	"true if web request in this nonsecure session uses cookies, false otherwise"
	^self cookies at: 1.! !

!WebSession methodsFor: 'private'!
cookie: aBoolean
	self cookies 	at: 1 put: aBoolean! !

!WebSession methodsFor: 'private' stamp: ' 21/4/07 22:07'!
cookies
	cookies isNil ifTrue: [self initCookies].
	^cookies! !

!WebSession methodsFor: 'locale support'!
country
	^self otherAt: #Country ifAbsent: [nil]! !

!WebSession methodsFor: 'locale support'!
country: aSymbol
	"set the country of a web request originator in ISO 2letter format"
	^self otherAt: #Country put: aSymbol! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
created

	"return the timestamp of a session creation."

	^created! !

!WebSession methodsFor: 'accessing'!
createdTimestampText
	^self created printSloString! !

!WebSession methodsFor: 'private'!
existsJson
	"exists JSON support in user's browser?"
	^self otherAt: #JsonExists ifAbsent: [false]! !

!WebSession methodsFor: 'private'!
fullUrlForCurrentPage
	"composes and returns a full url for a curent requested page. If parms dictionary is changed, 
	then a query string with changed parameters is generated. Usefull for presenting the same 
	page in a different way by parameteres in query string"
	^self lastRequest urlString! !

!WebSession methodsFor: 'accessing-other'!
geolocation
	"Geolocation of user's browser, if any"
	^self otherAt: #geolocation ifAbsent: [nil]! !

!WebSession methodsFor: 'private'!
geolocation: aWebGeolocation
	"Geolocation of user's browser"
	^self otherAt: #geolocation put: aWebGeolocation! !

!WebSession methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
hasSecureCookie
	"check if secure cookie is already set on secure part of session"
	^self secureCookie! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
id

	"return the unique identification of a nonsecure session to browser. This is a random generated number at session generation. It can be used for session tracking in URLs, forms, etc."

	^self ids at: 1! !

!WebSession methodsFor: 'private'!
id: aNumber
	"return the unique identification of a nonsecure session. This is a random generated number 
	at session generation. It can be used for session tracking in URLs, forms, etc."
	self ids at: 1 put: aNumber.! !

!WebSession methodsFor: 'private' stamp: ' 21/4/07 22:07'!
ids
	ids isNil ifTrue: [self initIds].
	^ids! !

!WebSession methodsFor: 'session modes'!
inAdminMode
	"is session in admin mode?"
	^(self otherAt: #sessionMode) = #admin! !

!WebSession methodsFor: 'session modes'!
inDevMode
	"is session in developers mode?"
	^(self otherAt: #sessionMode) = #dev! !

!WebSession methodsFor: 'session modes'!
inNormalMode
	"is session in normal users mode?"
	^(self otherAt: #sessionMode) = #normal! !

!WebSession methodsFor: 'session modes'!
inTranslationMode
	"should text in your Apps be in-place edited for translation?"
	^self inAdminMode or: [self inDevMode]! !

!WebSession methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initAppsForObjects
	appsForObjects := IdentityDictionary new.! !

!WebSession methodsFor: 'initialize-release'!
initClipboard
	^self otherAt: #clipboard put: WebClipboard new! !

!WebSession methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initCookies
	cookies := Array with: false with: false.! !

!WebSession methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initIds
	ids := Array new: 2.! !

!WebSession methodsFor: 'initialize-release'!
initLoginHistory
	^self otherAt: #LoginHistory put: DailyCollection new! !

!WebSession methodsFor: 'initialize-release'!
initOther
	other := Dictionary new! !

!WebSession methodsFor: 'initialize-release'!
initParms
	^self otherAt: #parms put: Dictionary new.! !

!WebSession methodsFor: 'initialize-release'!
initQueue
	"for sending commands back to browser"
	queue := OrderedCollection new.! !

!WebSession methodsFor: 'initialize-release'!
initRealtimeConnections
	^self otherAt: #RealtimeConnections put: OrderedCollection new! !

!WebSession methodsFor: 'initialize-release'!
initRequests
	^self otherAt: #requests put: OrderedCollection new.! !

!WebSession methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initUser
	self user: self site securityManager guestUser! !

!WebSession methodsFor: 'initialize-release'!
initUserValues
	userValues := Dictionary new! !

!WebSession methodsFor: 'accessing-other'!
initialIP
	"from which user came when session was created. It can change later for mobile users!!"
	^self sessionIPs notEmpty 
		ifTrue: [self sessionIPs first]
		ifFalse: ['']! !

!WebSession methodsFor: 'initialize-release'!
initialize
	self setRandomIds.
	self setCreatedTimestamp.
	self initCookies.
	self initParms.
	self initRequests.
	self initUser.
	self setNormalMode. 
	self initAppsForObjects.! !

!WebSession methodsFor: 'testing' stamp: 'np 9/4/2008 16:21'!
isActive

	"active if at least one request received last hour"

	self lastRequest isNil ifTrue: [^false].
	^(SpTimestamp now asSeconds - self lastRequest timestamp asSeconds) < 3600! !

!WebSession methodsFor: 'testing-user agent'!
isBrowserSupported
	"advanced functions like Ajax supported in this browser?"
	"Test for JSON support or IE8 and newer for now"
	| supported version |
	supported := self otherAt: #BrowserSupported ifAbsentPut:
		[supported := self existsJson ifTrue: [true] ifFalse: 
			[self isFromMSIE 
				ifTrue:
					[version := self lastRequest userAgent readStream upToAll: 'MSIE'; upTo: $ ; upTo: $. .
"					Transcript cr; show: ('*** ? browser: ', self lastRequest userAgent, ' from: ', self user username). "
					version asInteger >= 8]
				ifFalse: [true] ]. "for now"
		supported].
	supported ifFalse: [self other removeKey: #BrowserSupported]. "to always recheck"
	^supported

"
('Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB6.6; .NET CLR 2.0.50727; .NET CLR 1.1.4322; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)'  readStream upToAll: 'MSIE'; upTo: $ ; upTo: $.) asInteger
"! !

!WebSession methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isEncrypted
	^self lastRequest isEncrypted "for now!! "! !

!WebSession methodsFor: 'testing' stamp: 'np 9/4/2008 16:21'!
isExpired
	"more than 15min of inactivity"
	self lastRequest isNil ifTrue: [^false].
	^(SpTimestamp now asSeconds - self lastRequest timestamp asSeconds) > (15*60)! !

!WebSession methodsFor: 'testing-user agent'!
isFromLinux
	^self lastRequest isFromLinux! !

!WebSession methodsFor: 'testing-user agent'!
isFromMSIE
	^self lastRequest isFromMSIE! !

!WebSession methodsFor: 'testing-user agent'!
isFromNetscape
	".. or Moziila or Firefox"
	^self lastRequest isFromNetscape! !

!WebSession methodsFor: 'testing-user agent'!
isFromWindows
	^self lastRequest isFromWindows! !

!WebSession methodsFor: 'testing'!
isGuest
	"user is Guest - anonymous, not logged in"
	^self user isNil or: [self user isGuest]! !

!WebSession methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isHttpAuthenticationNeeded
	"Usually we authenticate by WebAdminApp logon form. But if site is configured for HTTP 	authentication (to open a separate username/password dialog window to user), and 
	a session is not yet logged in, this method will return true"
	^self isLoggedIn not and: [self site securityManager hasHttpAuthenticationScheme]! !

!WebSession methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isLoggedIn
	^self user notNil and: [self user isGuest not]! !

!WebSession methodsFor: 'testing-user agent'!
isMobile
	"a session from mobile device: phone, tablet, .."
	| request userAgent |
	request := self lastRequest. request isNil ifTrue: [^false].
	userAgent := request userAgent.  userAgent isNil ifTrue: [^false].
	( '*Android*' match: userAgent) ifTrue: [^true]. "Android device"
	( '*Symbian*' match: userAgent) ifTrue: [^true]. "Symbian device"
	( 'BlackBerry*' match: userAgent) ifTrue: [^true]. "BlackBerry device"
	('*iPhone*' match: userAgent) ifTrue: [^true].  "iPhone"
	('*iPad*' match: userAgent) ifTrue: [^true].  "iPad"
	^false! !

!WebSession methodsFor: 'testing-user agent'!
isMobilePhone
	"a session from mobile phone"
	^self isMobileTablet not and: [self isMobile]! !

!WebSession methodsFor: 'testing-user agent'!
isMobileTablet
	"a session from mobile tablet (bigger screen than phone)"
	self lastRequest isNil ifTrue: [^false].
	( '*Android*SPH*Mobile*' match: self lastRequest userAgent) ifTrue: [^true]. "Galaxy Tab"
	('*iPad*' match: self lastRequest userAgent) ifTrue: [^true].  "iPad"
	^false! !

!WebSession methodsFor: 'testing'!
isNew
	"this is first request and cookie not set on the browser yet"
	^self cookie not "enough?"! !

!WebSession methodsFor: 'testing'!
isRemoteGuest
	"access from outside via Proxy, not yet logged in"
	^self user isGuest
		and: [self lastRequest isForwarded ]! !

!WebSession methodsFor: 'locale support'!
language
	"preferred language of a web user. Initialy set from the last request (lazily, when first needed)"
	^self otherAt: #Language ifAbsent:
		[self lastRequest notNil 
			ifTrue: [self language: (self originatorLanguageFrom: self lastRequest)]
			ifFalse: [nil] ]! !

!WebSession methodsFor: 'locale support'!
language: aLanguageCodeSymbol
	"preferred language of a web user. Initialy set from the last request (lazily, when first needed)"
	^self otherAt: #Language put: aLanguageCodeSymbol! !

!WebSession methodsFor: 'locale support'!
languageBasic
	" if a combined code (like 'en-us'), return only basic lanuage (like 'en' for 'en-us')"
	^(self language asString includes: $- )
		ifTrue: [self language asString readStream upTo: $- ]
		ifFalse: [self language]! !

!WebSession methodsFor: 'accessing-other'!
lastActivity
	"the last activity (request) timestamp"
	^self otherAt: #lastActivityTimestamp ifAbsent: [nil]! !

!WebSession methodsFor: 'accessing-other'!
lastActivityText
	"the last activity (request) timestamp"
	^self lastActivity notNil
		ifTrue: [self lastActivity printSloString]
		ifFalse: ['']! !

!WebSession methodsFor: 'accessing-other'!
lastApp
	"return WebApplication subclass which was called with last request"
	^self otherAt: #lastApp! !

!WebSession methodsFor: 'accessing-other'!
lastApp: anApplication
	self otherAt: #lastApp put: anApplication! !

!WebSession methodsFor: 'accessing-other'!
lastRequest
	"the last, actualy current request pending. also add request to the history in a request 
	if logging is on."
	"BE CAREFULL!! more than one request can be processed concurrently, so don't count 
	that last reques is actually a current one too!! It mostly is, but not always!!"
	^self otherAt: #lastRequest! !

!WebSession methodsFor: 'accessing-other'!
lastRequest: aRequest
	"remember the last, actualy current request pending. also add request to the history in a request 
	if logging is on. If first request then also try to find country, language and codePage 
	of the originator"
	self otherAt: #lastRequest put: aRequest.  
	self initParms.				      "clear old parameters"
	self newView: (aRequest queryAt: #view ifAbsent: ['']).  "default new view is view from last request"! !

!WebSession methodsFor: 'accessing-other'!
lastView
	"return a view of WebApllication, which is created in response to last request"
	^self otherAt: #lastView! !

!WebSession methodsFor: 'accessing-other'!
lastView: aSymbol
	self otherAt: #lastView put: aSymbol! !

!WebSession methodsFor: 'private' stamp: 'jm 9/8/2010 21:09'!
logLoginOf: aWebUser
	self loginHistory
		add: (Array with: #login with: aWebUser with: SpTimestamp now)
		onDate: SpDate today! !

!WebSession methodsFor: 'private' stamp: 'jm 9/8/2010 21:10'!
logLogoutOf: aWebUser
	self loginHistory 
		add: (Array with: #logout with: aWebUser with: SpTimestamp now)
		onDate: SpDate today! !

!WebSession methodsFor: 'accessing-other'!
loginHistory
	"occurences of user logged it/out. As DailyCollection of Array #login/logout, WebUser, timestamp"
	^self otherAt: #LoginHistory ifAbsent: [self initLoginHistory]! !

!WebSession methodsFor: 'accessing'!
loginStateText
	"login, logout, guest"
	(self isGuest and: [self neverLoggedIn]) ifTrue: [^'guest'].
	self isLoggedIn ifTrue: [^'login'].
	^'logout'! !

!WebSession methodsFor: 'accessing'!
loginUser
	"user logged now or in a past"
	(self isGuest and: [self neverLoggedIn]) ifTrue: [^nil].
	self isLoggedIn ifTrue: [^self user].
	^self loginHistory all first at: 2! !

!WebSession methodsFor: 'security-login'!
loginUser: aWebUser
"	(self site securityManager isAllowedToLoginIP: self lastRequest peer) 
		ifFalse: [^self error: 'From this IP not allowed to login!!'].
"	self user: aWebUser.
	self logLoginOf: aWebUser.
	aWebUser inAdminGroup ifTrue: [aWebUser escalateToAdmin]. "temporary, otherwise rather unescalate!!"
	aWebUser logLogin.! !

!WebSession methodsFor: 'security-login'!
loginUserNamed: aUsernameString withPassword: aPasswordString 
	"will fail if username or password wrong!!"
	| usr |
	usr := self site securityManager userNamed: aUsernameString withPassword: aPasswordString.
	usr isNil ifTrue: [self error: 'User withat username/password combination does not exist'].
	self loginUser: usr! !

!WebSession methodsFor: 'accessing'!
loginUserText
	"user logged now or in a past"
	| usr |
	usr := self loginUser. 
	usr isNil ifTrue: [^''].
	^usr nameSurname! !

!WebSession methodsFor: 'security-login'!
loginUserWithName: aNameString surname: aSurnameString 
	| usr |
	usr := self site securityManager userWithName: aNameString surname: aSurnameString.
	usr notNil ifTrue: [self loginUser: usr]! !

!WebSession methodsFor: 'security-login'!
logout
	"Replace logged user with Guest. Remember last page to return after login again"
	| origin usr |
	self redirectLink: nil. 	self redirectOrigin: nil.
	self isLoggedIn 
		ifTrue: 
			[usr := self user. self initUser. 
			usr isEscalatedToAdmin ifTrue: [usr unEscalateFromAdmin].
			self logLogoutOf: usr. usr logLogout] 
		ifFalse: [^nil].
	origin := usr lastAppUrl. 
	(origin isNil or: [self lastRequest notNil and: [origin = self lastRequest uriString]])  ifFalse: 
		[usr logoutFromUrl: origin]. "to jump back after login"! !

!WebSession methodsFor: 'testing'!
neverLoggedIn
	^self loginHistory isEmpty! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
newView

	"return a value of a 'view' parameter in query part of a URL to be generated. Also used for changing views in a state machine for web applications (in method actionFormForm (here is set) and method printWebPage (here is used to genererate appropriate page))"

	^self parms at: 'view' ifAbsent: [^''].! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
newView: aString
	"set a value of a 'view' parameter in query part of a URL to be generated. Also used for changing 
	views in a state machine for web applications (in method actionFormForm (here is set) and method 	printWebPage (here is used to genererate appropriate page))"
	((aString = '') or: [aString isNil]) ifFalse: [self parms at: 'view' put: aString ].! !

!WebSession methodsFor: 'initialize-release'!
nilLastApp
	self other notNil ifTrue: [self other removeKey: #lastApp ifAbsent: [nil] ]! !

!WebSession methodsFor: 'initialize-release'!
nilLastRequest
	self other notNil ifTrue: [self other removeKey: #lastRequest ifAbsent: [nil] ]! !

!WebSession methodsFor: 'private-serving'!
notifyQueueAddition
	"to send added command immediatelly if some realtime channel is open, otherwise 
	wait for current or next request"
	self cleanupQueue. "of stalled commands like those on inactive apps or views"
	self realtimeHandler sendMesagesFromQueue. "and clear sent msgs from queue"! !

!WebSession methodsFor: 'locale support' stamp: ' 21/4/07 22:07'!
originatorCountryFrom: aRequest
	"find an ISO country code from a web request"
	"not yet implemented!!"! !

!WebSession methodsFor: 'locale support' stamp: 'mu 4/6/2008 10:55'!
originatorLanguageFrom: aRequest
	"find a language from a web request"
	| defaultLang header |
	defaultLang := self site defaultLanguage.
	header := aRequest headerAt: 'Accept-Language' ifAbsent:[^defaultLang].
	header values isEmpty ifFalse: [^(header values at: 1) asSymbol].
	^defaultLang! !

!WebSession methodsFor: 'private-other'!
other
	^other! !

!WebSession methodsFor: 'private-other'!
otherAt: aSymbol
	"other values"
	^self otherAt: aSymbol ifAbsent: [nil]! !

!WebSession methodsFor: 'private-other'!
otherAt: aSymbol ifAbsent: aBlock
	"other values"
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!WebSession methodsFor: 'private-other'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!WebSession methodsFor: 'private-other'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!WebSession methodsFor: 'private-serving'!
packToJSONMessages: aCollection "of WebCommands"
	"convert commands to an array of JSON"
	^'[', (aCollection 
		inject: ''
		into: [:jsonString :command || separator |
			separator := command = aCollection last ifFalse: [','] ifTrue: [''].
			jsonString, command asJSON, separator]),
	  ']'! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
parent
	"a session manager !! "
	^parent! !

!WebSession methodsFor: 'private' stamp: ' 21/4/07 22:07'!
parent: aWebSessionManager
	parent := aWebSessionManager.! !

!WebSession methodsFor: 'accessing-other'!
parms
	"This is a dictionary of parameters in query part of url. When web request arrives, parameters 
 	from query string are written here. When any url is dynamically generated, those parms are 
	appended to it as a query string. You can add, change or delete any parameter to better 
	suit your needs (eg. view=brief to instruct brief view of an object) "
	^self otherAt: #parms! !

!WebSession methodsFor: 'private'!
printString
^'aWebSession
	ip: ', (self lastRequest notNil ifTrue: [self lastRequest peer] ifFalse: ['']), '
	user: ', self user username, ' (', self user nameSurname, ')
	created: ', self created printSloString, '
	last:      ', (self lastRequest notNil ifTrue: [self lastRequest timestamp printSloString] ifFalse: ['']), ''! !

!WebSession methodsFor: 'private-serving'!
queue
	"for sending commands back to browser"
	queue isNil ifTrue: [self initQueue].
	^queue! !

!WebSession methodsFor: 'private-serving'!
queueCommand: aWebCommand
	self queue add: aWebCommand.
	self notifyQueueAddition.! !

!WebSession methodsFor: 'private-serving'!
queueUpdateElement: anElement
	"this element is to be updated on the browser, stream it to a WebCommand and put into waiting queue"
	| stream stripped toUpdate |
	stream := WriteStream on: String new.
	stripped := anElement isWrapped 
		ifFalse: [anElement copy noDiv; nilAttributes]  "just plain element, no div,  to send its inner html only"
		ifTrue: [anElement parent copy]. "wrapped <span> element"
	stripped streamHtmlTo: stream for: nil on: anElement app session.
	toUpdate := anElement isWrapped
		ifFalse: [anElement elementToReplace] "anElement itself, except for popups"
		ifTrue: [anElement parent].  "wrapper <span> element"
	self queueCommand: 
		(WebCommand 
			newUpdate: toUpdate
			with: stream contents).! !

!WebSession methodsFor: 'accessing-other'!
realtimeHandler
	"to handle realtime (WebSocket and Comet) channels on that session"
	^self otherAt: #RealtimeHandler ifAbsentPut: [WebRealtimeHandler newOn: self]! !

!WebSession methodsFor: 'redirection'!
redirectLink
	"if this aWebLink is set, then web browser will recreate another request with url from that link. Used, if you like, after form action in one page to show page for some other object, e.g. if you have search field in page in one object, and search result is exactly one, then you want to show result page immediately. You can do this with this method.
Atribute redirectLink is reset to nil immediately after printWebPage and before printHTMLPage in WebMediator method dicpatchClient (see WebMediator sendResponseHeaderOn:)"
	^self otherAt: #redirectLink! !

!WebSession methodsFor: 'redirection'!
redirectLink: aWebLink
	(aWebLink isKindOf: WebLink) | aWebLink isNil ifFalse: [^nil].
	self otherAt: #redirectLink put: aWebLink.! !

!WebSession methodsFor: 'redirection'!
redirectOrigin
	"this is an URL from where the redirection request originates. Used for returning back from
	exception page, for example when you want to see page without access rights, then you are
	redirected to login page. after successfull login, you are redirected back to intended page.
	Redirect origin is set up automatically by redirectLink: request."
	^self otherAt: #redirectOrigin! !

!WebSession methodsFor: 'redirection'!
redirectOrigin: anUrlString
	self otherAt: #redirectOrigin put: anUrlString.! !

!WebSession methodsFor: 'redirection'!
redirectToOrigin
	"Used for returning back from
	exception page, for example when you want to see page without access rights, then you are
      redirected to login page. after successfull login, you are redirected back to intended page.
	Redirect origin is set up automatically by redirectLink: request."
	self redirectOrigin notNil ifTrue:
		[self redirectLink: (WebLink text: '' linkTo: self redirectOrigin).
		self redirectOrigin: nil].! !

!WebSession methodsFor: 'private'!
registerIP
	"add IP address of user's computer to the list, if not there already"	
	| ip |
	self lastRequest isNil ifTrue: [^nil].
	ip := self lastRequest peer.
	self initialIP = ip ifFalse:   "new session or session from new IP (like mobile user)"
		[(self sessionIPs contains: [:existing | existing = ip])
			ifFalse: [self sessionIPs add: ip] ]! !

!WebSession methodsFor: 'releasing state'!
releaseApplicationState
	self removeAppsForObjects.
	self nilLastRequest.
	self nilLastApp.
	self initQueue.
	self initRequests.
	self initClipboard.
	self redirectLink: nil; redirectOrigin: nil.
	self realtimeHandler removeAll! !

!WebSession methodsFor: 'private-app state' stamp: ' 21/4/07 22:07'!
removeApp: anApplication for: anObject type: aSymbol
	(self appsForObjects at: anObject ifAbsent: [^nil])
		removeKey: aSymbol ifAbsent: [^nil]! !

!WebSession methodsFor: 'releasing state'!
removeAppsForObjects
	self appsForObjects keysAndValuesDo: [:object :dict |
		(dict includesKey: #web) ifTrue: [(dict at: #web) removeYourself] ].
	self initAppsForObjects! !

!WebSession methodsFor: 'releasing state'!
removeIfNewGuest
	"remove yourself if completelly fresh Guest session, used for DOS attack countermeasures"
	(self isGuest and: [(SpTimestamp now asSeconds - self created asSeconds) < 1])
		ifTrue: [self removeYourself]! !

!WebSession methodsFor: 'releasing state'!
removeYourself
	" .. from session manager"
	self parent notNil ifTrue: [self parent removeSession: self].
	self releaseApplicationState.
	self parent: nil.! !

!WebSession methodsFor: 'accessing-other'!
requestNum
	"return number of all requests up to now on this session"
	^self requests size! !

!WebSession methodsFor: 'accessing-other'!
requests
	"return the history of all requests on this session as ordered collection with the oldest as 
	first and newest as last"
	^self otherAt: #requests ifAbsent: [self initRequests].! !

!WebSession methodsFor: 'private-serving'!
respondToElementDirectRequest: aRequest
	"Direct a request to the specified element of a webpage. Element context id and is 
	found in request's Url, like /aidasession/element-id345-ctx35234"
	| stream id ctxId context element |
	stream := aRequest uriString readStream.
	id := (stream upTo: $-;  upToAll: '-ctx') asSymbol.
	ctxId := (stream next; upToEnd) asInteger.
	context := self lastApp contexts at: ctxId.
	element := context elementId: id.
	^element aidaPresenterFor: aRequest on: self! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
secureCookie
	"true if web request in this secure session uses cookies, false otherwise"
	^self cookies at: 2! !

!WebSession methodsFor: 'private'!
secureCookie: aBoolean
	self cookies at: 2 put: aBoolean! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
secureId

	"return the unique identification of a secure session to browser. This is a random generated number at session generation. It can be used for session tracking in URLs, forms, etc."

	^self ids at: 2! !

!WebSession methodsFor: 'private'!
secureId: aNumber
	"return the unique identification of a secure session. This is a random generated number 
	at session generation. It can be used for session tracking in URLs, forms, etc."
	self ids at: 2 put: aNumber.! !

!WebSession methodsFor: 'accessing-other'!
sessionIPs
	"all IP addresses of this session. Usually one, except for mobile/roaming users and those with dynamic IP"
	^self otherAt: #SessionIPs ifAbsentPut: [OrderedCollection new]! !

!WebSession methodsFor: 'session modes'!
setAdminMode
	"set session to admin mode"
	self user inAdminGroup ifFalse: [^self error: 'user not in Admininistrators group'].
	self otherAt: #sessionMode put: #admin! !

!WebSession methodsFor: 'initialize-release' stamp: 'JM 4/25/2007 21:10'!
setCreatedTimestamp
	created := SpTimestamp now.! !

!WebSession methodsFor: 'session modes'!
setDevMode
	"set session to developers mode"
	self user inAdminGroup ifFalse: [^self error: 'user not Admin!!'].
	self otherAt: #sessionMode put: #dev! !

!WebSession methodsFor: 'private-serving'!
setGeolocationFrom: aRequest
	| location |
	location := WebGeolocation newFromJSON: (aRequest ensureFullRead; entityBody).
	self geolocation: location.! !

!WebSession methodsFor: 'private'!
setJsonExists
	"JSON support exists in user's browser"
	^self otherAt: #JsonExists put: true! !

!WebSession methodsFor: 'private'!
setLastActivity
	"set the last activity (request) timestamp"
	^self otherAt: #lastActivityTimestamp put: SpTimestamp now! !

!WebSession methodsFor: 'session modes'!
setNormalMode
	"set session to normal users mode"
	self otherAt: #sessionMode put: #normal! !

!WebSession methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
setRandomIds
	self id: (Random new next * 1000000000) asInteger.
	self secureId: (Random new next * 1000000000) asInteger.! !

!WebSession methodsFor: 'testing'!
shouldCountRequests
	| policy |
	policy := self site countingPolicy.
	policy = #all ifTrue: [^true].
	policy = #none ifTrue: [^false].
	policy = #onlyGuests ifTrue: [^self user isGuest].
	policy = #excludeAdmins ifTrue: [^self user inAdminGroup not].
	^true! !

!WebSession methodsFor: 'testing'!
shouldLogRequests
	| policy |
	policy := self site loggingPolicy.
	policy = #all ifTrue: [^true].
	policy = #none ifTrue: [^false].
	policy = #onlyGuests ifTrue: [^self user isGuest].
	policy = #excludeAdmins ifTrue: [^self user inAdminGroup not].
	^true! !

!WebSession methodsFor: 'redirection'!
shouldRedirect
	^self redirectLink notNil! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
site
	"a session manager !! "
	^self parent site! !

!WebSession methodsFor: 'private-serving'!
streamAjaxResponseOn: aStream for: aRequest on: aWebSession
	| jsonString |
	jsonString := self packToJSONMessages: self queue.
	aStream nextPutAll:  jsonString.
"	aStream nextPutAll:  (AIDASite convert: jsonString toCodepage: #UTF8). "
	self initQueue.! !

!WebSession methodsFor: 'private-serving'!
streamEmptyResponseOn: aStream for: aRequest on: aWebSession
	"respond only 200 ok"! !

!WebSession methodsFor: 'private-serving'!
streamHtmlTo: aStream for: aRequest on: aWebSession
	| url |
	url := aRequest urlString readStream upTo: $? .
	url = '/aidasession/ajax' ifTrue:    "Ajax response with JSON commands"
		[^self streamAjaxResponseOn: aStream for: aRequest on: aWebSession]. 
	url = '/aidasession/websocket' ifTrue:   "upgrade to WebSocket request"
		[^self realtimeHandler streamWebSocketOn: aStream for: aRequest on: aWebSession]. 
	url = '/aidasession/comet' ifTrue:   "long polling Ajax Comet"
		[^self realtimeHandler streamCometOn: aStream for: aRequest on: aWebSession]. 
	url = '/aidasession/geolocation' ifTrue:   "geolocation of browser received"
		[self setGeolocationFrom: aRequest.
		^self streamEmptyResponseOn: aStream for: aRequest on: aWebSession]. 
	^self error: 'unknown request'.! !

!WebSession methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
user
	user isNil ifTrue: [self initUser].
	^user! !

!WebSession methodsFor: 'private'!
user: aWebUser
	"set a reference to aWebUser, who is logged into this session"
	user := aWebUser.! !

!WebSession methodsFor: 'user values' stamp: ' 21/4/07 22:07'!
userValueAt: aSymbol
	"anything you need to share among Apps in that seesion, like last selected stuff, etc."
	^self userValueAt: aSymbol ifAbsent: [nil]! !

!WebSession methodsFor: 'user values' stamp: ' 21/4/07 22:07'!
userValueAt: aSymbol ifAbsent: aBlock
	^self userValues at: aSymbol ifAbsent: aBlock! !

!WebSession methodsFor: 'user values' stamp: ' 21/4/07 22:07'!
userValueAt: aSymbol put: anObject
	^self userValues at: aSymbol put: anObject! !

!WebSession methodsFor: 'private'!
userValues
	"return a dictionary with user defined values, which scope is this session. Usr can use it for such 
	things as global navigation, remembering views etc."
	userValues isNil ifTrue: [self initUserValues].
	^userValues! !

!WebSession methodsFor: 'testing'!
wasLoggedInUser: aWebUser
	"or still is"
	self user = aWebUser ifTrue: [^true].
	^self loginHistory all contains: [:record | (record at: 2) = aWebUser]! !

!WebSession methodsFor: 'private-app state' stamp: ' 21/4/07 22:07'!
webAppFor: anObject
	^self appFor: anObject type: #web! !

!WebSession class methodsFor: 'instance creation' stamp: 'mivsek 8/22/2007 21:17'!
new
	^super basicNew.
! !

!WebSession class methodsFor: 'instance creation' stamp: 'JM 4/25/2007 21:21'!
newOn: aWebSessionManager
	"new web session on a specified session manager"
	| session |
	session := super basicNew.
	session parent: aWebSessionManager.
	session initialize.
	^session! !

!WebSessionManager methodsFor: 'accessing'!
activeSessionsForUsername: aString
	"find active sessions for a user with that username"
	"(AIDASite named: 'wikib') sessionManager activeSessionsForUsername: 'mivsek' "
	^self allActiveSessions select: [:each | each user username = aString]! !

!WebSessionManager methodsFor: 'adding-removing' stamp: ' 7/6/08 18:41'!
addSession: aWebSession
	self site critical:
		[self sessions 
			at: aWebSession id put: aWebSession;
			at: aWebSession secureId put: aWebSession]! !

!WebSessionManager methodsFor: 'accessing' stamp: 'np 10/20/2008 13:54'!
allActiveSessions
	^self allSessions select: [:each | each isActive]! !

!WebSessionManager methodsFor: 'accessing'!
allGuestSessions
	"guest and never logged in"
	^self allSessions select: [:each | 
		(each user isNil or: [each user isGuest]) and: [each neverLoggedIn] ].! !

!WebSessionManager methodsFor: 'accessing'!
allLoggedInSessions
	^self allSessions select: [:each | each isLoggedIn]! !

!WebSessionManager methodsFor: 'accessing' stamp: 'janko 10/31/2008 16:04'!
allNonactiveGuestSessions
	"guest sessions nonactive more that one hour"
	^self allGuestSessions select: [:each | each isActive not].! !

!WebSessionManager methodsFor: 'accessing' stamp: ' 7/6/08 18:41'!
allSessions
	^self sessions values asSet  "to remove duplicates because the session id can be double, 
							     one for ssl too!!"! !

!WebSessionManager methodsFor: 'accessing'!
allSessionsForUser: aWebUser
	"all sessions (logged-in or not) for that user"
	^self allSessions select: [:each | 
		each user = aWebUser or: 
			[each isLoggedIn not and: [each wasLoggedInUser: aWebUser] ] ]! !

!WebSessionManager methodsFor: 'accessing'!
allWereLoggedSessions
	"all sessions which were or still are logged in"
	^self allSessions select: [:each |
		each isLoggedIn or: [each neverLoggedIn not] ] "was or still is logged in"! !

!WebSessionManager methodsFor: 'private' stamp: ' 7/6/08 18:41'!
bindSSLSessionFor: aRequest
	"Try to find a session among currently live sessions. It helps with a session id in a query 
	part of url. If not found, or id not in query string, then make a new session"
	| session id |
	id := aRequest queryAt: 'sessionId' ifAbsent: [self error: 'no session id!!'].
	session := (self existSessionWithID: id asInteger)
		ifTrue: [self findSessionWithID: id asInteger]
		ifFalse: [self error: 'no session with that id'].
	session requests size = 1
		ifTrue: [self countNewVisitor]
		ifFalse: 	[self checkAndCountReturningVisitor: session].
	session lastRequest: aRequest.
	(aRequest includesQuery:  'setLanguage') ifTrue:
		[session language: (aRequest queryAt: 'setLanguage') asSymbol].
	^session.! !

!WebSessionManager methodsFor: 'private' stamp: ' 7/6/08 18:41'!
checkAndCountReturningVisitor: aSession
	"returning visitor is those who is not active more than 1h"
	(aSession isActive not and: [aSession requests size > 1]) ifTrue:
		[self site critical: [self site returningVisitorsCounter incCounter] ]! !

!WebSessionManager methodsFor: 'private' stamp: ' 7/6/08 18:41'!
countNewVisitor
	self site critical:
		[self site newVisitorsCounter incCounter]! !

!WebSessionManager methodsFor: 'testing' stamp: ' 7/6/08 18:41'!
existSessionWithID: anIDNumber
	^self sessions includesKey: anIDNumber.
! !

!WebSessionManager methodsFor: 'accessing'!
findAllSessionsWithUsername: aString
	^self sessions values select: [:each | each user username = aString]! !

!WebSessionManager methodsFor: 'adding-removing'!
findOrCreateSessionFor: aRequest
	"Try to find a session among currently live sessions. It helps with a session id in a query 
	part of url. If not found, or id not in query string, then make a new session"
	| session id cookie |
	(self hasSSLBinding: aRequest) ifTrue: [^self bindSSLSessionFor: aRequest].
	(aRequest hasCookie and: [aRequest idFromCookie notNil])
		ifTrue: [id := aRequest idFromCookie. cookie := true. self site log: ' cookie ' ]
		ifFalse: 
			[cookie := false. id := aRequest queryAt: 'id' ifAbsent: [(self newSessionCookie: cookie) id] ].
	session := (self existSessionWithID: id asInteger)
		ifTrue: [self findSessionWithID: id asInteger] 
		ifFalse: [self newSessionCookie: cookie id: id asInteger].
	session requests size = 1 
		ifTrue: [self countNewVisitor] ifFalse: 	[self checkAndCountReturningVisitor: session].
	session checkExpirationAndPossiblyLogoutFor: aRequest.
	session lastRequest: aRequest.  
	session registerIP; setLastActivity.
	session cookie: cookie. 
	(cookie not and: [self site urlsWithSessionId]) ifTrue: [session addSessionID].

	(aRequest includesQuery:  'setLanguage') ifTrue:
		[session language: (aRequest queryAt: 'setLanguage') asSymbol].
	^session.! !

!WebSessionManager methodsFor: 'accessing' stamp: ' 7/6/08 18:41'!
findSessionWithID: anIDNumber
	^self sessions at: anIDNumber ifAbsent: [nil].
! !

!WebSessionManager methodsFor: 'accessing'!
findSessionWithUsername: aString
	^self sessions detect: [:each | each user username = aString] ifNone: [nil].! !

!WebSessionManager methodsFor: 'private' stamp: ' 7/6/08 18:41'!
hasSSLBinding: aRequest
	"if sessionId=456546464 exist in query part of request. This means that this is 
	a SSL session with its own cookie and must be bind to a normal session with sessionId"

	^aRequest isEncrypted and: [aRequest includesQuery: 'sessionId']! !

!WebSessionManager methodsFor: 'initialize-release' stamp: ' 7/6/08 18:41'!
initSessions
	sessions := Dictionary new.! !

!WebSessionManager methodsFor: 'initialize-release' stamp: ' 7/6/08 18:41'!
initialize
	self initSessions.

"WebSessionManager default initialize"! !

!WebSessionManager methodsFor: 'private' stamp: ' 7/6/08 18:41'!
newSessionCookie: aBoolean
	"open and return a fresh new session"
	^self newSessionCookie: aBoolean id: nil! !

!WebSessionManager methodsFor: 'private' stamp: ' 7/6/08 18:41'!
newSessionCookie: aBoolean id: aSessionID
	"open and return a fresh new session"
	| session |
	session := WebSession newOn: self.
	aSessionID notNil ifTrue: [session id: aSessionID].
	self site log: ' new session '.
	self addSession: session.
	session cookie: aBoolean.
	^session! !

!WebSessionManager methodsFor: 'private' stamp: 'janko 3/19/2012 13:21'!
preferredUrl
	^'/sessions'! !

!WebSessionManager methodsFor: 'private'!
printString
	^'WebSessionManager on: ', self site name! !

!WebSessionManager methodsFor: 'adding-removing'!
releaseApplicationState
	"release all application state of sessions"
	^self allSessions do: [:each | each releaseApplicationState].! !

!WebSessionManager methodsFor: 'adding-removing'!
removeGuestSessions
	"all guest (never logged in) sessions"
	^self allGuestSessions do: [:each | 
		each parent == self 
			ifTrue: [each removeYourself] 
			ifFalse: [self removeSession: each] ]. "in which case?"! !

!WebSessionManager methodsFor: 'adding-removing'!
removeNonactiveGuestSessions
	"all guest (never logged in) sessions inactive more than one hour"
	^self allNonactiveGuestSessions do: [:each | 
		each parent == self 
			ifTrue: [each removeYourself] 
			ifFalse: [self removeSession: each] ]. "in which case?"! !

!WebSessionManager methodsFor: 'adding-removing' stamp: ' 7/6/08 18:41'!
removeSession: aWebSession
	"remove from sessions"
	self site critical:
		[self sessions 
			removeKey: aWebSession id ifAbsent: [];
			removeKey: aWebSession secureId ifAbsent: [] ].! !

!WebSessionManager methodsFor: 'private-serving'!
resourceFor: aRequest
	"from router to know, where to route a request. Route it to request's session"
	^aRequest session! !

!WebSessionManager methodsFor: 'private' stamp: ' 7/6/08 18:41'!
sessions
	"dictionary of sessions by session id as the key. Not that session can have two ids, for ssl too!!"
	sessions isNil ifTrue: [self initSessions].
	^sessions! !

!WebSessionManager methodsFor: 'accessing' stamp: ' 7/6/08 18:41'!
site
	^site! !

!WebSessionManager methodsFor: 'private' stamp: ' 7/6/08 18:41'!
site: anAIDASite
	site := anAIDASite.! !

!WebSessionManager class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
default
	^AIDASite default sessionManager! !

!WebSessionManager class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newOn: aSite
	^super new 
		initialize; 
		site: aSite! !

!WebSessionMgmtTest methodsFor: 'running' stamp: 'mivsek 8/22/2007 21:24'!
setUp
"TOO DANGEROUS!!!!!!
	server := Swazoo.SwazooServer singleton.
	server initialize.  ""to remove all stuff and stop it""
	site := AIDASite newNamed: 'test'.
	session := WebSession newOn: site sessionManager.
"! !

!WebSessionMgmtTest methodsFor: 'running' stamp: 'mivsek 8/22/2007 21:24'!
tearDown
"	site := server siteNamed: 'test'.
	site stop.
	server removeSite: site.
	server := nil. site := nil. session := nil.
"! !

!WebSessionMgmtTest methodsFor: 'testing' stamp: 'mivsek 8/22/2007 21:24'!
testSetUp
"	self assert: session notNil "! !

!WebStaticServer methodsFor: 'serving'!
fileProxyForURL: aString
	" Try to find a html file for a specified URL and make aHTMLFileProxy. 
	Returns nil if such a file does not exist. Index content in default WebIndex"
	| add home fname proxy |
	aString isEmpty ifTrue: [^nil].
	(aString last = $/) ifTrue: [add := 'index.htm'] ifFalse: [add := ''].
	home := self site homeDirectory.
	(home last = $/ ) | (home last = $\ ) ifTrue: [home := home copyFrom: 1 to: home size-1].
	fname := home, aString, add.
	SpEnvironment onWindows ifTrue: [fname := fname copyReplaceAll: '/' with: '\'].
	((SpFilename named: fname) exists and: [(SpFilename named: fname) isDirectory not]) ifFalse:
		[fname := fname, 'l'.   ".html instead just .htm"
		(SpFilename named: fname) exists ifFalse: [^nil] ].
	proxy := FileProxy from: fname onSite: self site.
	proxy indexContent.
	^proxy! !

!WebStaticServer methodsFor: 'accessing'!
files
	"a dictionary of urls as keys  and FileProxies as values"
	files ifNil: [self initFiles].
	^files! !

!WebStaticServer methodsFor: 'initialize-release'!
initFiles
	files := Dictionary new! !

!WebStaticServer methodsFor: 'initialize-release'!
initialize
	"put yoursef in a router and remove all files from urlResolver, where are not needed anymore"
	self site router addStaticServerRoute.
	self site urlResolver removeObjectsOfClass: FileProxy.! !

!WebStaticServer methodsFor: 'serving'!
resourceFor: aHTTPRequest
	"returns or creates an instance of FileProxy for requested file. Nil if not exist"
	| url proxy |
	url := AIDASite convertFromWeb: aHTTPRequest uriString on: aHTTPRequest session.  "for international Urls"
	url = '/' ifTrue: [^self resourceForRootUrl].
	^self files at: url ifAbsentPut:
		[proxy := self fileProxyForURL: url.
		proxy ifNil: [^nil].
		proxy]! !

!WebStaticServer methodsFor: 'serving'!
resourceForRootUrl
	"returns or creates an instance of FileProxy for root index.htm or index.html"
	| url proxy |
	url := '/index.htm'.
	proxy := self files at: url ifAbsent: 
		[proxy := self fileProxyForURL: url.
		proxy notNil ifTrue: 
			[self files at: url put: proxy. 
			^proxy]].
	url := '/index.html'.
	^self files at: url ifAbsentPut: 
		[proxy := self fileProxyForURL: url.
		proxy isNil ifTrue: [^nil].
		proxy].! !

!WebStaticServer methodsFor: 'accessing'!
site
	^site! !

!WebStaticServer methodsFor: 'private'!
site: anAIDASite
	site := anAIDASite! !

!WebStaticServer class methodsFor: 'instance creation' stamp: 'jm 9/8/2010 20:49'!
newOn: anAIDASite
	^super basicNew
		site: anAIDASite! !

!WebStatistics methodsFor: 'private-referers' stamp: ' 21/8/07 09:38'!
addNewReferer: anUrlString

	"add new counter to referers dictionary"

	self referers 
		at: anUrlString
		put: WebCounter new.! !

!WebStatistics methodsFor: 'referers' stamp: 'janko 10/31/2008 16:11'!
allRefererCounts
	"return a collection of all referers and their total counts, most counted first"
	| collection |
	collection := OrderedCollection new.
	self referers keysAndValuesDo: [:referer :counter |  
		collection add: (Array 
			with: referer
			with: counter total)].
	^SortedCollection
		withAll: collection
		sortBlock: [:a :b | (a at: 2) > (b at: 2)].

"WebStatistics default allRefererCounts size"! !

!WebStatistics methodsFor: 'referers' stamp: ' 21/8/07 09:38'!
allRefererCountsToday
	"return a collection of today referers and their total counts, most counted first"
	| collection |
	collection := OrderedCollection new.
	self referers keysAndValuesDo: [:referer :counter |  
		collection add: (Array 
			with: referer
			with: counter today)].
	^SortedCollection
		withAll: (collection select: [:each | each value last > 0])
		sortBlock: [:a :b | (a at: 2) > (b at: 2)].

"WebStatistics default allReferersAndCounts"! !

!WebStatistics methodsFor: 'referers' stamp: ' 21/8/07 09:38'!
allRefererCountsWeekly
	"return a collection of current week referers and their total counts, most counted first"
	| collection |
	collection := OrderedCollection new.
	self referers keysAndValuesDo: [:referer :counter |  
		collection add: (Array 
			with: referer
			with: counter weekly)].
	^SortedCollection
		withAll: (collection select: [:each | each value last > 0])
		sortBlock: [:a :b | (a at: 2) > (b at: 2)].

"WebStatistics default allReferersAndCounts"! !

!WebStatistics methodsFor: 'referers' stamp: ' 21/8/07 09:38'!
allRefererCountsYesterday
	"return a collection of yesterday referers and their total counts, most counted first"
	| collection |
	collection := OrderedCollection new.
	self referers keysAndValuesDo: [:referer :counter |  
		collection add: (Array 
			with: referer
			with: counter yesterday)].
	^SortedCollection
		withAll: (collection select: [:each | each value last > 0])
		sortBlock: [:a :b | (a at: 2) > (b at: 2)].

"WebStatistics default allReferersAndCounts"! !

!WebStatistics methodsFor: 'referers' stamp: 'janko 10/31/2008 16:05'!
allReferersJustOneHit
	"return a collection of all referers with just one hit and older that one week"
	| collection secBefore7days |
	secBefore7days := SpTimestamp now asSeconds - (7 * 3600 * 24).
	collection := OrderedCollection new.
	self referers keysAndValuesDo: [:referer :counter |
		(counter total = 1 and: [secBefore7days >= counter started asSeconds ]) ifTrue:
			[collection add: referer] ].
	^collection

"WebStatistics default allReferersJustOneHit size"! !

!WebStatistics methodsFor: 'collecting' stamp: 'mu 4/6/2008 10:16'!
collectStatsFrom: aWebRequest
	| referer |
	referer := AIDASite convert: aWebRequest referer fromCodepage: #UTF8.
	(referer notNil and: [(self isLocalUrl: referer) not]) 
		ifTrue: [self countReferer: referer]! !

!WebStatistics methodsFor: 'private-referers' stamp: ' 21/8/07 09:38'!
countReferer: anUrlString
	| url |
	url := self prepareReferer: anUrlString.
	url isEmpty ifTrue: [^self].
	(self refererOnStopList: url) ifTrue: [^self].
	(self referers includesKey: url)
		ifFalse: [self addNewReferer: url].
	(self referers at: url) incCounter! !

!WebStatistics methodsFor: 'initialize-release' stamp: ' 21/8/07 09:38'!
initRefererStopList
	refererStopList := Set new.
	refererStopList
		add: '[unknown origin]';
		add: 'bookmarks';
		add: 'http://lw2fd.hotmail.msn.com/cgi-bin/getmsg';
		add: 'http://mobitel.sux.nu/cgi-bin/tabla/showpost.pl'.
"AIDASite default statistics initRefererStopList"! !

!WebStatistics methodsFor: 'initialize-release' stamp: ' 21/8/07 09:38'!
initReferers
	referers := Dictionary new.

"AIDASite default statistics initReferers"! !

!WebStatistics methodsFor: 'private' stamp: ' 21/8/07 09:38'!
isLocalUrl: anUrlString
	"true, if this url points to page from this server"
	^self site uriPattern contains: [:siteIdentifier | 
		('http://', siteIdentifier host, '*') match: anUrlString].! !

!WebStatistics methodsFor: 'private' stamp: 'np 10/24/2008 12:52'!
isNewReferer: anUrlString onDate: aDate
	"this referer is new if it occurs for a first time in last 7 days"
	| counter |
	counter := self refererCounterFor: anUrlString.
	^counter isFirstOnDate: aDate sinceDays: 7! !

!WebStatistics methodsFor: 'private-referers' stamp: ' 21/8/07 09:38'!
prepareReferer: anUrlString

	"ingnore all parameters in url"

	^(anUrlString copyUpTo: $?)! !

!WebStatistics methodsFor: 'private-referers' stamp: ' 21/8/07 09:38'!
refererCounterFor: anUrlString

	^self referers at: anUrlString ifAbsent: [^nil]! !

!WebStatistics methodsFor: 'private-referers' stamp: ' 21/8/07 09:38'!
refererOnStopList: anUrlString

	| |
	^self refererStopList includes: anUrlString! !

!WebStatistics methodsFor: 'referers' stamp: ' 21/4/07 22:07'!
refererStopList
	refererStopList isNil ifTrue: [self initRefererStopList].
	^refererStopList! !

!WebStatistics methodsFor: 'referers' stamp: 'janko 10/31/2008 16:07'!
referers
	referers isNil ifTrue: [self initReferers].
	^referers! !

!WebStatistics methodsFor: 'private-referers' stamp: ' 21/8/07 09:38'!
removeReferer: anUrlString

	self referers removeKey: anUrlString ifAbsent: [^self].! !

!WebStatistics methodsFor: 'referers' stamp: 'janko 10/31/2008 16:11'!
removeReferersJustOneHit
	"..and older that 7 days"
	self allReferersJustOneHit do: [:each | self referers removeKey: each]
	
"WebStatistics default removeReferersJustOneHit"! !

!WebStatistics methodsFor: 'private-referers' stamp: ' 21/8/07 09:38'!
removeReferersOnStopList

	self refererStopList do: [:referer |
		self removeReferer: referer]

"WebStatistics default  removeReferersOnStopList"! !

!WebStatistics methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
site
	^site! !

!WebStatistics methodsFor: 'private' stamp: ' 21/8/07 09:38'!
site: anAIDASite
	site := anAIDASite.! !

!WebStatistics class methodsFor: 'log analysis' stamp: ' 21/4/07 22:07'!
analyzeAndStoreLine: aLineAsArray into: aDictionary forDate:aDate

	| datum |
	((aLineAsArray at: 2) > ' ' ) ifTrue:
		[(aLineAsArray at: 2) = '#Date:'
			ifTrue: [datum := self parseDatum: (aLineAsArray at: 3).]
			ifFalse: [datum:=aDate.].
		((aLineAsArray at: 2) copyFrom: 1 to: 1) = '#' ifFalse: 
			[aLineAsArray at: 2 put: 
				(Time readFrom: (ReadStream on: (aLineAsArray at: 2))).
			aLineAsArray at: 1 put: 
				(Timestamp new fromDate: datum andTime: (aLineAsArray at: 2)).
			(aDictionary at:  (aLineAsArray at: 3) ifAbsentPut: [WebCounter new  ] )
				 incCounterOnTimestamp: (aLineAsArray at: 1).
			].
		].
	^datum! !

!WebStatistics class methodsFor: 'log analysis' stamp: ' 21/4/07 22:07'!
bossCountersFromIISLogsIn: aDirectoryString

	" WebStatistics bossCountersFromIISLogsIn: 'h:\winnt\system32\logfiles\w3svc3\temp'  "
	| file boss |
	file := 'LogDict.boss'.
	boss := BinaryObjectStorage onNew: file asFilename writeStream.
	boss nextPut: 
		(self countersFromIISLogsIn: aDirectoryString).
	boss close.! !

!WebStatistics class methodsFor: 'log analysis' stamp: ' 21/4/07 22:07'!
convertFromGMT: aTimestamp

	"IIS logs have time in GMT timezone. Return local time"
	TimeZone reference
		convertGMT: aTimestamp asSeconds
		do: [:date :sec | 	^Timestamp fromDate: date andTime: (Time fromSeconds: sec)]! !

!WebStatistics class methodsFor: 'log analysis' stamp: ' 21/4/07 22:07'!
countUrlsIn: aFileString to: anUrlDictionary

self parseFile: aFileString into: anUrlDictionary.! !

!WebStatistics class methodsFor: 'log analysis' stamp: ' 21/4/07 22:07'!
countersFromIISLogsIn: aDirectoryString

	"return a dictionary (url as key) of counters for urls in all IIS log files in specified directory"
	" WebStatistics countersFromIISLogsIn: 'h:\winnt\system32\logfiles\w3svc8'  "

	| logFiles urlCounters |
	logFiles := aDirectoryString asFilename directoryContents.
	logFiles := SortedCollection
		withAll: logFiles 	sortBlock: [:a :b | a < b].
	urlCounters := Dictionary new.
	logFiles do: [:logFile | 
		" self halt. "
		self countUrlsIn: (aDirectoryString, '\', logFile) to: urlCounters].
	^urlCounters! !

!WebStatistics class methodsFor: 'log analysis' stamp: 'JM 4/26/2007 21:34'!
dateFromFilename: aFilename

	^SpDate 
		newDay: (aFilename tail copyFrom: 7 to: 8) asInteger
		month:(aFilename tail copyFrom: 5 to: 6) asInteger
		year: ((aFilename tail copyFrom: 3 to: 4) asInteger + 2000)! !

!WebStatistics class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
default

	^AIDASite default statistics! !

!WebStatistics class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newOn: anAIDASite
	^super new site: anAIDASite! !

!WebStatistics class methodsFor: 'log analysis' stamp: 'JM 4/26/2007 21:35'!
parseDatum: stringDatum 
	"pretvorimo datum iz formata LLLL-MM-DD v date format
	| tmp | 
	 tmp := DelimitedFile new. 
	Transcript show: (tmp parseDatum: '1999-12-11') printString ; cr  
	"

	| datumStream leto mesec dan |
	datumStream := (stringDatum copyReplaceAll: '-' with: ' ') readStream.
	leto := (self  parseWords: datumStream) asNumber.
	mesec := (self  parseWords: datumStream) asNumber.
	dan := (self  parseWords: datumStream) asNumber.
	^SpDate newDay: dan
		month: mesec
		year: leto! !

!WebStatistics class methodsFor: 'log analysis' stamp: ' 21/4/07 22:07'!
parseFile: aFile 
	"
 	Trenutno opusceno, osnova za parseFile: into:
	WebStatistics parseFile: 'h:\winnt\system32\logfiles\w3svc8\ex990506.log' 
	"

	| logFile stream cr besedeVrstice vrstica stevecBesed |
	cr := Character cr.	" self halt. "
	logFile := aFile asFilename.
	stream := logFile readStream.
	[stream atEnd] whileFalse: 
			[besedeVrstice := Array new: 15.
			stevecBesed := 1.
			vrstica := (stream throughAll: (String with: cr)) readStream.
			[vrstica atEnd] whileFalse: 
					[besedeVrstice at: stevecBesed put: vrstica parseWordsIntoArray.
					stevecBesed := stevecBesed + 1].
			vrstica close].
	stream close! !

!WebStatistics class methodsFor: 'log analysis' stamp: ' 21/4/07 22:07'!
parseFile: aFile into: URLCountDictionary 
	| stream besedeVrstice vrstica stevecBesed datum |
	datum := Date today.
	stream := aFile asFilename readStream.
	[stream atEnd] whileFalse: 
		[besedeVrstice := Array new: 15.
		stevecBesed := 2.
		vrstica := (stream throughAll: (String with: Character cr)) readStream.
		[vrstica atEnd] whileFalse: 
			[besedeVrstice at: stevecBesed put: (self parseWords: vrstica) .
			stevecBesed := stevecBesed + 1].
 		datum:= self analyzeAndStoreLine: besedeVrstice 
			into: URLCountDictionary forDate:datum.
		vrstica close.].
	stream close

	" test lines : 
	Xx := Dictionary new.
	WebStatistics parseFile: 'h:\winnt\system32\logfiles\w3svc8\ex990506.log' into: Xx.
	Transcript show: Xx printString
	"! !

!WebStatistics class methodsFor: 'log analysis' stamp: ' 21/4/07 22:07'!
parseWords: inputStream 
	"Answer the contents of the receiver, up to the next separator  character."

	| aStream |
	aStream := (String new: 200) writeStream.
	inputStream skipSeparators.
	inputStream class endOfStreamSignal handle: [:ex | ex return]
		do: 
			[
			[| char |
			char := inputStream next.
			char isSeparator ifTrue: [^aStream contents] ifFalse: [aStream nextPut: char]]
					repeat].
	^aStream contents! !

!WebStubElement methodsFor: 'printing'!
build
	self clear.
	self setDiv.
	self addComment: 'stub'.! !

!WebStubElement methodsFor: 'testing'!
canUpdate
	"stub element needs to be updated back when closing a popup window"
	^true! !

!WebStubElement methodsFor: 'testing' stamp: 'jm 8/26/2009 15:02'!
isStubElement
	^true! !

!WebStubElement methodsFor: 'attributes'!
noDiv
	"ignore that, stub element must be always DIV"! !

!WebStubElement class methodsFor: 'instance creation'!
newOn: aWebContext
	| instance |
	instance := super new.
	instance 
		creationMethod: #build;
		creationObject: instance;
		creationContext: aWebContext;
		setDiv;
		registerId;
		build.
	^instance! !

!WebTable methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
bgColor: aColorSymbol
	self attributesAt: #bgcolor put: (self colorValue: aColorSymbol)! !

!WebTable methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
border: aNumber
	"set the width of table border. default is 0"
	self attributesAt: #border put: aNumber printString.! !

!WebTable methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
cellPadding: aNumber
	"define spacing between vertically adjacent cells"
	self attributesAt: #cellpadding put: aNumber printString.! !

!WebTable methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
cellSpacing: aNumber
	"define spacing between adjacent cells horizontally"
	self attributesAt: #cellspacing put: aNumber printString.! !

!WebTable methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
color: aColorSymbol
	self	bgColor: aColorSymbol! !

!WebTable methodsFor: 'private'!
hasTag
	^super hasTag! !

!WebTable methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
height: aNumber
	| text |
	text := aNumber <= 1 
			ifTrue: [(aNumber * 100) asInteger printString, '%']
			ifFalse: [aNumber asInteger printString].
	self attributesAt: #height put: text! !

!WebTable methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	"self border: 0."! !

!WebTable methodsFor: 'private'!
shouldIdent
	^true! !

!WebTable methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession. 
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	aStream nextPutAll: self ident, '<table'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '>', self eol.
	super streamHtmlTo: aStream for: aRequest on: aSession.
	aStream nextPutAll: self ident, '</table>', self eol.
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebTable methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
width: aNumber
	"set the width of entire table If nil, then table automaticaly addjust itself. 
	If number is between 0 and 1 then width is percent of document width.
	If number above 1 then width in pixels"
	| text |
	text := aNumber <= 1 
			ifTrue: [(aNumber * 100) asInteger printString, '%']
			ifFalse: [aNumber asInteger printString].
	self attributesAt: #width put: text! !

!WebTable class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebTableCell methodsFor: 'attributes'!
align: aSymbol
	"set a horizontal aligment if cell content. It can be #left, #center #right or #justify"
	(#(left center right justify) includes: aSymbol) ifFalse: [self error: 'wrong align symbol'].
	self attributesAt: #align put: aSymbol asString.! !

!WebTableCell methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
background: aWebImage
	"bachground image"
	self attributesAt: #background put:
		(((aWebImage isKindOf: WebImage) ifTrue: [aWebImage] ifFalse: [WebImage image: aWebImage]) 
			urlOnSession: self session)! !

!WebTableCell methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
bgColor: aColorSymbol
	"set the color of table cell background. It can be in hex format (for example #00FF00) 
	or name of color (for example #White)"
	self attributesAt: #bgcolor put: (self colorValue: aColorSymbol)! !

!WebTableCell methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
color: aColorSymbol
	self	bgColor: aColorSymbol! !

!WebTableCell methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
colspan: aNumber
	"set the number of columns this cell will span"
	self attributesAt: #colspan put: aNumber printString.! !

!WebTableCell methodsFor: 'testing'!
hasTag
	^super hasTag! !

!WebTableCell methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
height: aNumber
	| text |
	text := aNumber <= 1 
			ifTrue: [(aNumber * 100) asInteger printString, '%']
			ifFalse: [aNumber asInteger printString].
	self attributesAt: #height put: text! !

!WebTableCell methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize! !

!WebTableCell methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isTableHeader
	^false! !

!WebTableCell methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
nowrap: aBoolean
	"if true then text is not wrapped in new lines of a cell but a cell is expanded to carry all the text"
	self attributesAt: #nowrap put: aBoolean.! !

!WebTableCell methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
rowspan: aNumber
	"set the number of rows this cell will span"
	self attributesAt: #rowspan put: aNumber printString.! !

!WebTableCell methodsFor: 'attributes' stamp: 'JM 4/26/2007 19:34'!
setHeader
"	self changeClassTo: WebTableHeader"
	self become: (self as: WebTableHeader)! !

!WebTableCell methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebTableCell methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession. 
	aStream nextPutAll: self ident, '<td'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '>'.
	super streamHtmlTo: aStream for: aRequest on: aSession.
	aStream nextPutAll: self ident, '</td>', self eol.! !

!WebTableCell methodsFor: 'attributes'!
valign: aSymbol
	"set a verttical aligment if cell content. It can be #top, #middle, #bottom or #baseline"
	(#(top middle bottom baseline) includes: aSymbol) ifFalse: [self error: 'wrong valign symbol'].
	self attributesAt: #valign put: aSymbol asString.! !

!WebTableCell methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
width: aNumber
	"set the width of a cell. If nil, then cell automaticaly addjust itself. 
	If number is between 0 and 1 then width is percent of table width. 
	If number above 1 then width in pixels"
	| text |
	text := aNumber <= 1 
			ifTrue: [(aNumber * 100) asInteger printString, '%']
			ifFalse: [aNumber asInteger printString].
	self attributesAt: #width put: text! !

!WebTableCell class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebTableHeader methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isTableHeader
	^true! !

!WebTableHeader methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession. 
	aStream nextPutAll: self ident, '<th'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '>'.
	elements notNil ifTrue: [elements do: [:element | 
		element notNil ifTrue: 
			[element streamHtmlTo: aStream for: aRequest on: aSession] ] ].
	aStream nextPutAll: self ident, '</th>', self eol.! !

!WebTableRow methodsFor: 'attributes'!
align: aSymbol
	"set a horizontal aligment for all cells in this row. It can be #left, #center or #right"
	(#(left center right) includes: aSymbol) ifFalse: [self error: 'wrong align symbol'].
	self attributesAt: #align put: aSymbol asString.! !

!WebTableRow methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
bgColor: aColorSymbol
	"set the color of table row background. It can be in hex format (for example #00FF00) 
	or name of color (for example #White)"
	self attributesAt: #bgcolor put: (self colorValue: aColorSymbol)! !

!WebTableRow methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
color: aColorSymbol
	self	bgColor: aColorSymbol! !

!WebTableRow methodsFor: 'private'!
hasTag
	^super hasTag! !

!WebTableRow methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
height: aNumber
	| text |
	text := aNumber <= 1 
			ifTrue: [(aNumber * 100) asInteger printString, '%']
			ifFalse: [aNumber asInteger printString].
	self attributesAt: #height put: text! !

!WebTableRow methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize! !

!WebTableRow methodsFor: 'private'!
shouldIdent
	^true! !

!WebTableRow methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession. 
	aStream nextPutAll: self ident, '<tr'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '>', self eol.
	super streamHtmlTo: aStream for: aRequest on: aSession.
	aStream nextPutAll: self ident, '</tr>', self eol.! !

!WebTableRow methodsFor: 'attributes'!
valign: aSymbol
	"set a vertical aligment for all cells in this row. It can be #top, #middle, #bottom or #baseline"
	(#(top middle bottom baseline) includes: aSymbol) ifFalse: [self error: 'wrong valign symbol'].
	self attributesAt: #valign put: aSymbol asString.! !

!WebTableRow class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebTabs methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
defaultClass
	"default CSS class for tabs, see WebStyle cssTabs1 for more info"
	^#tabs1! !

!WebTabs methodsFor: 'initialize-release'!
initialize
	super initialize.
	self unordered.
	self class: self defaultClass.
	self selected: 1! !

!WebTabs methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
selected
	^selected! !

!WebTabs methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
selected: aNumber
	"whivh tab is selected, that is in front"
	selected := aNumber! !

!WebTabs methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
selectedClass
	"CSS class for selected tab, auto coposed!! "
	^(self attributesAt: #class), 'selected'! !

!WebTabs methodsFor: 'private-streaming'!
streamHtmlTo: aStream for: aRequest on: aSession
	(self selected notNil and: [self selected <= self elements size]) ifTrue:
		[(self elements at: self selected) class: self selectedClass].
	super streamHtmlTo: aStream for: aRequest on: aSession.! !

!WebTabs class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebText methodsFor: 'accessing' stamp: 'janko 9/30/2011 12:21'!
addText: aStringOrAssociation
	"make a new element with aString. Attributes are same as previous text." 

	self add: (WebText text: aStringOrAssociation attributes: self attributes)! !

!WebText methodsFor: 'accessing' stamp: 'janko 9/30/2011 12:21'!
addText: aStringOrAssociation attributes: anArray
	"make a new element with aString. Attributes are same as previous text." 

	self add: (WebText text: aStringOrAssociation attributes: anArray)! !

!WebText methodsFor: 'accessing'!
asString
	^self text! !

!WebText methodsFor: 'private'!
basicText: aString
	text := aString! !

!WebText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
color: aString
	self style: '{color: ', aString asString, '}'.! !

!WebText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
font
	^font! !

!WebText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
font: aString
	font := aString! !

!WebText methodsFor: 'private'!
hasTag
	^false  "well, ...."! !

!WebText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
header
	^header! !

!WebText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
header: aNumber
	
	"Assigns this WebText as a header text. Parameter can be 1 .. 5. If this parameter is nil then WebText is not a header"

	aNumber < 1 
		ifTrue: [header:= 1.   ]
		ifFalse:
			[aNumber > 5 ifTrue: [header := 5.] ifFalse: [header := aNumber.]].
	^self! !

!WebText methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	text := ''.   
	paragraph := false.! !

!WebText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
insideSpanTag
	"to enclose or not in span tag. Only if element have any attribute!!"
	^self attributes notNil and: [self isLink not]! !

!WebText methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isLink
	^false! !

!WebText methodsFor: 'testing'!
isMultilingual
	^self text aidaIsAssociation! !

!WebText methodsFor: 'private' stamp: ' 21/8/07 09:38'!
onChangePost
	"just if addAspect:for:editing: false returns text instead of input field!!"! !

!WebText methodsFor: 'private' stamp: ' 21/8/07 09:38'!
onChangePostAndUpdate: e
	"just if addAspect:for:editing: false returns text instead of input field!!"! !

!WebText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
paragraph
	^paragraph! !

!WebText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
paragraph: aBoolean
	
	"call this method if you want this text in a new paragraph"

	paragraph := aBoolean.! !

!WebText methodsFor: 'translation'!
prepareForTranslation
	"if multilingual text, replace it with in-place input field"
	| translDict replacement session |
	self isMultilingual ifFalse: [^nil].
	session := self app session.
	translDict := session site translator 
		dictToTranslate: self text to: session languageBasic for: self  on: session. "it will create one if not exists yet"
	replacement := WebInPlaceEditableText 
		aspect: self text value for: translDict size: self text value size.
	replacement onChangePost.
"	self parent replace: self with: replacement. "
	self add: replacement. "this will encapsulate inline text editor in original text formating"
	text := nil.! !

!WebText methodsFor: 'private'!
printString

	^'''', [self text isNil ifTrue: [''] ifFalse: [self text] ] value,''''! !

!WebText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
size
	^size! !

!WebText methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
size: aNumber
	
	"larger or smaller text for aNumber factor. Range -7..+7"

	aNumber < -7 
		ifTrue: [size := -7.  ]
		ifFalse:
			[aNumber > 7 ifTrue: [size := 7.  ] ifFalse: [size := aNumber.]].
	^self! !

!WebText methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	"make a header"
	self prepareToHtmlStreamingOn: aSession. 
	aStream nextPutAll: self ident.
	self insideSpanTag ifTrue: 
		[aStream nextPutAll: '<span'. self streamAttributesTo: aStream for: aSession. aStream nextPutAll: '>'].
	self header notNil ifTrue: [aStream nextPutAll: '<h', self header printString, '>'].
	"font size, color, face"
	(self size notNil | self font notNil ) ifTrue:
		[aStream nextPutAll: '<font '.
		self size notNil ifTrue:
			[aStream nextPutAll: 'size=', (self size > 0 ifTrue: ['+'] ifFalse: ['']), self size printString, ' '].
		self font notNil ifTrue:	[aStream nextPutAll: 'face=', self font, ' '].
		aStream nextPutAll: '> ' ].
	"set text attributes, if any"
	self textAttributes notNil ifTrue: 
		[self textAttributes do: [:attribute |  aStream nextPutAll: 
			'<', attribute asString, '>']].
	"print a text"
	self text notNil ifTrue: [aStream nextPutAll: 
		(AIDASite convertToWeb: 
			(self isMultilingual ifTrue: [self textFromMultilang: self text on: aSession] ifFalse: [self text]) 
			on: aSession)].
	"print composite elements"
	super streamHtmlTo: aStream for: aRequest on: aSession.
	"reset text attributes"
	self textAttributes notNil ifTrue: 
		[self textAttributes do: [:attribute |  aStream nextPutAll: 
			'</', attribute asString, '>']].
	"end of font adjustment"
	(self size notNil | self font notNil ) ifTrue: [aStream nextPutAll: '</font>'].
	self header notNil ifTrue: [aStream nextPutAll: '</h', self header printString, '>', self eol].
	self insideSpanTag ifTrue: [aStream nextPutAll: '</span>', self eol].! !

!WebText methodsFor: 'accessing'!
text
	"if text is association in format #lang->text, then this is a multilingual text"
	^text! !

!WebText methodsFor: 'accessing'!
text: aStringOrAssociation
	"if text is association in format #lang->text, then this is a multilingual text"
	self basicText: (WebFormElement 
		autoConvertToString: aStringOrAssociation).  "in case the argument  is not string but date, number  etc."
	"Slovenian csz are converted if char ^ is after such a char"
	(self text aidaIsAssociation not and: [self text includes: $^ ]) 
		ifTrue: [self basicText: self text convertToSloveneChars].! !

!WebText methodsFor: 'accessing' stamp: 'janko 9/30/2011 12:16'!
text: aStringOrAssociation attributes: anArray
	self text: aStringOrAssociation.
	self textAttributes: anArray.! !

!WebText methodsFor: 'private' stamp: ' 21/4/07 22:07'!
textAttributes
	"get the attributes of a text" 
	^textAttributes! !

!WebText methodsFor: 'private' stamp: 'janko 9/30/2011 12:07'!
textAttributes: anArray
	"check and set the attributes of a text. Atribute can be one or a set of them" 

	(anArray isKindOf: Symbol)		"if only one attribute, convert to an Array"
		ifTrue: [textAttributes := Array with: anArray.       ]
		ifFalse: [(anArray isKindOf: Array)
			ifTrue: [textAttributes := anArray.      ]
			ifFalse: [anArray isNil
				ifTrue: [textAttributes := nil.     ]
				ifFalse: 
					[self error: 'Text attributes should be Array of Symbols']]].

"WebText text: 'test' attributes: #b"
"WebText text: 'test' attributes: #( #b #i)"
"WebText text: 'test' attributes: nil"! !

!WebText class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
header: aNumber

	"create an empty header. You can add elements such as images and text later"

	^(self new) header: aNumber.

"| a | 
a := (WebText header: 1).
a add: (WebImage urlReference: 'http://pu/stefan.gif').
a inspect"! !

!WebText class methodsFor: 'instance creation'!
new
	^super new
		setCreationMethodAndObject; "Widget or App, needed for multilingual support"
		initialize! !

!WebText class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newParagraph

	"To open a new paragraph. Use addText: for adding a paragraph text."

	^self new paragraph: true.! !

!WebText class methodsFor: 'instance creation' stamp: 'janko 9/30/2011 12:22'!
text: aStringOrAssociation
	^self new text: aStringOrAssociation

"WebText text: 'test'"! !

!WebText class methodsFor: 'instance creation' stamp: 'janko 9/30/2011 12:22'!
text: aStringOrAssociation attributes: anArray

	^self new text: aStringOrAssociation attributes: anArray

"WebText text: 'test' attributes: #b"! !

!WebTextArea methodsFor: 'private'!
acceptInputFromValue: aString
	| vlue |
	aString isNil ifTrue: [^nil].  "error?"
	vlue :=  AIDASite convertFromWeb: aString on: self session. "ensure unicode!!"
	vlue := (WebFormElement autoConvertString:  vlue toObject: self value).
	self value: vlue.! !

!WebTextArea methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject size: aNumber
	^self aspect: aSymbol for: anObject; size: aNumber! !

!WebTextArea methodsFor: 'private'!
autoConvertAndEncodeValue: aValue
	| vlue |
	vlue := WebFormElement autoConvertToString: aValue. "dates, numbers etc."
	vlue := AIDASite encodeQuoteEntitiesIn: vlue.               "char entity encoding just for double quote '' "
	^vlue! !

!WebTextArea methodsFor: 'private'!
autoConvertAndEncodeValue: aValue on: aSession
	| vlue |
	vlue := WebFormElement autoConvertToString: aValue.   "dates, numbers etc."
	vlue := AIDASite encodeQuoteEntitiesIn: vlue.               "char entity encoding just for double quote '' "
	vlue := AIDASite convertToWeb: vlue on: aSession.      "UTF-8 encoding"
	^vlue! !

!WebTextArea methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
columns: aNumber
	^self attributesAt: #cols put: aNumber printString! !

!WebTextArea methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	super initialize.
	self columns: 5; rows: 5; wrap: 'soft'.! !

!WebTextArea methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isTextArea
	^true! !

!WebTextArea methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
rows: aNumber
	^self attributesAt: #rows put: aNumber printString! !

!WebTextArea methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
shouldIdent
	^false! !

!WebTextArea methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
size: aPoint
	"set the size of area in format colums@rows"
	self columns: aPoint x.
	self rows: aPoint y.! !

!WebTextArea methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession.
	self scriptBefore notNil ifTrue: 
		[self scriptBefore streamHtmlTo: aStream for: aRequest on: aSession].
	aStream nextPutAll: self ident, '<textarea'.
	self streamAttributesTo: aStream for: aSession.
	aStream nextPutAll: '>'.
	self value notNil ifTrue:
		[aStream nextPutAll:    "encode only quotes as &quot; then UTF8" 
			(self autoConvertAndEncodeValue: self value on: aSession)]. 
	aStream nextPutAll: '</textarea>'.
	self scriptAfter notNil ifTrue: 
		[self scriptAfter streamHtmlTo: aStream for: aRequest on: aSession].! !

!WebTextArea methodsFor: 'attributes' stamp: ' 21/4/07 22:07'!
wrap: aString
	"how to wrap text in area"
	^self attributesAt: #wrap put: aString! !

!WebTextArea class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject
	^self new aspect: aSymbol for: anObject! !

!WebTextArea class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
aspect: aSymbol for: anObject size: aNumber
	^self new aspect: aSymbol for: anObject size: aNumber! !

!WebTransactionMonitor class methodsFor: 'local servers' stamp: ' 21/4/07 22:07'!
addServer: aWebServer

	self localServers add: aWebServer! !

!WebTransactionMonitor class methodsFor: 'transactions' stamp: ' 21/4/07 22:07'!
beginTransaction

	"Mark the beginning of transaction on current process. 
	Mark the end with commit or cancelTransaction"

	self beginTransactionOn: Processor activeProcess.! !

!WebTransactionMonitor class methodsFor: 'transactions' stamp: ' 21/4/07 22:07'!
beginTransactionOn: aProcess

	"Mark the beginning of transaction. Mark the end with commit or cancelTransaction"

	self critical: 
		[self transactions add: aProcess]! !

!WebTransactionMonitor class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
busySessions

	"a collection of database sessions, which are busy on that moment"

	BusySessions isNil ifTrue: [self initBusySessions].
	^BusySessions! !

!WebTransactionMonitor class methodsFor: 'transactions' stamp: ' 21/4/07 22:07'!
cancelTransaction

	"cancel the transaction without commiting on current process. 
	Used in exception handling routines"

	self cancelTransactionOn: Processor activeProcess! !

!WebTransactionMonitor class methodsFor: 'transactions' stamp: ' 21/4/07 22:07'!
cancelTransactionOn: aProcess

	"cancel the transaction without commiting. Used in exception handling routines"

	self critical: 
		[self transactions remove: aProcess ifAbsent: []].! !

!WebTransactionMonitor class methodsFor: 'transactions' stamp: ' 21/4/07 22:07'!
clearHangedProcesses

	"remove all processes with hanged  suspended context from set of transactions. "
	"WebTransactionMonitor clearHangedProcesses"
" TEMORARY, vw5i4 sender unknown !! "
	self transactions copy do: 
		[:each | (each suspendedContext notNil and:
""
			[(each suspendedContext sender selector = #readWait) | 
			(each suspendedContext sender selector = #writeWait)] )
""
				ifTrue:
					[each terminate.
					self transactions remove: each] ].
""! !

!WebTransactionMonitor class methodsFor: 'transactions' stamp: ' 21/4/07 22:07'!
clearNilProcesses

	"remove all processes with nil  suspended context from set of transactions. Such processes
	died somewhere and were not removed with method cancelTransaction"

	self transactions copy do: 
		[:each | each suspendedContext isNil 
			ifTrue:
				[self transactions remove: each] ].! !

!WebTransactionMonitor class methodsFor: 'transactions' stamp: ' 21/4/07 22:07'!
commit

	"commit the transaction if there is no more pending transactions, otherwise defer commit to
	the next call of this method."
	"WebTransactionMonitor commit"
	self critical: 
		[self clearNilProcesses.
		"self transactions isEmpty" true
			ifTrue: 
				["WebServer default diagnostics ifTrue: [Transcript show: ' comm.']."
"				Swazoo.SwazooServer isPersistent ifTrue: [self gemstoneCommit].  "
				"WebServer default diagnostics ifTrue: [Transcript show: '.ited ']."
				self setLastCommit. ]
			ifFalse: 
				[self clearHangedProcesses.
				self transactions notEmpty ifTrue: 
					[self noCommitFor10min ifTrue: 
						[self notifyNoCommiting.
"						Swazoo.SwazooServer isPersistent ifTrue: [self gemstoneCommit] "]
					]
				]
		].

"WebTransactionMonitor commit"! !

!WebTransactionMonitor class methodsFor: 'transactions' stamp: ' 21/4/07 22:07'!
commitTransaction

	"commit the transaction on current process if there is no more pending transactions, 
	otherwise defer commit to the next call of this method."

	self commitTransactionOn: Processor activeProcess! !

!WebTransactionMonitor class methodsFor: 'transactions' stamp: ' 21/4/07 22:07'!
commitTransactionOn: aProcess

	"commit the transaction if there is no more pending transactions, otherwise defer commit to
	the next call of this method."

	self critical: 
		[self cancelTransactionOn: aProcess.
		self commit].! !

!WebTransactionMonitor class methodsFor: 'critical sections'!
critical: aBlock
	"For protecting critical sections in parallel execution of web requests. Use it always
	when you do things, which cannot be disturbed by another request. Example:
		WebTransactionMonitor critical: [<a block with critical section>]. "

	^self mutex critical: aBlock.! !

!WebTransactionMonitor class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
freeSession

	"find a session in a pool of sessions which is not current and not busy"

	| allSessions pick |
	allSessions := GBSM loggedInSessions asOrderedCollection.
	allSessions 
		remove: GBSM currentSession;
		removeAll: self busySessions.
	allSessions notEmpty
		ifTrue:
			[pick := (Random new next * allSessions size) truncated + 1.
			^allSessions at: pick]
		ifFalse: [^GBSM currentSession]


"WebTransactionMonitor freeSession"! !

!WebTransactionMonitor class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
gemstoneCommit

	| result |
	AIDARoot critical:
		[result := GBSM currentSession commitTransaction.
		result == true ifFalse: 
			[result := GBSM currentSession commitTransaction.
			result == true ifFalse: 
				[Transcript cr; show: '****** commit troubles !!!!!! ******'] ].
		].

"WebTransactionMonitor commit"! !

!WebTransactionMonitor class methodsFor: 'initialize' stamp: ' 21/4/07 22:07'!
initBusySessions

	BusySessions := Set new.! !

!WebTransactionMonitor class methodsFor: 'initialize' stamp: ' 21/4/07 22:07'!
initTransactions

	Transactions := Set new.! !

!WebTransactionMonitor class methodsFor: 'initialize' stamp: ' 21/4/07 22:07'!
initialize
	self initTransactions.
	self initBusySessions.

"WebTransactionMonitor initialize"! !

!WebTransactionMonitor class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
isNotificationSent

	NotificationSent isNil ifTrue: [self resetNotificationSent].
	^NotificationSent! !

!WebTransactionMonitor class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
lastCommit

	"return the time of last real odb commit"

	^AIDASite default lastCommitTimestamp.! !

!WebTransactionMonitor class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
localServers
	"all active web servers, whose are running on local image"
	LocalServers isNil ifTrue: [LocalServers := Set new].
	self removeNonactiveServers.
	^LocalServers! !

!WebTransactionMonitor class methodsFor: 'private' stamp: 'janko 3/19/2012 21:59'!
mutex
	"for critical sections"
	Muttex isNil ifTrue: [Muttex := AidaMutex new].
	^Muttex! !

!WebTransactionMonitor class methodsFor: 'error notifying' stamp: 'rob.rothwell 3/2/2009 22:02'!
noCommitFor10min

	"check if there was no real odb commit more than 10min"

	^(TimeStamp now asSeconds - self lastCommit asSeconds) > (10 * 60)! !

!WebTransactionMonitor class methodsFor: 'error notifying' stamp: ' 21/4/07 22:07'!
notifyNoCommiting

	"if there is no odb commit for more than 10min then an e-mail message is sent to a 
	specified address (from settings in WebServer)"
	"WebTransactionMonitor notifyNoCommiting"



	| subject body |

	self isNotificationSent ifTrue: [^self].
"
	subject := 'AIDAWeb Urgent: No odb commit!!'.
	body := 'No commit for more than 10 minutes!!'.
	WebServer default urgentEMailSubject: subject body: body.
"
	self setNotificationSent.! !

!WebTransactionMonitor class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
onFreeSessionFor: anObject remotePerform: aSelector

	^self onFreeSessionFor: anObject remotePerform: aSelector withArgs: #()


"WebTransactionMonitor onFreeSessionFor: AIDARoot remotePerform: #copy"! !

!WebTransactionMonitor class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
onFreeSessionFor: anObject remotePerform: aSelector with: anArgument

	^self onFreeSessionFor: anObject remotePerform: aSelector withArgs: (Array with: anArgument)

"WebTransactionMonitor onFreeSessionFor: AIDARoot remotePerform: #at: with: 'planid' "! !

!WebTransactionMonitor class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
onFreeSessionFor: anObject remotePerform: aSelector withArgs: argsArray

	| session gsObject result |
	session := self freeSession.
	[	
		self busySessions add: session.
		gsObject := anObject asGSObjectInSession: session .
		result := gsObject remotePerform: aSelector withArgs: argsArray.
		result := gsObject remotePerform: aSelector withArgs: argsArray.
		result := result asLocalObject.
		session commitTransaction
	] valueNowOrOnUnwindDo: 
		[self busySessions remove: session ifAbsent: [].
		 session disconnectST: anObject fromGS: gsObject].
	^result

"WebTransactionMonitor onFreeSessionFor: WebServer default remotePerform: #settings withArgs: #()"! !

!WebTransactionMonitor class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
removeNonactiveServers
	LocalServers copy do: [:srv | 
		srv isServing ifFalse: [LocalServers remove: srv ifAbsent: []] ]! !

!WebTransactionMonitor class methodsFor: 'local servers' stamp: ' 21/4/07 22:07'!
removeServer: aWebServer

	self localServers remove: aWebServer ifAbsent: []! !

!WebTransactionMonitor class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
resetNotificationSent

	NotificationSent := false.! !

!WebTransactionMonitor class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setLastCommit

	"set the time of last real odb commit to time now"
	
	self localServers do: [:each | each setLastCommitTimestamp].
	self resetNotificationSent! !

!WebTransactionMonitor class methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
setNotificationSent

	NotificationSent := true.! !

!WebTransactionMonitor class methodsFor: 'private' stamp: ' 21/4/07 22:07'!
transactions

	"a collection of all processes with open transactions . Such a process is 
	addded with method beginTransaction and removed with commit or cancelTransaction"
	"WebTransactionMonitor transactions"
	Transactions isNil ifTrue: [self initTransactions].
	^Transactions! !

!WebTransactionMonitor class methodsFor: 'odb specific' stamp: ' 21/4/07 22:07'!
versantCommit

"	ODBInterface checkpointCommit "! !

!WebTranslDict methodsFor: 'accessing'!
at: key
	^self dict at: key! !

!WebTranslDict methodsFor: 'accessing'!
at: key ifAbsent: aBlock
	^self dict at: key ifAbsent: aBlock! !

!WebTranslDict methodsFor: 'accessing'!
at: key ifAbsentPut: aBlock
	^self at: key ifAbsent: [self initialAt: key put: aBlock value]! !

!WebTranslDict methodsFor: 'accessing'!
at: key put: value
	"this one should be used by translation tools!!"
	"This method is called by WebInlineEditableText widget after the text change is posted. See 
       WebText>>#prepareForTranslation, how the aspect of this widget is prepared to achieve that."
	self changes add: key.
	self dict at: key put: value.
	self writeChanges. "immediatelly after each change, for now"
	^value! !

!WebTranslDict methodsFor: 'private'!
changes
	"changes of multilingual text to be written on class side of classses with translations"
	changes isNil ifTrue: [self initChanges].
	^changes! !

!WebTranslDict methodsFor: 'private'!
dict
	dict ifNil: [self initDict].
	^dict! !

!WebTranslDict methodsFor: 'initialize-release'!
initChanges
	changes := Set new.! !

!WebTranslDict methodsFor: 'initialize-release'!
initDict
	dict := Dictionary new.! !

!WebTranslDict methodsFor: 'accessing'!
initialAt: key put: value
	"this one does not register the change, use it for initial dict setup!!"
	^self dict at: key put: value! !

!WebTranslDict methodsFor: 'accessing'!
language
	"language of translations in this dictionary"
	^language! !

!WebTranslDict methodsFor: 'private'!
language: aSymbol
	language := aSymbol! !

!WebTranslDict methodsFor: 'accessing'!
method
	"a creation method which holds our translations (contains multilingual associations"
	^method! !

!WebTranslDict methodsFor: 'private'!
method: aSymbol
	"a creation method which holds our translations (contains multilingual associations"
	method := aSymbol! !

!WebTranslDict methodsFor: 'private'!
printOn: aStream
	aStream nextPutAll: 'aWebTranslDict ('.
	self dict keysAndValuesDo: [:key :value | 
		aStream nextPutAll: key printString, '->', value printString, ' '].
	aStream nextPutAll: ') '! !

!WebTranslDict methodsFor: 'accessing'!
site
	^self translator site! !

!WebTranslDict methodsFor: 'accessing'!
translClass	
	"a class holding this transactions on its class side methods. Usually a sublcass of WebApplication"
	^class! !

!WebTranslDict methodsFor: 'private'!
translClass: aClassWithTransactions
	"a class holding this transactions on its class side methods. Usually a sublcass of WebApplication"
	class := aClassWithTransactions! !

!WebTranslDict methodsFor: 'accessing'!
translator
	^translator! !

!WebTranslDict methodsFor: 'private'!
translator: aWebTranslator
	translator := aWebTranslator! !

!WebTranslDict methodsFor: 'private'!
view: aSymbol
	"a view on our App class where those translations belong"
	view := aSymbol! !

!WebTranslDict methodsFor: 'changing'!
writeChanges
	self changes do: [:key |
		self translator 
			changeTranslationKey: key 
			to: (self at: key) 
			language: self language 
			class: self translClass 
			method: self method].
	self initChanges.! !

!WebTranslDict class methodsFor: 'instance creation'!
newOn: aWebTranslator forClass: aWebAppClass method: aSymbol language: aLangSymbol
	^super new
		translator: aWebTranslator;
		translClass: aWebAppClass;
		method: aSymbol;
		language: aLangSymbol! !

!WebTranslator methodsFor: 'private-cache' stamp: 'np 3/25/2009 15:30'!
cache
	"cached translations. A multilevel dictionary"
	"class->(method->(langCode->(key->translation))))) "
	cache isNil ifTrue: [self initCache].
	^cache! !

!WebTranslator methodsFor: 'private-cache'!
cachedTranslate: aString toLanguage: aLanguageCode class: aClassWithTransl method: aMethodSymbol
	"cache hierarchy: class->(method->(langCode->(key->translation))))) "
	"last dictionary is WebTranslDict!! "
	^(((self cache at: aClassWithTransl ifAbsent: [self refreshClass: aClassWithTransl])
		at: aMethodSymbol ifAbsentPut: [^aString])
			at: aLanguageCode ifAbsent: [^aString])
				at: aString ifAbsent: [^aString]! !

!WebTranslator methodsFor: 'private-classes-changes'!
changePairs: aPairsCollection key: aKeyString value: aString
	"change (or add new pair) a value of a pair (an association) on specified key"
	| pair |
	pair := aPairsCollection 
		detect: [:assoc | assoc key = aKeyString]
		ifNone: [aPairsCollection add: (aKeyString -> '')].
	pair value: aString.
	^aPairsCollection! !

!WebTranslator methodsFor: 'translating'!
changeTranslationKey: aKeyString to: aNewString language: aLanguageCode class: aClassWithTransl method: aMethodSymbol
	"change that translation by recompiling the apropriate method in a class side of App class"
	| translMethod translPairs |
	translMethod := self translMethodForLang: aLanguageCode method: aMethodSymbol.
	self checkOrCreateMethod: translMethod onClass: aClassWithTransl.
	translPairs := self pairsForLang: aLanguageCode method: aMethodSymbol on: aClassWithTransl.
	translPairs := self changePairs: translPairs key: aKeyString value: aNewString.
	self writeBackPairs: translPairs intoMethod: translMethod onClass: aClassWithTransl! !

!WebTranslator methodsFor: 'private-classes-changes'!
checkCreateTranslation: aMultilangAssociation forLanguage: aLanguageCode inDict: aTranslDict
	"check if that translation exists and if not, create a pair in a dict. Same for original lang too!!"
	| origLang origDict |
	(aTranslDict at: aMultilangAssociation value ifAbsent: [nil]) notNil ifTrue: [^true]. "exists, no need to create"
	aTranslDict  
		at:  aMultilangAssociation value
		put:  aMultilangAssociation value. "default text is from orig lang"
	origLang := aMultilangAssociation key.
	origDict := ((self cache at: aTranslDict translClass) at: aTranslDict method) at: origLang.
	self checkCreateTranslation: aMultilangAssociation forLanguage: origLang inDict: origDict.! !

!WebTranslator methodsFor: 'private-classes-changes'!
checkOrCreateMethod: aTranslMethodSymbol onClass: aClassWithTransl
	"check if exist and if not, create that method with translations (empty so far)  on a class side of class"
	(aClassWithTransl respondsTo: aTranslMethodSymbol) ifTrue: [^true].
	self writeBackPairs: #() intoMethod: aTranslMethodSymbol onClass: aClassWithTransl! !

!WebTranslator methodsFor: 'translating'!
dictToTranslate: aMultilangAssociation to: aLanguageCode for: anElement on: aSession
	"returns WebTranslDict, for setting an aspect to edit by translation tools"
	"Open a new one automatically if not yet exist for that method and language"
	| translClass method dict |
	translClass := aSession lastApp class. "app class where translations reside"
	method := anElement creationMethod. "method which created an element with multilang text"
	dict := ((self cache at: translClass ifAbsent: [self refreshClass: translClass])
		at: method ifAbsent: 
			[self openDictsToTranslate: aMultilangAssociation 
				toLanguage: aLanguageCode forMethod: method on: translClass.
			self refreshClass: translClass.
			(self cache at: translClass) at: method])
				at: aLanguageCode ifAbsent: 
					[self openDictsToTranslate: aMultilangAssociation 
						toLanguage: aLanguageCode forMethod: method on: translClass.
						self refreshClass: translClass.
						((self cache at: translClass) at: method) at: aLanguageCode].
	self checkCreateTranslation: aMultilangAssociation forLanguage: aLanguageCode inDict: dict.
	^dict! !

!WebTranslator methodsFor: 'initialize-release' stamp: 'np 3/25/2009 15:29'!
initCache
	"cached translations"
	cache := Dictionary new.! !

!WebTranslator methodsFor: 'initialize-release' stamp: 'np 3/25/2009 15:29'!
initOther
	other := Dictionary new! !

!WebTranslator methodsFor: 'private-classes' stamp: 'np 3/25/2009 15:31'!
langFromTranslMethod: aMethodSymbol
	"extract language code from transl.method:  #fr from #frViewCalendar"
	^(aMethodSymbol asString copyFrom: 1 to: 2) asSymbol! !

!WebTranslator methodsFor: 'private-classes' stamp: 'np 3/25/2009 15:31'!
langsForMethod: aMethodSymbol on: aClassWithTransl
	"get all languages for which we have a translation for that creation method"
	^((self translMethodsOn: aClassWithTransl)
		 select: [:each | (self methodFromTranslMethod: each) = aMethodSymbol]) 
			collect: [:each | self langFromTranslMethod: each]! !

!WebTranslator methodsFor: 'private-classes' stamp: 'np 3/25/2009 15:31'!
methodFromTranslMethod: aMethodSymbol
	"extract creation method name from transl.method:  #viewCalendar from #frViewCalendar"
	| method |
	method := String with: (aMethodSymbol asString at: 3) asLowercase.
	^(method, (aMethodSymbol asString copyFrom: 4 to: aMethodSymbol size)) asSymbol.! !

!WebTranslator methodsFor: 'private-classes' stamp: 'np 3/25/2009 15:31'!
methodsOn: aClassWithTransl
	"get all creation methods for elements holding multilang text"
	^((self translMethodsOn: aClassWithTransl) collect: [:each | self methodFromTranslMethod: each]) 
		asSet "to find a unique set of those methods"! !

!WebTranslator methodsFor: 'private-classes-changes'!
openDictsToTranslate: aMultilangAssociation toLanguage: aLanguageCode forMethod: aMethodSymbol on: aClassWithTransl
	"check/create dict for orig language, then create dict for specified language"
	| origLang translMethod pairs pair |
	origLang := aMultilangAssociation key.
	translMethod := self translMethodForLang: origLang method: aMethodSymbol.
	pairs := (aClassWithTransl respondsTo: translMethod) 
		ifTrue: [self pairsForLang: origLang method: aMethodSymbol on: aClassWithTransl.]
		ifFalse: [OrderedCollection new].
	self changePairs: pairs key:  aMultilangAssociation value value: aMultilangAssociation value.
	self writeBackPairs: pairs intoMethod: translMethod onClass: aClassWithTransl.
	translMethod := self translMethodForLang: aLanguageCode method: aMethodSymbol.
	pair := aMultilangAssociation value -> aMultilangAssociation value. "default one for specified lang too"	
	self writeBackPairs: (Array with: pair) intoMethod: translMethod onClass: aClassWithTransl! !

!WebTranslator methodsFor: 'private' stamp: 'np 3/25/2009 15:29'!
other
	^other! !

!WebTranslator methodsFor: 'private' stamp: 'np 3/25/2009 15:29'!
otherAt: aSymbol
	"other values"
	^self otherAt: aSymbol ifAbsent: [nil]! !

!WebTranslator methodsFor: 'private' stamp: 'np 3/25/2009 15:30'!
otherAt: aSymbol ifAbsent: aBlock
	"other values"
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!WebTranslator methodsFor: 'private' stamp: 'np 3/25/2009 15:30'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!WebTranslator methodsFor: 'private' stamp: 'np 3/25/2009 15:30'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!WebTranslator methodsFor: 'private-classes'!
pairsForLang: aLanguageCode method: aMethodSymbol on: aClassWithTransl
	| translMethod pairs |
	translMethod := self translMethodForLang: aLanguageCode method: aMethodSymbol.
	pairs := (aClassWithTransl perform: translMethod) 
		collect: [:triple | Association 
			key: (AIDASite convert: triple first fromCodepage: #UTF8)
			value: (AIDASite convert: triple last fromCodepage: #UTF8)]. "triple midlle is just ->"
	^pairs asOrderedCollection! !

!WebTranslator methodsFor: 'accessing' stamp: 'np 3/25/2009 15:28'!
parent
	^parent! !

!WebTranslator methodsFor: 'private' stamp: 'np 3/25/2009 15:30'!
parent: anObject
	parent := anObject! !

!WebTranslator methodsFor: 'private-cache'!
refreshClass: aClassWithTransl
	"refresh a cache from translations stored in class methods of specified class"
	| classDict methodDict langDict |
	classDict := self cache at: aClassWithTransl put: Dictionary new. "just remove old stuff"
	(self methodsOn: aClassWithTransl) do: [:method |
		methodDict := classDict at: method put: Dictionary new.
		(self langsForMethod: method on: aClassWithTransl) do: [:lang |
			langDict := methodDict 
				at: lang 
				put: (WebTranslDict newOn: self forClass: aClassWithTransl method: method language: lang).
			(self pairsForLang: lang method: method on: aClassWithTransl) do: [:assoc |
				langDict initialAt: assoc key put: assoc value ]]]. "initalAt:put: to avoid signaling change"
	^classDict! !

!WebTranslator methodsFor: 'accessing' stamp: 'np 3/25/2009 15:28'!
site	
	^self parent! !

!WebTranslator methodsFor: 'private-classes' stamp: 'np 3/25/2009 15:31'!
translLanguagesOn: aClassWithTransl
	"get all languages (codes) in which we have trnaslations"
	^(self translMethodsOn: aClassWithTransl) 
		inject: Set new 
		into: [:each :set | set add: (self langFromTranslMethod: each); yourself]! !

!WebTranslator methodsFor: 'private-classes' stamp: 'np 3/25/2009 15:31'!
translMethodForLang: aLanguageCode method: aMethodSymbol
	"compose that method name. For #fr and #viewCalendar = #frViewCalendar"
	^(aLanguageCode asString, (String with: aMethodSymbol asString first) asUppercase,
		(aMethodSymbol asString copyFrom: 2 to: aMethodSymbol size))
			asSymbol! !

!WebTranslator methodsFor: 'private-classes' stamp: 'np 3/25/2009 15:32'!
translMethodsOn: aClassWithTransl
	"get all class method names holding translations"
	"VW specific"
	^aClassWithTransl class organization listAtCategoryNamed: self translationsCategory! !

!WebTranslator methodsFor: 'translating'!
translate: aMultilangAssociation to: aLanguageCode for: anElement on: aSession
	| translClass translation |
	translClass := aSession lastApp class. "app class where translations reside"
	translation := self 
		cachedTranslate: aMultilangAssociation value
		toLanguage: aLanguageCode
		class: translClass
		method: anElement creationMethod. "method which created an element with multilang text"
	^translation notNil 
		ifTrue: [translation] 
		ifFalse: [aMultilangAssociation value] "original text"! !

!WebTranslator methodsFor: 'accessing' stamp: 'np 3/25/2009 15:28'!
translationsCategory
	"name of category holding translations on class side of App classes"
	^#translations! !

!WebTranslator methodsFor: 'private-classes-changes'!
writeBackPairs: aTranslPairsArray intoMethod: aTranslMethodSymbol onClass: aClassWithTransl
	| cr mstream semaphore |
	cr :=  (String with: Character cr).
	mstream := WriteStream on: String new.
	mstream
		nextPutAll: aTranslMethodSymbol asString, cr;
		nextPut: Character tab; nextPutAll: '^#('.
	aTranslPairsArray do: [:assoc |
		mstream 
			nextPut: Character cr; nextPut: Character tab; nextPutAll: '(';
			nextPut: $'; nextPutAll: (AIDASite convert: assoc key toCodepage: #UTF8); nextPut: $'; 
			nextPutAll: '->';
			nextPut: $'; nextPutAll:  (AIDASite convert: assoc value toCodepage: #UTF8); nextPut: $';
			nextPutAll: ')'].
	mstream nextPut: Character cr; nextPut: Character tab; nextPutAll: ')', cr. 
	semaphore := Semaphore new.
	[aClassWithTransl class compile: mstream contents  classified: 'translations'. semaphore signal] 
		fork. "well, don't ask why :( "
	semaphore wait. "for forked compilation to finish"! !

!WebTranslator class methodsFor: 'instance creation' stamp: 'np 3/25/2009 15:28'!
newOn: anAIDASite
	^super new
		parent: anAIDASite! !

!WebUser methodsFor: 'groups' stamp: ' 21/4/07 22:07'!
addToActivatingGroup
	self parent addActivatingUser: self! !

!WebUser methodsFor: 'groups' stamp: ' 21/4/07 22:07'!
addToRegisteredGroup
	self parent addRegisteredUser: self! !

!WebUser methodsFor: 'accessing-address'!
address
	address isNil ifTrue: [^'']. 
	^address! !

!WebUser methodsFor: 'accessing-address'!
address: aString
	address := aString.! !

!WebUser methodsFor: 'accessing' stamp: 'janko 8/6/2011 19:42'!
asPerson
	"parallel Person object (from Party framework if present, otherwise nil)"
	^self otherAt: #Person ifAbsent: [^self initPerson]! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
asWebUser
	^self! !

!WebUser methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:42'!
autoLogout
	"logout after 15min of inactivity. default is NO!! "
	^self otherAt: #AutoLogout ifAbsent: [false]! !

!WebUser methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:44'!
autoLogout: aBoolean
	"logout after 15min of inactivity"
	^self otherAt: #AutoLogout put: aBoolean! !

!WebUser methodsFor: 'groups' stamp: ' 21/4/07 22:07'!
becomeAdmin
	self parent adminGroup addUser: self! !

!WebUser methodsFor: 'accessing-address'!
city
	city isNil ifTrue: [^'']. 
	^city! !

!WebUser methodsFor: 'accessing-address'!
city: aString
	city := aString.! !

!WebUser methodsFor: 'accessing-address'!
company
	company isNil ifTrue: [^'']. 
	^company! !

!WebUser methodsFor: 'accessing-address'!
company: aString 
	company := aString.! !

!WebUser methodsFor: 'private' stamp: 'janko 4/20/2012 17:09'!
copy
	| new |
	new := super copy.
	new 
		parent: nil;
		initOtherValues;
		name: self name;
		surname: self surname. "because it can be on his aPerson"
	self copyOtherTo: new.
	^new! !

!WebUser methodsFor: 'private'!
copyOtherTo: aWebUser
	"override in subclasses for specifics here"! !

!WebUser methodsFor: 'accessing-address'!
country
	country isNil ifTrue: [^'']. 
	^country! !

!WebUser methodsFor: 'accessing-address'!
country: aString
	country := aString.! !

!WebUser methodsFor: 'accessing-address'!
email 
	email isNil ifTrue: [^''].
	^email! !

!WebUser methodsFor: 'accessing-address'!
email: aString
	email := aString.! !

!WebUser methodsFor: 'security' stamp: 'janko 4/25/2012 12:38'!
escalateToAdmin
	"escalate access rights of that use to admin rights, if user is in Administrators group"
	"WebSecurityManager default adminGroup users do: [:each | each escalateToAdmin] "
	self inAdminGroup ifFalse: [self error: 'User to escalate must be in Admin group'].
	self otherAt: #EscalatedToAdmin put: true.! !

!WebUser methodsFor: 'accessing-address'!
fax
	fax isNil ifTrue: [^''].
	^fax! !

!WebUser methodsFor: 'accessing-address'!
fax: aString 
	fax := aString.! !

!WebUser methodsFor: 'groups'!
groups 
	"where this user is a member"
	^self parent groups select: [:group | group users includes: self]! !

!WebUser methodsFor: 'security'!
hasAdminRights
	"Admin is every member of Administrators group which rights are escalated to admin rights. 
	Default Admin user is always regarded as 'escalated to admin' and is therefore admin by default "
	self isAdminUser ifTrue: [^true].
	^self inAdminGroup 
		and: [self isEscalatedToAdmin]! !

!WebUser methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
hasEMail 

	"at least email must be entered to accept a new user"
	
	^self email ~= ''! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
id
	"unique id of that user"
	^id! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
id: aNumber
	id := aNumber.! !

!WebUser methodsFor: 'testing'!
inActivatingGroup
	"user needs to confirm registration"
	^self groups contains: [:each | each isActivatingGroup]! !

!WebUser methodsFor: 'testing'!
inAdminGroup
	"all from Administrators group are admins, also default Admin user"
	^self groups contains: [:each | each isAdminGroup]! !

!WebUser methodsFor: 'testing'!
inRegisteredGroup
	^self groups contains: [:each | each isRegisteredGroup]! !

!WebUser methodsFor: 'initialize-release'!
initId
	self id: (AIDASite random next * 1000000000) rounded printString.! !

!WebUser methodsFor: 'initialize-release' stamp: 'janko 8/6/2011 19:44'!
initLoginHistory
	^self otherAt: #LoginHistory put: DailyCollection new! !

!WebUser methodsFor: 'initialize-release' stamp: 'janko 8/6/2011 19:49'!
initOtherValues
	other := Dictionary new.! !

!WebUser methodsFor: 'initialize-release' stamp: 'janko 8/6/2011 19:44'!
initPerson
	^self otherAt: #Person put: (Person new webUser: self)! !

!WebUser methodsFor: 'initialize-release' stamp: ' 21/4/07 22:07'!
initialize
	self initId! !

!WebUser methodsFor: 'private-obsolete'!
isAdmin
	"if from Administrators group and escalated to Admin. Default Admin user has always Admin rights"
	"DEPRECIATED!!, use #hasAdminRights, #inAdminGroup or #isAdminUser instead!! "
	^self hasAdminRights! !

!WebUser methodsFor: 'testing'!
isAdminUser
	"special user with name Admin"
	^self username = 'admin' and: [self name= 'Admin'].! !

!WebUser methodsFor: 'security' stamp: 'janko 4/25/2012 13:09'!
isEscalatedToAdmin
	"escalate access rights of that use to admin rights, if user is in Admin group"
	^self otherAt: #EscalatedToAdmin ifAbsent: [false]! !

!WebUser methodsFor: 'testing'!
isExtranetUser
	"a general user for extranets"
	^self name = 'Extranet' or: [(self username = 'extranet') & (self password = 'password')]! !

!WebUser methodsFor: 'testing' stamp: 'mivsek 3/7/2008 22:57'!
isGuest
	"all non registered visitors have the same user: a Guest"
	^self name = 'Guest' and: 
		[(self username = 'guest') 
			"& (self password = (WebSecurityManager hashPassword: 'guest'))"]! !

!WebUser methodsFor: 'testing' stamp: 'janko 8/6/2011 19:42'!
isLocked
	"change or delete of this user data not allowed"
	^self otherAt: #Locked ifAbsent: [false]! !

!WebUser methodsFor: 'testing' stamp: 'janko 8/8/2011 11:03'!
isLoggedIn
	^self loginHistory isEmpty not
		and: [(self loginHistory last at: 1) = #login]! !

!WebUser methodsFor: 'testing' stamp: 'np 1/18/2008 11:23'!
isPerson
	^false! !

!WebUser methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebUser
	^true! !

!WebUser methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebUserGroup
	^false! !

!WebUser methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:42'!
lastAppUrl
	"an url which last WebApplication was called. "
	^self otherAt: #LastAppUrl ifAbsent: [nil].! !

!WebUser methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:44'!
lastAppUrl: aString
	"an url which last WebApplication was called. It is set AFTER the app view is generated!!"
	^self otherAt: #LastAppUrl put: aString! !

!WebUser methodsFor: 'accessing-timestamps'!
lastLoginTimestamp
	self loginHistory isEmpty ifTrue: [^nil].
	^(self loginHistory all detect: [:array | (array at: 1) = #login] ifNone: [^nil])
		at: 2.                 	"what if he is logged in in more than one session?"! !

!WebUser methodsFor: 'accessing-timestamps'!
lastLogoutTimestamp
	self loginHistory isEmpty ifTrue: [^nil].
	^(self loginHistory all detect: [:array | (array at: 1) = #logout] ifNone: [^nil])
		at: 2.                 	"what if he is logged in in more than one session?"! !

!WebUser methodsFor: 'private' stamp: 'jm 9/8/2010 21:11'!
logLogin
	self loginHistory
		add: (Array with: #login with: SpTimestamp now)
		onDate: SpDate today! !

!WebUser methodsFor: 'private' stamp: 'jm 9/8/2010 21:11'!
logLogout
	self loginHistory 
		add: (Array with: #logout with: SpTimestamp now)
		onDate: SpDate today! !

!WebUser methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:42'!
loginHistory
	"occurences of user logged it/out. As DailyCollection of Array #login/logout, WebUser, timestamp"
	^self otherAt: #LoginHistory ifAbsent: [self initLoginHistory]! !

!WebUser methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:42'!
logoutFromUrl
	"From which page user logout. To be redirected back after login"
	^self otherAt: #LogoutFromUrl ifAbsent: [nil].! !

!WebUser methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:44'!
logoutFromUrl: aString
	"From which page user logout. To be redirected back after login"
	^self otherAt: #LogoutFromUrl put: aString! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
menuName
	"in dropdown menus"
	^self surnameName! !

!WebUser methodsFor: 'private' stamp: ' 21/4/07 22:07'!
migrateToUnicode
	"from iso8859-2"
	"WebUser allInstances do: [:each | each migrateToUnicode]"
	username notNil ifTrue: [username := username ensureUnicodeSloveneChars].
	password notNil ifTrue: [password := password ensureUnicodeSloveneChars].
	name notNil ifTrue: [name := name ensureUnicodeSloveneChars].
	surname notNil ifTrue: [surname := surname ensureUnicodeSloveneChars].
	company notNil ifTrue: [company := company ensureUnicodeSloveneChars].
	city notNil ifTrue: [city := city ensureUnicodeSloveneChars].
	country notNil ifTrue: [country := country ensureUnicodeSloveneChars].! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
name
	name isNil ifTrue: [self asPerson notNil ifTrue: [^self asPerson name] ifFalse: [^''] ].
	^name! !

!WebUser methodsFor: 'accessing'!
name: aString 
	self isLocked ifTrue: [^self error: 'user locked, changes not allowed!! '].
	self asPerson notNil ifTrue: [^self asPerson name: aString].
	name := aString trimBlanks.! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
nameSurname 
	^self name, ' ', self surname! !

!WebUser methodsFor: 'private' stamp: 'janko 8/6/2011 19:49'!
other
	^other! !

!WebUser methodsFor: 'private' stamp: 'janko 8/6/2011 19:43'!
otherAt: aString
	^self otherAt: aString ifAbsent: [nil]! !

!WebUser methodsFor: 'private' stamp: 'janko 8/6/2011 19:44'!
otherAt: aString ifAbsent: aBlock
	self other isNil ifTrue: [^aBlock value].
	^self other at: aString ifAbsent: [aBlock value]! !

!WebUser methodsFor: 'private' stamp: 'janko 8/6/2011 19:44'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOtherValues].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!WebUser methodsFor: 'private' stamp: 'janko 8/6/2011 19:44'!
otherAt: aString put: anObject
	self other isNil ifTrue: [self initOtherValues].
	^self other at: aString put: anObject! !

!WebUser methodsFor: 'private' stamp: ' 21/4/07 22:07'!
parent
	^parent! !

!WebUser methodsFor: 'private' stamp: ' 21/4/07 22:07'!
parent: aWebSecurityManager
	parent := aWebSecurityManager! !

!WebUser methodsFor: 'accessing' stamp: 'jm 4/22/2009 22:23'!
password
	"returns SHA1 encrypted password!! "
	password isNil ifTrue: [^''].
	^password! !

!WebUser methodsFor: 'accessing' stamp: 'np 4/6/2008 15:53'!
password: aString	
	"Store hashed string"
	aString notEmpty ifTrue: [
		password := WebSecurityManager hashPassword: aString]! !

!WebUser methodsFor: 'accessing' stamp: 'jm 4/22/2009 19:56'!
passwordAsHex
	"leading zero in each byte ommited!! 0F = just F !!"
	"Squeak specific!!"
	^(self password
		inject: (WriteStream on: String new)
		into:
			[:stream :byte | 
			stream nextPutAll: 
				((byte printStringRadix: 16) copyReplaceAll: '16r' with: ''). "Squeak specific!!"
			stream]) contents! !

!WebUser methodsFor: 'accessing' stamp: 'np 10/20/2008 16:43'!
passwordText
	"password is encripted/invisible anway, so return just empty string"
	^''! !

!WebUser methodsFor: 'accessing' stamp: 'np 10/20/2008 16:43'!
passwordText: aString
	aString = self passwordText "all *****, this means that password was not changed"
		ifTrue: [^nil]. 
	aString trimBlanks isEmpty ifTrue: [^nil].
	^self password: aString! !

!WebUser methodsFor: 'private' stamp: 'janko 8/6/2011 19:44'!
person: aPerson
	"connect to parrallel Person from Party framework"
	self otherAt: #Person put: aPerson.
	aPerson asWebUser ~= self ifTrue: [aPerson webUser: self].! !

!WebUser methodsFor: 'accessing-address'!
phone 
	phone isNil ifTrue: [^''].
	^phone! !

!WebUser methodsFor: 'accessing-address'!
phone: aString 
	phone := aString.! !

!WebUser methodsFor: 'private'!
preferredUrl
	| nme |
	nme := self nameSurname trimBlanks asSloveneWithoutCircumflexes asHttpFriendly.
	^'/user/', nme! !

!WebUser methodsFor: 'private'!
printString 
	^'a', self class name, ' named ', self surname, ', ', self name, ' (', self username, ') '! !

!WebUser methodsFor: 'accessing-timestamps' stamp: 'janko 8/6/2011 19:42'!
registeredTimestamp
	"when this user was registered (personally or by someone else)"
	^self otherAt: #RegisteredTimestamp ifAbsent: [nil]! !

!WebUser methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:44'!
resetLocked
	"changes of user data allowed again"
	^self otherAt: #Locked put: false! !

!WebUser methodsFor: 'accessing-other' stamp: 'janko 8/6/2011 19:44'!
setLocked
	"changes of user data not allowed"
	^self otherAt: #Locked put: true! !

!WebUser methodsFor: 'private' stamp: 'janko 8/6/2011 19:44'!
setRegisteredTimestamp
	"when this user was registered (personally or by someone else)"
	^self otherAt: #RegisteredTimestamp put: SpTimestamp now! !

!WebUser methodsFor: 'accessing'!
site
	^self parent site! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
someId
	"just return some text, possibly surnameName"
	self surnameName trimBlanks notEmpty ifTrue: [^self surnameName].
	self email notEmpty ifTrue: [^self email].
	^'----'! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
surname
	surname isNil ifTrue: [self asPerson notNil ifTrue: [^self asPerson surname] ifFalse: [^''] ].
	^surname! !

!WebUser methodsFor: 'accessing'!
surname: aString 
	self isLocked ifTrue: [^self error: 'user locked, changes not allowed!! '].
	self asPerson notNil ifTrue: [^self asPerson surname: aString].
	surname := aString trimBlanks.! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
surnameName
	^self surname, ' ', self name! !

!WebUser methodsFor: 'security' stamp: 'janko 4/25/2012 13:10'!
unEscalateFromAdmin
	"cancel escalation of that user from admin rights"
	self isEscalatedToAdmin ifTrue:
		[self otherAt: #EscalatedToAdmin put: false].! !

!WebUser methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
username
 
	username isNil ifTrue: [^''].
	^username.! !

!WebUser methodsFor: 'accessing'!
username: aString 
	self isLocked ifTrue: [^self error: 'user locked, changes not allowed!! '].
	username := aString asLowercase trimBlanks.! !

!WebUser methodsFor: 'accessing' stamp: 'janko 8/6/2011 19:43'!
uuid
	"unique identifier "
	^self otherAt: #uuid ifAbsentPut: [(AIDASite random next * 1000000000) rounded printString]! !

!WebUser methodsFor: 'accessing-address'!
website
	website isNil ifTrue: [^''].
	^website! !

!WebUser methodsFor: 'accessing-address'!
website: aString
	website := aString! !

!WebUser methodsFor: 'accessing-address'!
zip
	zip isNil ifTrue: [^'']. 
	^zip! !

!WebUser methodsFor: 'accessing-address'!
zip: aString
	zip := aString.! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
adminEMail
	^'admin'! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
adminName
	^'Admin'! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
adminPassword
	^'password'! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
adminSurname
	^''! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
adminUsername
	^'admin'! !

!WebUser class methodsFor: 'defaults' stamp: 'mivsek 1/10/2008 19:04'!
extranetEMail
	^'extranet'! !

!WebUser class methodsFor: 'defaults' stamp: 'mivsek 1/10/2008 19:04'!
extranetName
	^'Extranet'! !

!WebUser class methodsFor: 'defaults' stamp: 'mivsek 1/10/2008 19:04'!
extranetPassword
	^'password'! !

!WebUser class methodsFor: 'defaults' stamp: 'mivsek 1/10/2008 19:04'!
extranetSurname
	^''! !

!WebUser class methodsFor: 'defaults' stamp: 'mivsek 1/10/2008 19:05'!
extranetUsername
	^'extranet'! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
guestEMail
	^'guest'! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
guestName
	^'Guest'! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
guestPassword
	^'guest'! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
guestSurname
	^''! !

!WebUser class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
guestUsername
	^'guest'! !

!WebUser class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
new
	^super new initialize! !

!WebUser class methodsFor: 'instance creation' stamp: 'janko 3/16/2008 13:30'!
newAdmin
	^self new
		name: self adminName;
		surname: self adminSurname;
		email: self adminEMail;
		username: self adminUsername;
		password: self adminPassword! !

!WebUser class methodsFor: 'instance creation' stamp: 'janko 3/16/2008 13:30'!
newExtranet
	"a common extranet user, for easier setup of access rights"
	^self new
		name: self extranetName;
		surname: self extranetSurname;
		email: self extranetEMail;
		username: self extranetUsername;
		password: self extranetPassword! !

!WebUser class methodsFor: 'instance creation' stamp: 'np 3/17/2008 21:43'!
newGuest
	^self new
		name: self guestName;
		surname: self guestSurname;
		email: self guestEMail;
		username: self guestUsername;
		password: self guestPassword! !

!WebUserGroup methodsFor: 'adding-removing'!
addUser: aWebUser
 	self users add: aWebUser.! !

!WebUserGroup methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
allUsers
	^self users copy! !

!WebUserGroup methodsFor: 'accessing'!
allUsersSorted
	"..by name and surname"
	^self allUsers asSortedCollection: [:a :b | a nameSurname < b nameSurname]! !

!WebUserGroup methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
includes: aWebUser
	^self users includes: aWebUser! !

!WebUserGroup methodsFor: 'initialize-release'!
initOther
	other := Dictionary new.! !

!WebUserGroup methodsFor: 'private' stamp: ' 21/4/07 22:07'!
initUsers 
	users  := Set new.! !

!WebUserGroup methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isActivatingGroup
	"group of users waiting to confirm registration"
	^self name = self class activatingGroupName! !

!WebUserGroup methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isAdminGroup
	^self name = self class adminGroupName! !

!WebUserGroup methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isAllUsersGroup
	^self name = self class allUsersGroupName! !

!WebUserGroup methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isGuestGroup
	^self name = self class guestGroupName! !

!WebUserGroup methodsFor: 'testing'!
isLocked
	"change or delete this group not allowed"
	^self otherAt: #Locked ifAbsent: [false]! !

!WebUserGroup methodsFor: 'testing' stamp: 'np 1/18/2008 11:23'!
isPerson
	^false! !

!WebUserGroup methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isRegisteredGroup
	^self name = self class registeredGroupName! !

!WebUserGroup methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebUser
	^false! !

!WebUserGroup methodsFor: 'testing' stamp: ' 21/4/07 22:07'!
isWebUserGroup
	^true! !

!WebUserGroup methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
menuName
	"in dropdown menus"
	^name! !

!WebUserGroup methodsFor: 'private' stamp: ' 21/4/07 22:07'!
migrateToUnicode
	"from iso8859-2"
	"WebUserGroup allInstances do: [:each | each migrateToUnicode]"
	name notNil ifTrue: [name := name ensureUnicodeSloveneChars].! !

!WebUserGroup methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
name
	name isNil ifTrue: [self name: '']. 
	^name! !

!WebUserGroup methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
name: aString
	name := aString.! !

!WebUserGroup methodsFor: 'private-other'!
other
	^other! !

!WebUserGroup methodsFor: 'private-other'!
otherAt: aSymbol
	^self otherAt: aSymbol ifAbsent: [nil]! !

!WebUserGroup methodsFor: 'private-other'!
otherAt: aSymbol ifAbsent: aBlock
	self other isNil ifTrue: [^aBlock value].
	^self other at: aSymbol ifAbsent: aBlock! !

!WebUserGroup methodsFor: 'private-other'!
otherAt: aSymbol ifAbsentPut: aBlock
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]! !

!WebUserGroup methodsFor: 'private-other'!
otherAt: aSymbol put: anObject
	self other isNil ifTrue: [self initOther].
	^self other at: aSymbol put: anObject! !

!WebUserGroup methodsFor: 'private'!
preferredUrl
	| nme |
	nme := self name trimBlanks asHttpFriendly.
	^'/group/', nme! !

!WebUserGroup methodsFor: 'private'!
printString
	^'aWebUserGroup: ', self name! !

!WebUserGroup methodsFor: 'adding-removing'!
removeUser: aWebUser
 	self users remove: aWebUser ifAbsent: [].! !

!WebUserGroup methodsFor: 'accessing-other'!
resetLocked
	"change or delete this group allowed again"
	^self otherAt: #Locked put: false! !

!WebUserGroup methodsFor: 'accessing-other'!
setLocked
	"change or delete this group not allowed"
	^self otherAt: #Locked put: true! !

!WebUserGroup methodsFor: 'private' stamp: ' 21/4/07 22:07'!
users
	users isNil ifTrue: [self initUsers]. 
	^users! !

!WebUserGroup methodsFor: 'accessing' stamp: ' 21/4/07 22:07'!
uuid
	"some unique identifier. Hash for now, probably unique enough!! "
	^self hash printString! !

!WebUserGroup class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
activatingGroupName
	"group of users waiting to confirm registration"
	^'Users waiting activation'! !

!WebUserGroup class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
adminGroupName
	"return a name of group for administrators" 
	^'Administrators'! !

!WebUserGroup class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
allUsersGroupName
	"return a name of group, where all users are there by default" 
	^'AllUsers'! !

!WebUserGroup class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
guestGroupName
	"return a name of group for guests" 
	^self allUsersGroupName! !

!WebUserGroup class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newActivating
	^super new name: self activatingGroupName! !

!WebUserGroup class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newAdmin
	^super new name: self adminGroupName! !

!WebUserGroup class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newAllUsers
	^super new name: self allUsersGroupName! !

!WebUserGroup class methodsFor: 'instance creation' stamp: ' 21/4/07 22:07'!
newRegistered
	^super new name: self registeredGroupName! !

!WebUserGroup class methodsFor: 'defaults' stamp: ' 21/4/07 22:07'!
registeredGroupName
	"return a name of group of registered users" 
	^'Registered Users'! !

!WebUserRole methodsFor: 'private' stamp: ' 10/1/08 16:41'!
printString
	^'aWebUserRole ', self name! !

!WebValidationError methodsFor: 'printing' stamp: 'janko 10/31/2011 20:25'!
build
	| text |
	self class: #validationError.	"CSS"	"red background etc. See DefaultWebStyle>>css231Validation"
	(self origin isNil or: [self origin isValid]) ifFalse:
		[text := self origin errorText trimBlanks.
		text isEmpty ifTrue: [text := 'Error!!'].
		self addText: text]! !

!WebValidationError methodsFor: 'accessing' stamp: ' 3/8/10 15:32'!
origin
	
	^origin! !

!WebValidationError methodsFor: 'accessing' stamp: 'jm 8/3/2010 15:38'!
origin: aWebFormElement
	
	origin := aWebFormElement! !

!WebValidationError class methodsFor: 'instance creation'!
newFor: aFormElement
	^super new
		origin: aFormElement;
		build! !

!WebVideo methodsFor: 'attributes'!
autoplay
	"video will start playing as soon as it is ready"
	self attributes at: #autoplay put: true! !

!WebVideo methodsFor: 'attributes'!
controls: aString
	"Specifies that video controls should be displayed (such as a play/pause button etc)."
	self attributes at: #controls put: aString! !

!WebVideo methodsFor: 'attributes'!
height: anInteger
	self attributesAt: #height put: anInteger printString! !

!WebVideo methodsFor: 'attributes'!
loop
	"video will start over again, every time it is finished"
	self attributes at: #loop put: true! !

!WebVideo methodsFor: 'attributes'!
muted
	"audio output of the video should be muted"
	self attributes at: #muted put: true! !

!WebVideo methodsFor: 'attributes'!
poster: anUrlString
	"Specifies an image to be shown while the video is downloading, or until the user hits the play button"
	self attributes at: #poster put: anUrlString! !

!WebVideo methodsFor: 'attributes'!
preload: aSymbol
	"Specifies if and how the author thinks the video should be loaded when the page loads"
	" #auto #metadata or #none "
	self attributes at: #preload put: aSymbol asString! !

!WebVideo methodsFor: 'attributes'!
size: aPoint
	"set the size of a video player in format width@height"
	self width: aPoint x.
	self height: aPoint y.! !

!WebVideo methodsFor: 'attributes'!
src: anUrlString
	"Specifies the URL of the video file"
	" #auto #metadata or #none "
	self attributes at: #src put: anUrlString! !

!WebVideo methodsFor: 'private'!
tag
	^#video! !

!WebVideo methodsFor: 'attributes'!
text: aString
	"will be shown if browser does not support video"
	self addText: aString! !

!WebVideo methodsFor: 'attributes'!
width: anInteger
	self attributesAt: #width put: anInteger printString! !

!WebWidget methodsFor: 'private' stamp: 'janko 10/27/2011 12:42'!
add: anElement
	"all adding delegated to the form"
	self form add: anElement.
	anElement postAddAction.
	^anElement! !

!WebWidget methodsFor: 'views' stamp: 'janko 10/27/2011 11:28'!
ajaxUpdate
	"update a widget from the Ajax call"
	"override if you want to update a widget differently"
	self rebuild.! !

!WebWidget methodsFor: 'accessing'!
app
	"an App on which this widget is built"
	^self parent notNil 
		ifTrue: [self parent app]
		ifFalse: [self context app]! !

!WebWidget methodsFor: 'views' stamp: 'janko 10/27/2011 11:29'!
build
	"Build your widget by overriding this method. #build is called in two occassions: first when this 
	widget is first built and second from every Ajax update call"! !

!WebWidget methodsFor: 'testing'!
buildImmediatelly
	"shall we build a widget immediatelly when a widget is created?"
	"override in your sublclass if needed"
	^true! !

!WebWidget methodsFor: 'testing'!
buildWhileStreaming
	"shall we build a widget in a streaming state, just before starting to stream to response?"
	"override in your sublclass if needed"
	^false! !

!WebWidget methodsFor: 'views' stamp: 'janko 10/31/2011 20:37'!
clear
	self initElements.
	self clearTableInfo.
	self initScripts.
	self initForm.
	(self parent notNil and: [self parent form notNil]) ifTrue:
		[self parent form addSubform: self form]! !

!WebWidget methodsFor: 'accessing'!
form
	"WebForm is first and only subelement of the widget, all element addings go to it and not direclty to widget!!"
	self elements isEmpty ifTrue: [self initForm].
	^self elements first! !

!WebWidget methodsFor: 'events-actions'!
ifFalse: aBlock
	"run a block if answer is set to false when this widget is closed"
	self onCloseDo:
		[self context answer = false ifTrue: [aBlock value] ]! !

!WebWidget methodsFor: 'events-actions'!
ifTrue: aBlock
	"run a block if answer is set to true when this widget is closed"
	self onCloseDo:
		[self context answer = true ifTrue: [aBlock value] ]! !

!WebWidget methodsFor: 'events-actions'!
ifTrue: aTrueBlock ifFalse: aFalseBlock
	"run appropriate block if result is set to true or false when this widget is closed"
	self ifTrue: [aTrueBlock value].
	self ifFalse: [aFalseBlock value].! !

!WebWidget methodsFor: 'initialize-release'!
initForm
	"WebForm is a first element in a widget  and all adds go to this form and not direclty to the widget!! "
	(self elements add: (WebForm new parent: self))
		registerId! !

!WebWidget methodsFor: 'initialize-release' stamp: 'NicolasPetton 11/2/2011 12:28'!
initialize
	super initialize.
	self
		creationObject: self;
		creationMethod: #ajaxUpdate; "be sure to change it accordingly in subclasses if needed!! "
		creationContext: self context;
		setDiv; registerId; "Widgets must always have a web element id!! "
		attributesAt: #comment put: self class name; "unofficial attribute, just for easier debuging in browser"
		initForm;
		setStateComposing.
	self buildImmediatelly ifTrue: [self build]! !

!WebWidget methodsFor: 'state'!
isComposing
	"widget (or window or page) is in building state, composing from web elements"
	^state = #composing! !

!WebWidget methodsFor: 'state'!
isFinished
	"composing and streaming finished"
	^state = #finished! !

!WebWidget methodsFor: 'testing'!
isPureWidget
	"not a window or page, which are also widgets, as subclasses"
	^self isWebWindow not! !

!WebWidget methodsFor: 'state'!
isStreaming
	"printing, that is streaming to the tcp socket"
	^state = #streaming! !

!WebWidget methodsFor: 'testing'!
isWebWidget
	^true! !

!WebWidget methodsFor: 'events-actions'!
onAnswerDo: aBlock
	"if widget returns some answer on close, run that block with answer as an argument"
	self onCloseDo:
		[self context answer notNil ifTrue: 
			[aBlock value: self context answer] ]! !

!WebWidget methodsFor: 'events-actions'!
onCloseDo: aBlock
	"execute that block when this widget is closed"
	"Triggered in WebEventHandler addCloseWindow block"
	(self eventHandlerFor: #close)  "close is pseudo event, not browser native"
		addActionBlock: aBlock.! !

!WebWidget methodsFor: 'accessing'!
page
	"a webpage on which this widget resides"
	^self context page! !

!WebWidget methodsFor: 'private'!
postAddAction
	| sform c |
	sform := (self parent notNil and: [self parent creationObject notNil])
		ifTrue: [self parent form]
		ifFalse: 
			[c := (self widgetsAndAppsFromStack at: 2). "skip first because it is this widget"
			c isWebWidget ifTrue: [c form] ifFalse: [self context form] ].
	sform addSubform: self form.! !

!WebWidget methodsFor: 'views' stamp: 'janko 10/27/2011 11:28'!
rebuild
	"Rebuld first clears then builds this widget again. Used mostly to update a widget from Ajax update call"
	self clear.
	self build.
! !

!WebWidget methodsFor: 'accessing'!
session
	"a session on which this widget is built"
	^self app session! !

!WebWidget methodsFor: 'state'!
setComposing
	state := #composing! !

!WebWidget methodsFor: 'state'!
setFinished
	state := #finished! !

!WebWidget methodsFor: 'state'!
setStateComposing
	state := #composing! !

!WebWidget methodsFor: 'state'!
setStateFinished
	state := #finished! !

!WebWidget methodsFor: 'state'!
setStateStreaming
	state := #streaming! !

!WebWidget methodsFor: 'accessing'!
site
	"a website on which this widget is built"
	^self app site! !

!WebWidget methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession 
	self buildWhileStreaming
		ifTrue: [self build].
	self registerFormElementsTo: self form.	
	self setStateStreaming.
	super streamHtmlTo: aStream for: aRequest on: aSession.
	self setStateFinished.! !

!WebWidget methodsFor: 'events-actions'!
update
	"update (recreate or refresh) that widget by returning a recreated one"
	| superform new |
	superform := self form superform.
	superform notNil ifTrue: 
		[superform removeSubform: self form.
		superform isTopForm ifTrue: [self parent: nil] ]. "probably from previous popup with now nonexistent context"
	self context cancelReplacement. "widget is rebuilt, not replaced with new instance!!"
	new := (self creationMethod asString last = $: )
		ifTrue: [self creationObject perform: self creationMethod with: self updateArgument] 
		ifFalse: [self updateArgument notNil  "try to call the method with that argument"
			ifTrue: [self creationObject perform: (self creationMethod, ':') asSymbol with: self updateArgument]
			ifFalse: [self creationObject perform: self creationMethod] ].
	superform notNil ifTrue: 
		[superform isTopForm ifTrue: [superform := self context window form]. "new popup context!!"
		superform addSubform: new form].
	self session queueUpdateElement: new. "to be sent immediatelly via WebSocket if open, or in Ajax response"
	^new! !

!WebWidget methodsFor: 'accessing'!
user
	"a currently logged-in user on the session on which this widget is built"
	^self session user! !

!WebWidget methodsFor: 'private'!
widget
	^self! !

!WebWidget class methodsFor: 'instance creation' stamp: 'NicolasPetton 11/2/2011 12:29'!
new
	^self basicNew initialize! !

!WebWindow methodsFor: 'accessing'!
app
	^self context app! !

!WebWindow methodsFor: 'initialize-release'!
clear
	self setStateComposing.
	^self form clear! !

!WebWindow methodsFor: 'accessing'!
close
	"close that window and also its execution context. Call this method from Ajax closing link 
	on the window"
	"only the subwindow can be closed that way, not a main page"
	self context close.! !

!WebWindow methodsFor: 'accessing' stamp: 'janko 11/1/2011 14:46'!
context
	^self parent notNil 
		ifTrue: [self parent]
		ifFalse: [self firstContextFromStack]! !

!WebWindow methodsFor: 'accessing'!
form
	"form is a second, not first element in Window, first is popup stub"
	^self elements at: 2! !

!WebWindow methodsFor: 'initialize-release'!
initPopupStub
	self elements first isStubElement ifTrue: [^nil].
	self elements addFirst: 
		(WebStubElement newOn: self firstContextFromStack)! !

!WebWindow methodsFor: 'testing'!
isWebWindow
	^true! !

!WebWindow methodsFor: 'private'!
parent: aContext
	"temporary, for debugging!!"
	^super parent: aContext! !

!WebWindow methodsFor: 'accessing'!
popupStub
	"empty stub element for eventual popup window"
	self elements first isStubElement ifFalse: [^self error: 'not a popup stub!! '].
	^self elements first! !

!WebWindow methodsFor: 'private'!
popupStyle
	"for popup windows. Because they are stackable, we need to consider a level in the stack too"
	| level lvl |
	level :=self context level. lvl := level printString.
	^ '
form {width: 100%}
div#overlay', lvl ,' {
	position: fixed;
	width: 100%;
	height: 100%;
	z-index: ', (9000+(level*2)) printString, ';
	background-color: black;
	filter: alpha(opacity=10);
	-moz-opacity: 0.1;
	opacity: 0.1;
}
div#lightbox', lvl, ' { 
	background: #ffffff;
	z-index: ', (9001+(level*2)) printString, ';
	padding: 10px;
	border: 5px solid #888888;
	border-radius: 10px;
	box-shadow: 0 0 10px #333333;
}'! !

!WebWindow methodsFor: 'subelements'!
registerFormElementsTo: aWebForm
	self form initSubforms. "to avoid accumulating subforms during posting on the same page"
	^super registerFormElementsTo: aWebForm! !

!WebWindow methodsFor: 'private'!
shouldIdent
	^true! !

!WebWindow methodsFor: 'private'!
streamHtmlTo: aStream for: aRequest on: aSession
	self prepareToHtmlStreamingOn: aSession.
	self setStateStreaming.
	super streamHtmlTo: aStream for: aRequest on: aSession. "a form"
	self setStateFinished.! !

!WebWindow class methodsFor: 'instance creation'!
new
	^super new
		initPopupStub! !
AIDASite initialize!
GifImageStream initialize!
ImageStream initialize!
WebTransactionMonitor initialize!
